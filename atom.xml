<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZJQian&#39;s Blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-16T13:19:20.868Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZJQian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react-navigation 使用详解</title>
    <link href="http://yoursite.com/2018/04/12/react-navigation-detail/"/>
    <id>http://yoursite.com/2018/04/12/react-navigation-detail/</id>
    <published>2018-04-12T02:25:39.000Z</published>
    <updated>2018-04-16T13:19:20.868Z</updated>
    
    <content type="html"><![CDATA[<p>转自: <a href="https://blog.csdn.net/u013718120/article/details/72357698" target="_blank" rel="noopener">这里</a></p><h2 id="一、开源库介绍"><a href="#一、开源库介绍" class="headerlink" title="一、开源库介绍"></a>一、开源库介绍</h2><p>今年1月份，新开源的<code>react-natvigation</code>库备受瞩目。在短短不到3个月的时间，<code>github</code>上星数已达4000+。Fb推荐使用库，并且在<code>React Native</code>当前最新版本0.44中将<code>Navigator</code>删除。<code>react-navigation</code>据称有原生般的性能体验效果。<a id="more"></a> 可能会成为未来<code>React Native</code>导航组件的主流军。本篇内容基于【 ^1.0.0-beta.9 】版本来介绍关于该库的使用和实战技巧。可以看到，虽然是beta版本，不过基本稳定，大家可放心在项目中使用。</p><p>该库包含三类组件：</p><blockquote><p>（1）StackNavigator：用来跳转页面和传递参数<br>（2）TabNavigator：类似底部导航栏，用来在同一屏幕下切换不同界面<br>（3）DrawerNavigator：侧滑菜单导航栏，用于轻松设置带抽屉导航的屏幕</p></blockquote><h2 id="二、react-navigation使用"><a href="#二、react-navigation使用" class="headerlink" title="二、react-navigation使用"></a>二、react-navigation使用</h2><p>具体内容大致分为如下：</p><blockquote><p>（1）react-navigation库属性介绍</p><p>（2）StackNavigator、TabNavigator实现界面间跳转，Tab切换</p><p>（3）StackNavigator界面间跳转、传值、取值</p><p>（4）DrawerNavigator实现抽屉导航菜单</p><p>（5）DrawerNavigator扩展功能</p></blockquote><h3>1、StackNavigator属性介绍</h3><p>navigationOptions：配置StackNavigator的一些属性。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">title：标题，如果设置了这个导航栏和标签栏的title就会变成一样的，不推荐使用  </span><br><span class="line">   header：可以设置一些导航的属性，如果隐藏顶部导航栏只要将这个属性设置为null  </span><br><span class="line">   headerTitle：设置导航栏标题，推荐  </span><br><span class="line">   headerBackTitle：设置跳转页面左侧返回箭头后面的文字，默认是上一个页面的标题。可以自定义，也可以设置为null  </span><br><span class="line">   headerTruncatedBackTitle：设置当上个页面标题不符合返回箭头后的文字时，默认改成&quot;返回&quot;  </span><br><span class="line">   headerRight：设置导航条右侧。可以是按钮或者其他视图控件  </span><br><span class="line">   headerLeft：设置导航条左侧。可以是按钮或者其他视图控件  </span><br><span class="line">   headerStyle：设置导航条的样式。背景色，宽高等  </span><br><span class="line">   headerTitleStyle：设置导航栏文字样式  </span><br><span class="line">   headerBackTitleStyle：设置导航栏‘返回’文字样式  </span><br><span class="line">   headerTintColor：设置导航栏颜色  </span><br><span class="line">   headerPressColorAndroid：安卓独有的设置颜色纹理，需要安卓版本大于5.0  </span><br><span class="line">   gesturesEnabled：是否支持滑动返回手势，iOS默认支持，安卓默认关闭  </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">screen：对应界面名称，需要填入import之后的页面  </span><br><span class="line"> </span><br><span class="line">mode：定义跳转风格  </span><br><span class="line"> </span><br><span class="line">  card：使用iOS和安卓默认的风格  </span><br><span class="line"> </span><br><span class="line">  modal：iOS独有的使屏幕从底部画出。类似iOS的present效果  </span><br><span class="line"> </span><br><span class="line">  headerMode：返回上级页面时动画效果  </span><br><span class="line"> </span><br><span class="line">  float：iOS默认的效果  </span><br><span class="line"> </span><br><span class="line">  screen：滑动过程中，整个页面都会返回  </span><br><span class="line"> </span><br><span class="line">  none：无动画  </span><br><span class="line"> </span><br><span class="line">  cardStyle：自定义设置跳转效果  </span><br><span class="line"> </span><br><span class="line">  transitionConfig： 自定义设置滑动返回的配置  </span><br><span class="line"> </span><br><span class="line">  onTransitionStart：当转换动画即将开始时被调用的功能  </span><br><span class="line"> </span><br><span class="line">  onTransitionEnd：当转换动画完成，将被调用的功能  </span><br><span class="line"> </span><br><span class="line">  path：路由中设置的路径的覆盖映射配置  </span><br><span class="line"> </span><br><span class="line"> initialRouteName：设置默认的页面组件，必须是上面已注册的页面组件  </span><br><span class="line"> </span><br><span class="line"> initialRouteParams：初始路由参数</span><br></pre></td></tr></table></figure><p><strong>注：大家可能对于<code>path</code>不太理解。<code>path</code>属性适用于其他<code>app</code>或浏览器使用url打开本<code>app</code>并进入指定页面。<code>path</code>属性用于声明一个界面路径，例如：<code>【/pages/Home】</code>。此时我们可以在手机浏览器中输入：<code>app名称://pages/Home</code>来启动该<code>App</code>，并进入<code>Home</code>界面。</strong></p><h3>2、TabNavigator属性介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">screen：和导航的功能是一样的，对应界面名称，可以在其他页面通过这个screen传值和跳转。  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">navigationOptions：配置TabNavigator的一些属性  </span><br><span class="line">  </span><br><span class="line">title：标题，会同时设置导航条和标签栏的title  </span><br><span class="line">  </span><br><span class="line">tabBarVisible：是否隐藏标签栏。默认不隐藏(true)  </span><br><span class="line">  </span><br><span class="line">tabBarIcon：设置标签栏的图标。需要给每个都设置  </span><br><span class="line">  </span><br><span class="line">tabBarLabel：设置标签栏的title。推荐  </span><br><span class="line">  </span><br><span class="line">导航栏配置  </span><br><span class="line">  </span><br><span class="line">tabBarPosition：设置tabbar的位置，iOS默认在底部，安卓默认在顶部。（属性值：&apos;top&apos;，&apos;bottom&apos;）  </span><br><span class="line">  </span><br><span class="line">swipeEnabled：是否允许在标签之间进行滑动  </span><br><span class="line">  </span><br><span class="line">animationEnabled：是否在更改标签时显示动画  </span><br><span class="line">  </span><br><span class="line">lazy：是否根据需要懒惰呈现标签，而不是提前，意思是在app打开的时候将底部标签栏全部加载，默认false,推荐为true  </span><br><span class="line">  </span><br><span class="line">trueinitialRouteName： 设置默认的页面组件  </span><br><span class="line">  </span><br><span class="line">backBehavior：按 back 键是否跳转到第一个Tab(首页)， none 为不跳转  </span><br><span class="line">  </span><br><span class="line">tabBarOptions：配置标签栏的一些属性iOS属性  </span><br><span class="line">  </span><br><span class="line">activeTintColor：label和icon的前景色 活跃状态下  </span><br><span class="line">  </span><br><span class="line">activeBackgroundColor：label和icon的背景色 活跃状态下  </span><br><span class="line">  </span><br><span class="line">inactiveTintColor：label和icon的前景色 不活跃状态下  </span><br><span class="line">  </span><br><span class="line">inactiveBackgroundColor：label和icon的背景色 不活跃状态下  </span><br><span class="line">  </span><br><span class="line">showLabel：是否显示label，默认开启 style：tabbar的样式  </span><br><span class="line">  </span><br><span class="line">labelStyle：label的样式安卓属性  </span><br><span class="line">  </span><br><span class="line">activeTintColor：label和icon的前景色 活跃状态下  </span><br><span class="line">  </span><br><span class="line">inactiveTintColor：label和icon的前景色 不活跃状态下  </span><br><span class="line">  </span><br><span class="line">showIcon：是否显示图标，默认关闭  </span><br><span class="line">  </span><br><span class="line">showLabel：是否显示label，默认开启 style：tabbar的样式  </span><br><span class="line">  </span><br><span class="line">labelStyle：label的样式 upperCaseLabel：是否使标签大写，默认为true  </span><br><span class="line">  </span><br><span class="line">pressColor：material涟漪效果的颜色（安卓版本需要大于5.0）  </span><br><span class="line">  </span><br><span class="line">pressOpacity：按压标签的透明度变化（安卓版本需要小于5.0）  </span><br><span class="line">  </span><br><span class="line">scrollEnabled：是否启用可滚动选项卡 tabStyle：tab的样式  </span><br><span class="line">  </span><br><span class="line">indicatorStyle：标签指示器的样式对象（选项卡底部的行）。安卓底部会多出一条线，可以将height设置为0来暂时解决这个问题  </span><br><span class="line">  </span><br><span class="line">labelStyle：label的样式  </span><br><span class="line">  </span><br><span class="line">iconStyle：图标样式</span><br></pre></td></tr></table></figure><h3>3、DrawerNavigator属性介绍<h3><br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DrawerNavigatorConfig  </span><br><span class="line">  </span><br><span class="line">    drawerWidth - 抽屉的宽度  </span><br><span class="line">    drawerPosition - 选项是左或右。 默认为左侧位置  </span><br><span class="line">    contentComponent - 用于呈现抽屉内容的组件，例如导航项。 接收抽屉的导航。 默认为DrawerItems  </span><br><span class="line">    contentOptions - 配置抽屉内容  </span><br><span class="line">  </span><br><span class="line">    initialRouteName - 初始路由的routeName  </span><br><span class="line">    order - 定义抽屉项目顺序的routeNames数组。  </span><br><span class="line">    路径 - 提供routeName到路径配置的映射，它覆盖routeConfigs中设置的路径。  </span><br><span class="line">    backBehavior - 后退按钮是否会切换到初始路由？ 如果是，设置为initialRoute，否则为none。 默认为initialRoute行为  </span><br><span class="line">  </span><br><span class="line">   DrawerItems的contentOptions属性  </span><br><span class="line">  </span><br><span class="line">    activeTintColor - 活动标签的标签和图标颜色  </span><br><span class="line">    activeBackgroundColor - 活动标签的背景颜色  </span><br><span class="line">    inactiveTintColor - 非活动标签的标签和图标颜色  </span><br><span class="line">    inactiveBackgroundColor - 非活动标签的背景颜色  </span><br><span class="line">    内容部分的样式样式对象  </span><br><span class="line">    labelStyle - 当您的标签是字符串时，要覆盖内容部分中的文本样式的样式对象</span><br></pre></td></tr></table></figure><br><br><br>从上述中大致了解了<code>react-navigation</code>三种组件的一些基本属性，所以到我们甩起袖子撸代码见证下奇迹了。<br><br><h3>4、使用StackNavigator + TabNavigator实现Tab界面切换、界面间导航</h3><p>API定义：StackNavigator(RouteConfigs, StackNavigatorConfig)、TabNavigator(RouteConfigs, TabNavigatorConfig)</p><blockquote><p>（1）集成 react-navigation：在终端执行 【 npm install react-navigation –save 】</p><p>（2）界面中导入必要组件：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;StackNavigator,TabNavigator,TabBarBottom&#125; from &apos;react-navigation&apos;;  </span><br><span class="line">import HomeScreen from &apos;./pages/HomePage&apos;;  </span><br><span class="line">import MineScreen from &apos;./pages/MinePage&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>（3）定义TabNavigator：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">const Tab = TabNavigator(  </span><br><span class="line">  &#123;  </span><br><span class="line">    Home:&#123;  </span><br><span class="line">      screen:HomeScreen,  </span><br><span class="line">      navigationOptions:(&#123;navigation&#125;) =&gt; (&#123;  </span><br><span class="line">        tabBarLabel:&apos;首页&apos;,  </span><br><span class="line">        tabBarIcon:(&#123;focused,tintColor&#125;) =&gt; (  </span><br><span class="line">          &lt;TabBarItem  </span><br><span class="line">            tintColor=&#123;tintColor&#125;  </span><br><span class="line">            focused=&#123;focused&#125;  </span><br><span class="line">            normalImage=&#123;require(&apos;./imgs/nav_fav@2x.png&apos;)&#125;  </span><br><span class="line">            selectedImage=&#123;require(&apos;./imgs/nav_fav_actived@3x.png&apos;)&#125;  </span><br><span class="line">          /&gt;  </span><br><span class="line">        )  </span><br><span class="line">      &#125;),  </span><br><span class="line">    &#125;,  </span><br><span class="line">  </span><br><span class="line">    Mine:&#123;  </span><br><span class="line">          screen:MineScreen,  </span><br><span class="line">          navigationOptions:(&#123;navigation&#125;) =&gt; (&#123;  </span><br><span class="line">          tabBarLabel:&apos;我&apos;,  </span><br><span class="line">          tabBarIcon:(&#123;focused,tintColor&#125;) =&gt; (  </span><br><span class="line">            &lt;TabBarItem  </span><br><span class="line">             tintColor=&#123;tintColor&#125;  </span><br><span class="line">              focused=&#123;focused&#125;  </span><br><span class="line">              normalImage=&#123;require(&apos;./imgs/tab_me_nor@3x.png&apos;)&#125;  </span><br><span class="line">              selectedImage=&#123;require(&apos;./imgs/tab_me_selected@2x.png&apos;)&#125;  </span><br><span class="line">            /&gt;  </span><br><span class="line">          )  </span><br><span class="line">        &#125;),  </span><br><span class="line">      &#125;,  </span><br><span class="line">    &#125;,  </span><br><span class="line">  </span><br><span class="line">    &#123;  </span><br><span class="line">      tabBarComponent:TabBarBottom,  </span><br><span class="line">      tabBarPosition:&apos;bottom&apos;,  </span><br><span class="line">      swipeEnabled:false,  </span><br><span class="line">      animationEnabled:false,  </span><br><span class="line">      lazy:true,  </span><br><span class="line">      tabBarOptions:&#123;  </span><br><span class="line">        activeTintColor:&apos;#06c1ae&apos;,  </span><br><span class="line">        inactiveTintColor:&apos;#979797&apos;,  </span><br><span class="line">        style:&#123;backgroundColor:&apos;#ffffff&apos;,&#125;,  </span><br><span class="line">        labelStyle: &#123;  </span><br><span class="line">              fontSize: 20, // 文字大小  </span><br><span class="line">          &#125;,  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>TabBarItem为封装的组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123;Component&#125; from &apos;react&apos;;  </span><br><span class="line">import &#123;Image&#125; from &apos;react-native&apos;;  </span><br><span class="line">  </span><br><span class="line">export default class TabBarItem extends Component &#123;  </span><br><span class="line">  </span><br><span class="line">    render() &#123;  </span><br><span class="line">        return(  </span><br><span class="line">            &lt;Image source=&#123; this.props.focused ? this.props.selectedImage : this.props.normalImage &#125;  </span><br><span class="line">                style=&#123; &#123; tintColor:this.props.tintColor,width:25,height:25 &#125; &#125;  </span><br><span class="line">            /&gt;  </span><br><span class="line">        )  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们定义了一个名称为【Tab】的TabNavigator的导航组件。在组件中，分为两层参数：</p><blockquote><p>（1）第一层参数定义了要切换的界面，即【首页】、【我】两个界面组件，通过screen属性指定。并且通过navigationOptions属性设置相关属性参数。</p><p>（2）设置导航栏的属性参数。</p></blockquote><p><code>TabNavigator</code>定义好之后，需要用<code>StackNavigator</code>，顾名思义，<code>StackNavigator</code>就是以栈的方式来存放整个界面的，而<code>TabNavigator</code>是作为一个界面内不同子界面之间切换。所以还需要我们定义<code>StackNavigator</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const Navigator = StackNavigator(  </span><br><span class="line">    </span><br><span class="line">  &#123;  </span><br><span class="line">    Tab:&#123;screen:Tab&#125;,  </span><br><span class="line">    Product:&#123;screen:ProductScreen&#125;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  </span><br><span class="line">  &#123;  </span><br><span class="line">    navigationOptions:&#123;  </span><br><span class="line">      headerBackTitle:null,  </span><br><span class="line">      headerTintColor:&apos;#333333&apos;,  </span><br><span class="line">      showIcon:true,  </span><br><span class="line">     swipeEnabled:false,  </span><br><span class="line">     animationEnabled:false,  </span><br><span class="line">    &#125;,  </span><br><span class="line">  </span><br><span class="line">    mode:&apos;card&apos;,  </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>看起来和<code>TabNavigator</code>很相似，同样是指定了两个参数：</p><blockquote><p>（1）指定要跳转的界面组件。同样是screen属性标识界面组件，不多赘述。</p><p>（2）定义跳转属性参数，即顶部导航栏的一些参数设置和跳转方式。</p></blockquote><p>可以看到，我们将<code>Tab</code>作为一个界面设置到了<code>StackNavigator</code>。这样就可以实现Tab导航和界面间跳转的效果了。</p><p>最后就是在<code>render</code>中引用<code>StackNavigator</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default class Demo extends Component &#123;  </span><br><span class="line">  </span><br><span class="line">  render() &#123;  </span><br><span class="line">        return (  </span><br><span class="line">          &lt;Navigator /&gt;  </span><br><span class="line">        );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StackNavigator</code>还提供了<code>onNavigationStateChange</code>回调方法，用来监听导航状态的改变。具体不再赘述。实现了界面跳转和切换，那么就该来增加下界面之间的感情了，来看看如何实现界面之间的传值和取值。</p><h3>5、界面间跳转、传值、取值</h3><p>在界面组件注入到<code>StackNavigator</code>中时，界面组件就被赋予了<code>navigation</code>属性，即在界面组件中可以通过<code>【this.props.navigation】</code>获取并进行一些操作。</p><p><code>navigation</code>属性中提供了很多的函数简化界面间操作，简单列举几点：</p><blockquote><p>（1）通过navigate函数实现界面之间跳转：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.props.navigation.navigate(&apos;Mine&apos;);</span><br></pre></td></tr></table></figure><p>参数为我们在<code>StackNavigator</code>注册界面组件时的名称。同样也可以从当前页面返回到上一页：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 返回上一页  </span><br><span class="line">this.props.navigation.goBack();</span><br></pre></td></tr></table></figure><blockquote><p>（2）跳转时传值：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.props.navigation.navigate(&apos;Mine&apos;,&#123;info:&apos;传值过去&apos;&#125;);</span><br></pre></td></tr></table></figure><p>第一个参数同样为要跳转的界面组件名称，第二个参数为要传递的参数，info可以理解为key，后面即传递的参数。</p><blockquote><p>（3）获取值：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;this.props.navigation.state.params.info&#125;</span><br></pre></td></tr></table></figure><p>通过<code>state.params</code>来获取传来的参数，后面为<code>key</code>值。此处为<code>info</code>。</p><p>以上实现完成，我们就可以愉快的玩耍啦~~ 什么？忽然发现在Android上的效果和IOS效果不一样。老板要界面一致哇~ 怎么办？那就需要我们进行简单的适配了。</p><h2 id="三、DrawerNavigator实现抽屉导航"><a href="#三、DrawerNavigator实现抽屉导航" class="headerlink" title="三、DrawerNavigator实现抽屉导航"></a>三、DrawerNavigator实现抽屉导航</h2><h3>1、导航实现</h3><p>API定义：DrawerNavigator（RouteConfigs，DrawerNavigatorConfig）</p><blockquote><p>（1）界面中定义DrawerNavigator：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123;StackNavigator,TabNavigator,DrawerNavigator&#125; from &apos;react-navigation&apos;;  </span><br><span class="line">import HomeScreen from &apos;./pages/HomePage&apos;;  </span><br><span class="line">import MineScreen from &apos;./pages/MinePage&apos;;  </span><br><span class="line">  </span><br><span class="line">export default class Demo extends Component &#123;  </span><br><span class="line">  </span><br><span class="line">  render() &#123;  </span><br><span class="line">        return (  </span><br><span class="line">          &lt;Navigator /&gt;  </span><br><span class="line">        );  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">const Navigator = DrawerNavigator(&#123;  </span><br><span class="line">  </span><br><span class="line">    Home:&#123;screen:HomeScreen&#125;,  </span><br><span class="line">    Mine:&#123;screen:MineScreen&#125;,  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">const styles = StyleSheet.create(&#123;  </span><br><span class="line">  </span><br><span class="line">    container: &#123;  </span><br><span class="line">        flex: 1,  </span><br><span class="line">    &#125;,  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">AppRegistry.registerComponent(&apos;Demo&apos;, () =&gt; Demo);</span><br></pre></td></tr></table></figure><p>定义方式和<code>StackNavigator</code>基本类似，不再赘述。</p><blockquote><p>（2）HomeScreen界面和MineScreen界面：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">export default class HomePage extends Component &#123;  </span><br><span class="line">  </span><br><span class="line">    static navigationOptions = &#123;  </span><br><span class="line">        drawerLabel: &apos;首页&apos;,  </span><br><span class="line">        drawerIcon:(&#123;tintColor&#125;) =&gt; (  </span><br><span class="line">            &lt;Image  </span><br><span class="line">                source=&#123;require(&apos;./../imgs/ic_happy.png&apos;)&#125;  </span><br><span class="line">                style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125;/&gt;  </span><br><span class="line">        ),  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    render() &#123;  </span><br><span class="line">        return(  </span><br><span class="line">            &lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;  </span><br><span class="line">                &lt;Text onPress=&#123;this._skip.bind(this)&#125;&gt;点击跳转&lt;/Text&gt;  </span><br><span class="line">            &lt;/View&gt;  </span><br><span class="line">        );  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    _skip() &#123;  </span><br><span class="line">        this.props.navigation.navigate(&quot;Mine&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">export default class MinePage extends Component &#123;  </span><br><span class="line">  </span><br><span class="line">    static navigationOptions = &#123;  </span><br><span class="line">        drawerLabel:&apos;我&apos;,  </span><br><span class="line">         drawerIcon: (&#123; tintColor &#125;) =&gt; (  </span><br><span class="line">            &lt;Image  </span><br><span class="line">                source=&#123;require(&apos;./../imgs/ic_h.png&apos;)&#125;  </span><br><span class="line">                style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125;  </span><br><span class="line">            /&gt;  </span><br><span class="line">        ),  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    render() &#123;  </span><br><span class="line">        return(  </span><br><span class="line">            &lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;  </span><br><span class="line">                &lt;Text onPress=&#123;this._skip.bind(this)&#125;&gt;返回上一界面&lt;/Text&gt;  </span><br><span class="line">            &lt;/View&gt;  </span><br><span class="line">        );  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * 跳转  </span><br><span class="line">     */  </span><br><span class="line">    _skip() &#123;  </span><br><span class="line">        this.props.navigation.goBack();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，实现了界面之间的跳转。</p><h3>2、扩展功能</h3><blockquote><p>（1）默认DrawerView不可滚动。要实现可滚动视图，必须使用contentComponent自定义容器，如下所示：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  drawerWidth：200，  </span><br><span class="line">  抽屉位置：“对”  </span><br><span class="line">  contentComponent：props =&gt; &lt;ScrollView&gt; &lt;DrawerItems &#123;... props&#125; /&gt; &lt;/ ScrollView&gt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（2）可以覆盖导航使用的默认组件，使用DrawerItems自定义导航组件：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;DrawerItems&#125; from &apos;react-navigation&apos;;  </span><br><span class="line">  </span><br><span class="line">const CustomDrawerContentComponent = (props) =&gt; (  </span><br><span class="line">  &lt;View style = &#123;style.container&#125;&gt;  </span><br><span class="line">    &lt;DrawerItems &#123;... props&#125; /&gt;  </span><br><span class="line">  &lt;/View&gt;    </span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>（3）嵌套抽屉导航</p></blockquote><p>如果您嵌套<code>DrawerNavigation</code>，抽屉将显示在父导航下方。</p><h2 id="五、效果图"><a href="#五、效果图" class="headerlink" title="五、效果图"></a>五、效果图</h2><p>抽屉导航：<br><img src="https://img-blog.csdn.net/20170517171824737" alt="这里写图片描述"></p><p>以上就是我们实战中常用的属性和技巧。具体的操作还需要大家在实践过程中测试体会。</p><p><a href="https://github.com/songxiaoliang/ComicApp" target="_blank" rel="noopener">源码参考</a></p></h3></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自: &lt;a href=&quot;https://blog.csdn.net/u013718120/article/details/72357698&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、开源库介绍&quot;&gt;&lt;a href=&quot;#一、开源库介绍&quot; class=&quot;headerlink&quot; title=&quot;一、开源库介绍&quot;&gt;&lt;/a&gt;一、开源库介绍&lt;/h2&gt;&lt;p&gt;今年1月份，新开源的&lt;code&gt;react-natvigation&lt;/code&gt;库备受瞩目。在短短不到3个月的时间，&lt;code&gt;github&lt;/code&gt;上星数已达4000+。Fb推荐使用库，并且在&lt;code&gt;React Native&lt;/code&gt;当前最新版本0.44中将&lt;code&gt;Navigator&lt;/code&gt;删除。&lt;code&gt;react-navigation&lt;/code&gt;据称有原生般的性能体验效果。
    
    </summary>
    
      <category term="react-native学习笔记" scheme="http://yoursite.com/categories/react-native%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="navigator" scheme="http://yoursite.com/tags/navigator/"/>
    
      <category term="tabNavigator" scheme="http://yoursite.com/tags/tabNavigator/"/>
    
  </entry>
  
  <entry>
    <title>Method Swizzling 和 AOP 实践</title>
    <link href="http://yoursite.com/2018/04/03/Method_Swizzling_and_AOP/"/>
    <id>http://yoursite.com/2018/04/03/Method_Swizzling_and_AOP/</id>
    <published>2018-04-03T02:45:00.000Z</published>
    <updated>2018-04-16T13:18:53.313Z</updated>
    
    <content type="html"><![CDATA[<p>转自: <a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="noopener">http://tech.glowing.com/cn/method-swizzling-aop/</a></p><p>上一篇介绍了 <a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Messaging</a>。利用 <code>Objective-C</code> 的 <code>Runtime</code> 特性，我们可以给语言做扩展，帮助解决项目开发中的一些设计和技术问题。这一篇，我们来探索一些利用 <code>Objective-C Runtime</code> 的黑色技巧。这些技巧中最具争议的或许就是 <code>Method Swizzling</code> 。</p><a id="more"></a><p>介绍一个技巧，最好的方式就是提出具体的需求，然后用它跟其他的解决方法做比较。</p><p>所以，先来看看我们的需求：对 <code>App</code> 的用户行为进行追踪和分析。简单说，就是当用户看到某个 <code>View</code> 或者点击某个 <code>Button</code> 的时候，就把这个事件记下来。</p><h2 id="手动添加"><a href="#手动添加" class="headerlink" title="手动添加"></a>手动添加</h2><p>最直接粗暴的方式就是在每个 <code>viewDidAppear</code> 里添加记录事件的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@implementation MyViewController ()</span><br><span class="line"></span><br><span class="line">- (void)viewDidAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line"></span><br><span class="line">    // Custom code </span><br><span class="line"></span><br><span class="line">    // Logging</span><br><span class="line">    [Logging logWithEventName:@“my view did appear”];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)myButtonClicked:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    // Custom code </span><br><span class="line"></span><br><span class="line">    // Logging</span><br><span class="line">    [Logging logWithEventName:@“my button clicked”];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式的缺点也很明显：它破坏了代码的干净整洁。因为 <code>Logging</code> 的代码本身并不属于 <code>ViewController</code> 里的主要逻辑。随着项目扩大、代码量增加，你的 <code>ViewController</code> 里会到处散布着 <code>Logging</code> 的代码。这时，要找到一段事件记录的代码会变得困难，也很容易忘记添加事件记录的代码。</p><p>你可能会想到用继承或类别，在重写的方法里添加事件记录的代码。代码可以是长的这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIViewController ()</span><br><span class="line"></span><br><span class="line">- (void)myViewDidAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line"></span><br><span class="line">    // Custom code </span><br><span class="line"></span><br><span class="line">    // Logging</span><br><span class="line">    [Logging logWithEventName:NSStringFromClass([self class])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)myButtonClicked:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    // Custom code </span><br><span class="line"></span><br><span class="line">    // Logging</span><br><span class="line">    NSString *name = [NSString stringWithFormat:@“my button in %@ is clicked”, NSStringFromClass([self class])];</span><br><span class="line">    [Logging logWithEventName:name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Logging</code>的代码都很相似，通过继承或类别重写相关方法是可以把它从主要逻辑中剥离出来。但同时也带来新的问题：</p><ol><li>你需要继承 <code>UIViewController</code>, <code>UITableViewController</code>,<br><code>UICollectionViewController</code> 所有这些 <code>ViewController</code> ，或者给他们添加类别；</li><li>每个 <code>ViewController</code> 里的 <code>ButtonClick</code> 方法命名不可能都一样；</li><li>你不能控制别人如何去实例化你的子类；</li><li>对于类别，你没办法调用到原来的方法实现。大多时候，我们重写一个方法只是为了添加一些代码，而不是完全取代它。</li><li>如果有两个类别都实现了相同的方法，运行时没法保证哪一个类别的方法会给调用。</li></ol><h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><p><code>Method Swizzling</code> 利用 <code>Runtime</code> 特性把一个方法的实现与另一个方法的实现进行替换。</p><p>上一篇文章 有讲到每个类里都有一个 <code>Dispatch Table</code> ，将方法的名字（<code>SEL</code>）跟方法的实现（<code>IMP</code>，指向 C 函数的指针）一一对应。<code>Swizzle</code> 一个方法其实就是在程序运行时在 <code>Dispatch Table</code> 里做点改动，让这个方法的名字（<code>SEL</code>）对应到另个<code>IMP</code> 。</p><p>首先定义一个类别，添加将要 Swizzled 的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIViewController (Logging)</span><br><span class="line"></span><br><span class="line">- (void)swizzled_viewDidAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    // call original implementation</span><br><span class="line">    [self swizzled_viewDidAppear:animated];</span><br><span class="line"></span><br><span class="line">    // Logging</span><br><span class="line">    [Logging logWithEventName:NSStringFromClass([self class])];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来可能有点奇怪，像递归不是么。当然不会是递归，因为在 <code>runtime</code> 的时候，函数实现已经被交换了。调用 <code>viewDidAppear:</code> 会调用你实现的 <code>swizzled_viewDidAppear:</code>，而在 <code>swizzled_viewDidAppear:</code> 里调用 <code>swizzled_viewDidAppear:</code> 实际上调用的是原来的 <code>viewDidAppear:</code> 。</p><p>接下来实现 <code>swizzle</code> 的方法 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIViewController (Logging)</span><br><span class="line"></span><br><span class="line">void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector)  </span><br><span class="line">&#123;</span><br><span class="line">    // the method might not exist in the class, but in its superclass</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line"></span><br><span class="line">    // class_addMethod will fail if original method already exists</span><br><span class="line">    BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line"></span><br><span class="line">    // the method doesn’t exist and we just added one</span><br><span class="line">    if (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一可能需要解释的是 <code>class_addMethod</code> 。要先尝试添加原 <code>selector</code> 是为了做一层保护，因为如果这个类没有实现 <code>originalSelector</code> ，但其父类实现了，那 <code>class_getInstanceMethod</code> 会返回父类的方法。这样 <code>method_exchangeImplementations</code> 替换的是父类的那个方法，这当然不是你想要的。所以我们先尝试添加 <code>orginalSelector</code> ，如果已经存在，再用 <code>method_exchangeImplementations</code> 把原方法的实现跟新的方法实现给交换掉。</p><p>最后，我们只需要确保在程序启动的时候调用 <code>swizzleMethod</code> 方法。比如，我们可以在之前 <code>UIViewController</code> 的 <code>Logging</code> 类别里添加 <code>+load:</code> 方法，然后在 <code>+load:</code> 里把 <code>viewDidAppear</code> 给替换掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIViewController (Logging)</span><br><span class="line"></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    swizzleMethod([self class], @selector(viewDidAppear:), @selector(swizzled_viewDidAppear:));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，类别里的方法会重写掉主类里相同命名的方法。如果有两个类别实现了相同命名的方法，只有一个方法会被调用。但 <code>+load:</code> 是个特例，当一个类被读到内存的时候， <code>runtime</code> 会给这个类及它的每一个类别都发送一个 <code>+load:</code> 消息。</p><p>其实，这里还可以更简化点：直接用新的 <code>IMP</code>取代原 <code>IMP</code> ，而不是替换。只需要有全局的函数指针指向原<code>IMP</code> 就可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void (gOriginalViewDidAppear)(id, SEL, BOOL);</span><br><span class="line"></span><br><span class="line">void newViewDidAppear(UIViewController *self, SEL _cmd, BOOL animated)  </span><br><span class="line">&#123;</span><br><span class="line">    // call original implementation</span><br><span class="line">    gOriginalViewDidAppear(self, _cmd, animated);</span><br><span class="line"></span><br><span class="line">    // Logging</span><br><span class="line">    [Logging logWithEventName:NSStringFromClass([self class])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(self, @selector(viewDidAppear:));</span><br><span class="line">    gOriginalViewDidAppear = (void *)method_getImplementation(originalMethod);</span><br><span class="line"></span><br><span class="line">    if(!class_addMethod(self, @selector(viewDidAppear:), (IMP) newViewDidAppear, method_getTypeEncoding(originalMethod))) &#123;</span><br><span class="line">        method_setImplementation(originalMethod, (IMP) newViewDidAppear);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>Method Swizzling</code> ，我们成功把逻辑代码跟处理事件记录的代码解耦。当然除了 <code>Logging</code> ，还有很多类似的事务，如 <code>Authentication</code> 和 <code>Caching</code>。这些事务琐碎，跟主要业务逻辑无关，在很多地方都有，又很难抽象出来单独的模块。这种程序设计问题，业界也给了他们一个名字 - <a href="https://en.wikipedia.org/wiki/Cross-cutting_concern" target="_blank" rel="noopener">Cross Cutting Concerns</a>。</p><p>而像上面例子用 <code>Method Swizzling</code> 动态给指定的方法添加代码，以解决 <code>Cross Cutting Concerns</code> 的编程方式叫：<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="noopener">Aspect Oriented Programming</a></p><h2 id="Aspect-Oriented-Programming-（面向切面编程）"><a href="#Aspect-Oriented-Programming-（面向切面编程）" class="headerlink" title="Aspect Oriented Programming （面向切面编程）"></a>Aspect Oriented Programming （面向切面编程）</h2><p>Wikipedia 里对 AOP 是这么介绍的:</p><blockquote><p>An aspect can alter the behavior of the base code by applying advice<br>(additional behavior) at various join points (points in a program)<br>specified in a quantification or query called a pointcut (that detects<br>whether a given join point matches).</p></blockquote><p>在 <code>Objective-C</code> 的世界里，这句话意思就是利用 <code>Runtime</code> 特性给指定的方法添加自定义代码。有很多方式可以实现 <code>AOP</code> ，<code>Method Swizzling</code> 就是其中之一。而且幸运的是，目前已经有一些第三方库可以让你不需要了解 <code>Runtime</code> ，就能直接开始使用 <code>AOP</code> 。</p><p><code>Aspects</code> 就是一个不错的 <code>AOP</code> 库，封装了 <code>Runtime</code> ， <code>Method Swizzling</code> 这些黑色技巧，只提供两个简单的API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                          withOptions:(AspectOptions)options</span><br><span class="line">                       usingBlock:(id)block</span><br><span class="line">                            error:(NSError **)error;</span><br><span class="line">- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                      withOptions:(AspectOptions)options</span><br><span class="line">                       usingBlock:(id)block</span><br><span class="line">                            error:(NSError **)error;</span><br></pre></td></tr></table></figure><p>使用 <code>Aspects</code> 提供的<code>API</code>，我们之前的例子会进化成这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIViewController (Logging)</span><br><span class="line"></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    [UIViewController aspect_hookSelector:@selector(viewDidAppear:)</span><br><span class="line">                              withOptions:AspectPositionAfter</span><br><span class="line">                               usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</span><br><span class="line">        NSString *className = NSStringFromClass([[aspectInfo instance] class]);</span><br><span class="line">        [Logging logWithEventName:className];</span><br><span class="line">                               &#125; error:NULL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以用同样的方式在任何你感兴趣的方法里添加自定义代码，比如 <code>IBAction</code> 的方法里。更好的方式，你提供一个 <code>Logging</code> 的配置文件作为唯一处理事件记录的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@implementation AppDelegate (Logging)</span><br><span class="line"></span><br><span class="line">+ (void)setupLogging</span><br><span class="line">&#123;</span><br><span class="line">    NSDictionary *config = @&#123;</span><br><span class="line">        @&quot;MainViewController&quot;: @&#123;</span><br><span class="line">            GLLoggingPageImpression: @&quot;page imp - main page&quot;,</span><br><span class="line">            GLLoggingTrackedEvents: @[</span><br><span class="line">                @&#123;</span><br><span class="line">                    GLLoggingEventName: @&quot;button one clicked&quot;,</span><br><span class="line">                    GLLoggingEventSelectorName: @&quot;buttonOneClicked:&quot;,</span><br><span class="line">                    GLLoggingEventHandlerBlock: ^(id&lt;AspectInfo&gt; aspectInfo) &#123;</span><br><span class="line">                        [Logging logWithEventName:@&quot;button one clicked&quot;];</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                @&#123;</span><br><span class="line">                    GLLoggingEventName: @&quot;button two clicked&quot;,</span><br><span class="line">                    GLLoggingEventSelectorName: @&quot;buttonTwoClicked:&quot;,</span><br><span class="line">                    GLLoggingEventHandlerBlock: ^(id&lt;AspectInfo&gt; aspectInfo) &#123;</span><br><span class="line">                        [Logging logWithEventName:@&quot;button two clicked&quot;];</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">           ],</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        @&quot;DetailViewController&quot;: @&#123;</span><br><span class="line">            GLLoggingPageImpression: @&quot;page imp - detail page&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [AppDelegate setupWithConfiguration:config];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)setupWithConfiguration:(NSDictionary *)configs</span><br><span class="line">&#123;</span><br><span class="line">    // Hook Page Impression</span><br><span class="line">    [UIViewController aspect_hookSelector:@selector(viewDidAppear:)</span><br><span class="line">                              withOptions:AspectPositionAfter</span><br><span class="line">                               usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</span><br><span class="line">                                       NSString *className = NSStringFromClass([[aspectInfo instance] class]);</span><br><span class="line">                                    [Logging logWithEventName:className];</span><br><span class="line">                               &#125; error:NULL];</span><br><span class="line"></span><br><span class="line">    // Hook Events</span><br><span class="line">    for (NSString *className in configs) &#123;</span><br><span class="line">        Class clazz = NSClassFromString(className);</span><br><span class="line">        NSDictionary *config = configs[className];</span><br><span class="line"></span><br><span class="line">        if (config[GLLoggingTrackedEvents]) &#123;</span><br><span class="line">            for (NSDictionary *event in config[GLLoggingTrackedEvents]) &#123;</span><br><span class="line">                SEL selekor = NSSelectorFromString(event[GLLoggingEventSelectorName]);</span><br><span class="line">                AspectHandlerBlock block = event[GLLoggingEventHandlerBlock];</span><br><span class="line"></span><br><span class="line">                [clazz aspect_hookSelector:selekor</span><br><span class="line">                               withOptions:AspectPositionAfter</span><br><span class="line">                                usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</span><br><span class="line">                                    block(aspectInfo);</span><br><span class="line">                                &#125; error:NULL];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>-application:didFinishLaunchingWithOptions:</code> 里调用 <code>setupLogging：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line"></span><br><span class="line">    [self setupLogging];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>利用 <code>objective-C Runtime</code> 特性和 <code>Aspect Oriented Programming</code> ，我们可以把琐碎事务的逻辑从主逻辑中分离出来，作为单独的模块。它是对面向对象编程模式的一个补充。<code>Logging</code> 是个经典的应用，这里做个抛砖引玉，发挥想象力，可以做出其他有趣的应用。</p><p>使用 <code>Aspects</code> 完整的例子可以从这里获得：<a href="https://github.com/okcomp/AspectsDemo" target="_blank" rel="noopener">AspectsDemo</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自: &lt;a href=&quot;http://tech.glowing.com/cn/method-swizzling-aop/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://tech.glowing.com/cn/method-swizzling-aop/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇介绍了 &lt;a href=&quot;http://tech.glowing.com/cn/objective-c-runtime/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Objective-C Messaging&lt;/a&gt;。利用 &lt;code&gt;Objective-C&lt;/code&gt; 的 &lt;code&gt;Runtime&lt;/code&gt; 特性，我们可以给语言做扩展，帮助解决项目开发中的一些设计和技术问题。这一篇，我们来探索一些利用 &lt;code&gt;Objective-C Runtime&lt;/code&gt; 的黑色技巧。这些技巧中最具争议的或许就是 &lt;code&gt;Method Swizzling&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 之 runtime" scheme="http://yoursite.com/categories/iOS-%E4%B9%8B-runtime/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>Android 之简易涂鸦板</title>
    <link href="http://yoursite.com/2017/06/08/android-canvas/"/>
    <id>http://yoursite.com/2017/06/08/android-canvas/</id>
    <published>2017-06-08T03:56:31.000Z</published>
    <updated>2018-04-16T07:54:57.293Z</updated>
    
    <content type="html"><![CDATA[<p>没有废话，简单粗暴。</p><h2 id="1-创建一个自定义-view"><a href="#1-创建一个自定义-view" class="headerlink" title="1.创建一个自定义 view"></a><strong>1.创建一个自定义 view</strong></h2><p>创建一个 DrawView，继承自 android.view.View 类。在这个类中，先定义所需的属性，再创建一个构造方法。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class DrawView extends View &#123;</span><br><span class="line"></span><br><span class="line">    private int view_width = 0;//画板宽度</span><br><span class="line">    private int view_height = 0;//画板高度</span><br><span class="line">    private float preX;//起始点的 x 坐标</span><br><span class="line">    private float preY;//起始点的 y 坐标</span><br><span class="line">    private Path path;//路径</span><br><span class="line">    public Paint paint = null;//画笔</span><br><span class="line">    Bitmap cacheBitmap = null;//定义一个内存中的图片，该图片作为缓冲区</span><br><span class="line">    Canvas cacheCanvas = null;//定义 cacheBitmap 上的 Canvas 对象</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    /*构造方法*/</span><br><span class="line">    public DrawView(Context context, AttributeSet set)&#123;</span><br><span class="line">        super(context,set);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*重写 onDraw 方法*/</span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-修改-xml-文件"><a href="#2-修改-xml-文件" class="headerlink" title="2.修改 xml 文件"></a><strong>2.修改 xml 文件</strong></h2><p>修改 activity_main.xml 文件，并将自定义的 DrawView 添加到布局管理器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">    android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.example.test.DrawView</span><br><span class="line">        android:id=&quot;@+id/drawView1&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="3-DrawView-的构造方法"><a href="#3-DrawView-的构造方法" class="headerlink" title="3.DrawView 的构造方法"></a><strong>3.DrawView 的构造方法</strong></h2><p>在 DrawView 的构造方法中，首先获取屏幕的宽度和高度，并创建一个与该 view 相同大小的缓存区，然后创建一个新的画面，并实例化一个路径，再讲内存中的位图绘制到 cacheCanvas 中，最后实例化一个画笔，并设置画笔的相关属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//获取屏幕宽度</span><br><span class="line">        view_width = context.getResources().getDisplayMetrics().widthPixels;</span><br><span class="line">        //获取屏幕高度</span><br><span class="line">        view_height = context.getResources().getDisplayMetrics().heightPixels;</span><br><span class="line"></span><br><span class="line">        cacheBitmap = Bitmap.createBitmap(view_width,view_height, Bitmap.Config.ARGB_8888);</span><br><span class="line">        //创建一个新的画布</span><br><span class="line">        cacheCanvas = new Canvas();</span><br><span class="line">        path = new Path();</span><br><span class="line">        //在 cacheCanvas 上绘制 cacheBitmap</span><br><span class="line">        cacheCanvas.setBitmap(cacheBitmap);</span><br><span class="line"></span><br><span class="line">        paint = new Paint(Paint.DITHER_FLAG);</span><br><span class="line">        //设置默认的画笔颜色</span><br><span class="line">        paint.setColor(Color.RED);</span><br><span class="line"></span><br><span class="line">        //设置填充方式为描边</span><br><span class="line">        paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        //设置笔刷的图形样式</span><br><span class="line">        paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class="line">        //设置画笔转弯处的连接风格</span><br><span class="line">        paint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line">        //设置默认的画笔的宽度</span><br><span class="line">        paint.setStrokeWidth(1);</span><br><span class="line">        //使用抗锯齿功能</span><br><span class="line">        paint.setAntiAlias(true);</span><br><span class="line">        //使用抖动效果</span><br><span class="line">        paint.setDither(true);</span><br></pre></td></tr></table></figure><h2 id="4-重写-onDraw-方法"><a href="#4-重写-onDraw-方法" class="headerlink" title="4.重写 onDraw 方法"></a><strong>4.重写 onDraw 方法</strong></h2><p>在 DrawView 的 onDraw 方法中，设置背景颜色，绘制 cacheBitmap，绘制路径以及保存当前的状态到栈中，并调用 restore()方法恢复所保存的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//设置背景颜色</span><br><span class="line">        canvas.drawColor(0xFFFFFFFF);</span><br><span class="line">        //采用默认设置创建一个画笔</span><br><span class="line">        Paint bmpPaint = new Paint();</span><br><span class="line"></span><br><span class="line">        //绘制cacheBitmap</span><br><span class="line">        canvas.drawBitmap(cacheBitmap,0,0,bmpPaint);</span><br><span class="line">        //绘制路径</span><br><span class="line">        canvas.drawPath(path,paint);</span><br><span class="line">        //保存 canvas 状态</span><br><span class="line">        canvas.save(Canvas.ALL_SAVE_FLAG);</span><br><span class="line">        //恢复 canvas 之前的保存状态，防止保存后对 canvas 执行的操作最后续的绘制有影响</span><br><span class="line">        canvas.restore();</span><br></pre></td></tr></table></figure><h2 id="5-重写-onTouchEvent-方法"><a href="#5-重写-onTouchEvent-方法" class="headerlink" title="5.重写 onTouchEvent 方法"></a><strong>5.重写 onTouchEvent 方法</strong></h2><p>在 DrawView 类中，重写onTouchEvent() 方法，为该视图添加触摸时间监听器，在该方法中，首先获取触摸时间发生的位置，然后应用 switch 对时间的不同状态添加响应代码，最后调用invalidate()方法更新视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line"></span><br><span class="line">        //获取触摸时间发生的位置</span><br><span class="line">        float x = event.getX();</span><br><span class="line">        float y = event.getY();</span><br><span class="line">        switch (event.getAction())&#123;</span><br><span class="line"></span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line"></span><br><span class="line">                //将绘图的起始点移到（x，y）的坐标位置</span><br><span class="line">                path.moveTo(x,y);</span><br><span class="line">                preX = x;</span><br><span class="line">                preY = y;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                float dx = Math.abs(x-preX);</span><br><span class="line">                float dy = Math.abs(y-preY);</span><br><span class="line"></span><br><span class="line">                //判断是否在允许的范围内</span><br><span class="line">                if (dx&gt;=5 || dy &gt;= 5)&#123;</span><br><span class="line">                    path.quadTo(preX,preY,(x+preX)/2,(y+preY)/2);</span><br><span class="line">                    preX = x;</span><br><span class="line">                    preY = y;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                //绘制路径</span><br><span class="line">                cacheCanvas.drawPath(path,paint);</span><br><span class="line">                path.reset();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        invalidate();</span><br><span class="line"></span><br><span class="line">        //返回 true，表示处理方法已经处理该事件</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-编写-clear-方法"><a href="#6-编写-clear-方法" class="headerlink" title="6.编写 clear() 方法"></a><strong>6.编写 clear() 方法</strong></h2><p>写一个 clear() 方法，用来实现橡皮擦功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line"></span><br><span class="line">       //设置图形重叠时的处理方式</span><br><span class="line">       paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));</span><br><span class="line">       //设置橡皮擦的宽度</span><br><span class="line">       paint.setStrokeWidth(50);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="7-编写-save-方法"><a href="#7-编写-save-方法" class="headerlink" title="7.编写 save() 方法"></a><strong>7.编写 save() 方法</strong></h2><p>写一个方法，用来保存当前的绘图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void save() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            saveBitmap(&quot;myPicture&quot;);</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private void saveBitmap(String filename) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        //创建文件对象</span><br><span class="line">        File file = new File(&quot;/sdcard/pictures/&quot;+filename+&quot;.png&quot;);</span><br><span class="line">        //创建一个新文件</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        //创建一个文件输出流对象</span><br><span class="line">        FileOutputStream out = new FileOutputStream(file);</span><br><span class="line">        //将绘图内容压缩成 PNG 格式输出到输出流对象中</span><br><span class="line">        cacheBitmap.compress(Bitmap.CompressFormat.PNG,100,out);</span><br><span class="line">        //将缓冲区的数据全部写出到输出流中</span><br><span class="line">        out.flush();</span><br><span class="line">        //关闭文件输出流对象</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="8-设置权限"><a href="#8-设置权限" class="headerlink" title="8.设置权限"></a><strong>8.设置权限</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;/&gt;</span><br><span class="line">   &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="9-创建-menu-资源文件"><a href="#9-创建-menu-资源文件" class="headerlink" title="9.创建 menu 资源文件"></a><strong>9.创建 menu 资源文件</strong></h2><p>在 res 目录下，创建menu 文件夹，在 menu 文件夹下，创建 toolsmenu.xml 资源文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line">    &lt;item android:title=&quot;@string/color&quot;&gt;</span><br><span class="line">        &lt;menu &gt;</span><br><span class="line">            &lt;!-- 定义一组单选菜单项 --&gt;</span><br><span class="line">            &lt;group android:checkableBehavior=&quot;single&quot; &gt;</span><br><span class="line">                &lt;!-- 定义子菜单 --&gt;</span><br><span class="line">                &lt;item android:id=&quot;@+id/red&quot; android:title=&quot;@string/color_red&quot;/&gt;</span><br><span class="line">                &lt;item android:id=&quot;@+id/green&quot; android:title=&quot;@string/color_green&quot;/&gt;</span><br><span class="line">                &lt;item android:id=&quot;@+id/blue&quot; android:title=&quot;@string/color_blue&quot;/&gt;</span><br><span class="line">            &lt;/group&gt;</span><br><span class="line">        &lt;/menu&gt;</span><br><span class="line">    &lt;/item&gt;</span><br><span class="line">    &lt;item android:title=&quot;@string/width&quot;&gt;</span><br><span class="line">        &lt;menu &gt;</span><br><span class="line">            &lt;!-- 定义子菜单 --&gt;</span><br><span class="line">            &lt;group&gt;</span><br><span class="line">                &lt;item android:id=&quot;@+id/width_1&quot; android:title=&quot;@string/width_1&quot;/&gt;</span><br><span class="line">                &lt;item android:id=&quot;@+id/width_2&quot; android:title=&quot;@string/width_2&quot;/&gt;</span><br><span class="line">                &lt;item android:id=&quot;@+id/width_3&quot; android:title=&quot;@string/width_3&quot;/&gt;</span><br><span class="line">            &lt;/group&gt;</span><br><span class="line">        &lt;/menu&gt;</span><br><span class="line">    &lt;/item&gt;</span><br><span class="line">    &lt;item android:id=&quot;@+id/clear&quot; android:title=&quot;@string/clear&quot;/&gt;</span><br><span class="line">    &lt;item android:id=&quot;@+id/save&quot; android:title=&quot;@string/save&quot;/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><h2 id="10-添加选项菜单"><a href="#10-添加选项菜单" class="headerlink" title="10.添加选项菜单"></a><strong>10.添加选项菜单</strong></h2><h3 id="重写onCreateOptionsMenu方法"><a href="#重写onCreateOptionsMenu方法" class="headerlink" title="重写onCreateOptionsMenu方法"></a><strong><1>重写onCreateOptionsMenu方法</1></strong></h3><p>在 activity 文件中，重写onCreateOptionsMenu()方法，在该方法中，实例化一个MenuInflater对象，并解析菜单资源文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean onCreateOptionsMenu(Menu menu) &#123;</span><br><span class="line">        MenuInflater menuInflater = new MenuInflater(this);</span><br><span class="line">        menuInflater.inflate(R.menu.toolsmenu,menu);</span><br><span class="line">        return super.onCreateOptionsMenu(menu);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="重写onOptionsItemSelected方法"><a href="#重写onOptionsItemSelected方法" class="headerlink" title="重写onOptionsItemSelected方法"></a><strong><2>重写onOptionsItemSelected方法</2></strong></h3><p>重写onOptionsItemSelected() 方法，分别对各个菜单项被选择时做出相应的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean onOptionsItemSelected(MenuItem item) &#123;</span><br><span class="line"></span><br><span class="line">        //获取自定义视图</span><br><span class="line">        DrawView drawView = (DrawView)findViewById(R.id.drawView1);</span><br><span class="line">        //取消擦除效果</span><br><span class="line">        drawView.paint.setXfermode(null);</span><br><span class="line">        //初始化画笔的宽度</span><br><span class="line">        drawView.paint.setStrokeWidth(1);</span><br><span class="line"></span><br><span class="line">        switch (item.getItemId())&#123;</span><br><span class="line"></span><br><span class="line">            //设置画笔的颜色为红色</span><br><span class="line">            case R.id.red:</span><br><span class="line">                drawView.paint.setColor(Color.RED);</span><br><span class="line">                item.setChecked(true);</span><br><span class="line">                break;</span><br><span class="line">            //设置画笔的颜色为绿色</span><br><span class="line">            case R.id.green:</span><br><span class="line">                drawView.paint.setColor(Color.GREEN);</span><br><span class="line">                item.setChecked(true);</span><br><span class="line">                break;</span><br><span class="line">            //设置画笔的颜色为蓝色</span><br><span class="line">            case R.id.blue:</span><br><span class="line">                drawView.paint.setColor(Color.BLUE);</span><br><span class="line">                item.setChecked(true);</span><br><span class="line">                break;</span><br><span class="line">            //设置画笔的宽度为1</span><br><span class="line">            case R.id.width_1:</span><br><span class="line">                drawView.paint.setStrokeWidth(1);</span><br><span class="line">                break;</span><br><span class="line">            //设置画笔的宽度为5</span><br><span class="line">            case R.id.width_2:</span><br><span class="line">                drawView.paint.setStrokeWidth(5);</span><br><span class="line">                break;</span><br><span class="line">            //设置画笔的宽度为10</span><br><span class="line">            case R.id.width_3:</span><br><span class="line">                drawView.paint.setStrokeWidth(10);</span><br><span class="line">                break;</span><br><span class="line">            //擦除绘画</span><br><span class="line">            case R.id.clear:</span><br><span class="line">                drawView.clear();</span><br><span class="line">                break;</span><br><span class="line">            //保存绘画</span><br><span class="line">            case R.id.save:</span><br><span class="line">                drawView.save();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行，就会得到一个简易的涂鸦板，可以改变画笔颜色，画笔宽度，擦除，保存等。</p><p>真是越来越有意思了呢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有废话，简单粗暴。&lt;/p&gt;
&lt;h2 id=&quot;1-创建一个自定义-view&quot;&gt;&lt;a href=&quot;#1-创建一个自定义-view&quot; class=&quot;headerlink&quot; title=&quot;1.创建一个自定义 view&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.创建一个自定义 view&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;创建一个 DrawView，继承自 android.view.View 类。在这个类中，先定义所需的属性，再创建一个构造方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
      <category term="paint" scheme="http://yoursite.com/tags/paint/"/>
    
      <category term="draw" scheme="http://yoursite.com/tags/draw/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/06/07/hello-world/"/>
    <id>http://yoursite.com/2017/06/07/hello-world/</id>
    <published>2017-06-07T13:00:30.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="hello world" scheme="http://yoursite.com/tags/hello-world/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义 item 的 ListView</title>
    <link href="http://yoursite.com/2017/06/05/android-listView/"/>
    <id>http://yoursite.com/2017/06/05/android-listView/</id>
    <published>2017-06-05T08:34:46.000Z</published>
    <updated>2018-04-16T07:55:18.898Z</updated>
    
    <content type="html"><![CDATA[<p> 从 iOS 的 TableView 突然转到 Android 的 ListView， 说实话，很恶心。各种不方便，不要问我为什么学 Android，我也不想，唉，牢骚归牢骚，既然学了，就得学到点什么，不然既浪费时间，又什么都没得到,太亏了。记录一下学习的历程。</p><a id="more"></a><p>在使用 ListView 的时候，大部分我们都会自定义 item，iOS 也一样，会自定义 cell。不然使用系统为我们提供的几种格式是满足不了我们的各式各样的需求的。</p><p>废话到此为止。</p><h2 id="1-先在-xml-文件中布局："><a href="#1-先在-xml-文件中布局：" class="headerlink" title="1.先在 xml 文件中布局："></a><strong>1.先在 xml 文件中布局：</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:id=&quot;@+id/main_listView&quot;</span><br><span class="line">        android:layout_alignParentTop=&quot;true&quot;</span><br><span class="line">        android:layout_alignParentLeft=&quot;true&quot;</span><br><span class="line">        android:layout_alignParentStart=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="2-创建模型文件"><a href="#2-创建模型文件" class="headerlink" title="2.创建模型文件"></a><strong>2.创建模型文件</strong></h2><p>相当于 iOS 中的 model 文件，每写一个东西，就得去 iOS 中找对应的东西，这属于思维固化了。慢慢改正，不过这样能方便快速的理解这些东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int imageID;</span><br><span class="line"></span><br><span class="line">    //setter和getter方法</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getImageID() &#123;</span><br><span class="line">        return imageID;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setImageID(int imageID) &#123;</span><br><span class="line">        this.imageID = imageID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比较而言，Android 的模型文件真的很麻烦，定义一个属性，就得写它的 getter 和 setter 方法。也许有其他的办法，只是我还不知道。</p><h2 id="3-创建Adapter"><a href="#3-创建Adapter" class="headerlink" title="3.创建Adapter"></a><strong>3.创建Adapter</strong></h2><p>这个适配器，在我的理解中就相当于 iOS 中的自定义 cell 了，比 iOS 方便的是，iOS 的那些数据源方法都在这里实现。一般的话，自定义的 adapter 会继承于 <code>BaseAdapter</code>。</p><h3 id="1-实现数据源方法"><a href="#1-实现数据源方法" class="headerlink" title="1.实现数据源方法"></a><strong>1.实现数据源方法</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public int getCount() &#123;</span><br><span class="line">  //返回多少行数据</span><br><span class="line">       return mList.size();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public Object getItem(int position) &#123;</span><br><span class="line">   //获取每一行的数据</span><br><span class="line">       return mList.get(position);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public long getItemId(int position) &#123;</span><br><span class="line">   //获取行号</span><br><span class="line">       return position;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public View getView(final int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line"></span><br><span class="line">//UI 刷新的代码主要在这里实现</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建一个构造方法"><a href="#2-创建一个构造方法" class="headerlink" title="2.创建一个构造方法"></a><strong>2.创建一个构造方法</strong></h3><p>这里是举例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public TeacherAdapter(ArrayList&lt;Teacher&gt; mList, Context mContext) &#123;</span><br><span class="line">        this.mList = mList;</span><br><span class="line">        this.mContext = mContext;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-给-item-布局"><a href="#4-给-item-布局" class="headerlink" title="4.给 item 布局"></a><strong>4.给 item 布局</strong></h2><p>创建一个 item 的 xml 文件，每一个 item 的布局都在这个文件中进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView</span><br><span class="line">       android:layout_width=&quot;50dp&quot;</span><br><span class="line">       android:layout_height=&quot;50dp&quot;</span><br><span class="line">       android:id=&quot;@+id/item_imageView&quot;</span><br><span class="line">       android:layout_marginTop=&quot;5dp&quot;</span><br><span class="line">       android:layout_marginLeft=&quot;10dp&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">       android:id=&quot;@+id/item_textView&quot;</span><br><span class="line">       android:layout_marginLeft=&quot;10dp&quot;</span><br><span class="line">       android:layout_gravity=&quot;center_vertical&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这里我给每个 item 上定义了两个控件，一个 TextView，一个 ImageView。是线性布局。</p><h2 id="5-给控件赋值"><a href="#5-给控件赋值" class="headerlink" title="5.给控件赋值"></a><strong>5.给控件赋值</strong></h2><p>接下来再回到 adapter 文件中的 getView 方法中，在这个方法中为控件赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public View getView(final int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line"></span><br><span class="line">//UI 刷新的代码主要在这里实现</span><br><span class="line">//获取老师的数据</span><br><span class="line">       final Teacher teacher = mlist.get(position);</span><br><span class="line"></span><br><span class="line">       //根据layout文件创建布局</span><br><span class="line">       View oneTeacherView = LayoutInflater.from(mContext).inflate(R.layout.teacher_item,parent,false);</span><br><span class="line"></span><br><span class="line">       //获取ImageView和TextView</span><br><span class="line">       ImageView imageView = (ImageView) oneTeacherView.findViewById(R.id.item_imageView);</span><br><span class="line">       TextView textView = (TextView) oneTeacherView.findViewById(R.id.item_textView);</span><br><span class="line"></span><br><span class="line">//根据数据分别为imageView和textView赋值       imageView.setImageResource(teacher.getImageID());</span><br><span class="line">       textView.setText(teacher.getName());</span><br><span class="line"></span><br><span class="line">return oneTeacherView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-设置数据源"><a href="#6-设置数据源" class="headerlink" title="6.设置数据源"></a><strong>6.设置数据源</strong></h2><p>接下来回到 Activity 文件中，获取 listView 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//因为这里是本地数据，所以将 listView 设置为了局部变量，本地数据也不需要在开启线程去刷新UI</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Teacher&gt; teacherList = new ArrayList&lt;Teacher&gt;();</span><br><span class="line"></span><br><span class="line">Teacher teacher = new Teacher()；</span><br><span class="line">teacher.setName(&quot;jack&quot;);</span><br><span class="line">teacher.setImageID(R.mipmap.header_image);</span><br><span class="line"></span><br><span class="line">teacherList.add(teacher);</span><br><span class="line"></span><br><span class="line">//我这里只添加了一条数据，如果像添加的话，添加进这个数组就行</span><br><span class="line">ListView listView = (ListView)findViewById(R.id.main_listView);</span><br><span class="line"></span><br><span class="line">TeacherAdapter adapter = new TeacherAdapter(teacherList,this);</span><br><span class="line"></span><br><span class="line">listView.setAdapter(adapter);</span><br></pre></td></tr></table></figure><p>到这里，一个完整的自定义 item 的 ListView 算是完成了。但是在实际开发中，大部分的应用场景都是从网络端获取数据，然后给 ListView 赋值。这个等我学到网络的时候再来介绍一下。</p><p>如有不对之处，请多多指正！达者为师，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 从 iOS 的 TableView 突然转到 Android 的 ListView， 说实话，很恶心。各种不方便，不要问我为什么学 Android，我也不想，唉，牢骚归牢骚，既然学了，就得学到点什么，不然既浪费时间，又什么都没得到,太亏了。记录一下学习的历程。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android-listView" scheme="http://yoursite.com/tags/android-listView/"/>
    
  </entry>
  
  <entry>
    <title>Android 响应按钮点击事件的4种写法</title>
    <link href="http://yoursite.com/2017/05/10/android-onClick/"/>
    <id>http://yoursite.com/2017/05/10/android-onClick/</id>
    <published>2017-05-10T05:25:35.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>在android 开发中，按钮响应点击事件有四种写法。下面依次介绍。</p><a id="more"></a><h2 id="1-匿名内部类"><a href="#1-匿名内部类" class="headerlink" title="1. 匿名内部类"></a><strong>1. 匿名内部类</strong></h2><p>这种方式一般适用于自己写 demo 测试时使用，优点就是快速。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_register);</span><br><span class="line"></span><br><span class="line">        Button button = (Button)findViewById(R.id.btn);</span><br><span class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">               </span><br><span class="line">                  //响应事件</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-自定义事件监听类"><a href="#2-自定义事件监听类" class="headerlink" title="2. 自定义事件监听类"></a><strong>2. 自定义事件监听类</strong></h2><p>这种方式和第一种差不多，唯一的区别就是将响应事件的代码放到一个自定义的监听类里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;  </span><br><span class="line">    super.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.activity_register);  </span><br><span class="line">              </span><br><span class="line">        Button button = (Button)findViewById(R.id.btn);  </span><br><span class="line">        button.setOnClickListener(new MyListener());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">//让自定义监听类去实现 View 的 OnClickListener 接口</span><br><span class="line">    private class MyListener implements View.OnClickListener &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void onClick(View v) &#123;  </span><br><span class="line">         </span><br><span class="line">        //响应事件</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-由-Activity-实现-OnClickListener-接口"><a href="#3-由-Activity-实现-OnClickListener-接口" class="headerlink" title="3. 由 Activity 实现 OnClickListener 接口"></a><strong>3. 由 Activity 实现 OnClickListener 接口</strong></h2><p>这种方式是在项目中应用最多的写法。因为这种写法可以减少代码量，尤其是在 Activity 上有多个点击事件的时候。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class RegisterActivity extends Activity implements View.OnClickListener &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;  </span><br><span class="line">        super.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.activity_register);  </span><br><span class="line">        </span><br><span class="line">          </span><br><span class="line">    Button button = (Button)findViewById(R.id.btn);  </span><br><span class="line">        button.setOnClickListener(this); </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void onClick(View v) &#123;  </span><br><span class="line">  </span><br><span class="line">//根据 id 来区分分别是哪个按钮的点击事件</span><br><span class="line">        switch (v.getId())&#123;  </span><br><span class="line">            case R.id.btn:  </span><br><span class="line">                //响应事件  </span><br><span class="line">                break;  </span><br><span class="line">            default:  </span><br><span class="line">                break;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-在布局文件中添加-onClick-属性"><a href="#4-在布局文件中添加-onClick-属性" class="headerlink" title="4. 在布局文件中添加 onClick 属性"></a><strong>4. 在布局文件中添加 onClick 属性</strong></h2><p>这种方式不用在 Activity 中声明组件对象就可以响应点击事件，虽然在看起来很轻便，但是在维护测试的时候，不容易找到 button 相对应的点击事件，所以不太推荐使用。</p><h3 id="首先在-XML-布局文件中添加-onClick-属性"><a href="#首先在-XML-布局文件中添加-onClick-属性" class="headerlink" title="首先在 XML 布局文件中添加 onClick 属性"></a><strong>首先在 XML 布局文件中添加 onClick 属性</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button  </span><br><span class="line">        android:onClick=&quot;btnClick&quot;  </span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;  </span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;  </span><br><span class="line">        android:text=&quot;@string/btn&quot;  </span><br><span class="line">        android:id=&quot;@+id/btn&quot;  /&gt;</span><br></pre></td></tr></table></figure><h3 id="在-Activity-中实现方法"><a href="#在-Activity-中实现方法" class="headerlink" title="在 Activity 中实现方法"></a><strong>在 Activity 中实现方法</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void btnClick(View v)&#123;  </span><br><span class="line">    //响应事件 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在android 开发中，按钮响应点击事件有四种写法。下面依次介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="onClick" scheme="http://yoursite.com/tags/onClick/"/>
    
  </entry>
  
  <entry>
    <title>React Native 集成到iOS原生项目</title>
    <link href="http://yoursite.com/2017/05/03/rn-integration-iosNative/"/>
    <id>http://yoursite.com/2017/05/03/rn-integration-iosNative/</id>
    <published>2017-05-03T02:25:39.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你正准备从头开始制作一个新的应用，那么React Native会是个非常好的选择。但如果你只想给现有的原生应用中添加一两个视图或是业务流程，React Native也同样不在话下。只需简单几步，你就可以给原有应用加上新的基于React Native的特性、画面和视图等。</p><a id="more"></a><p><strong>把React Native组件植入到iOS应用中有如下几个主要步骤：</strong></p><ol><li>首先当然要了解你要植入的React Native组件。</li><li>创建一个Podfile，在其中以subspec的形式填写所有你要植入的React Native的组件。</li><li>创建js文件，编写React Native组件的js代码。</li><li>添加一个事件处理函数，用于创建一个RCTRootView。这个RCTRootView正是用来承载你的React Native组件的，而且它必须对应你在index.ios.js中使用AppRegistry注册的模块名字。</li><li>启动React Native的Packager服务，运行应用。</li><li>根据需要添加更多React Native的组件。</li><li><a href="http://reactnative.cn/docs/0.44/debugging.html" target="_blank" rel="noopener">调试</a>。</li><li>准备<a href="http://reactnative.cn/docs/0.44/running-on-device-ios.html" target="_blank" rel="noopener">部署发布</a> （比如可以利用react-native-xcode.sh脚本）。</li><li>发布应用，升职加薪，走向人生巅峰！😘</li></ol><h2 id="创建一个原生应用"><a href="#创建一个原生应用" class="headerlink" title="创建一个原生应用"></a><strong>创建一个原生应用</strong></h2><p>这个就不多说。</p><h2 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a><strong>添加依赖包</strong></h2><p><code>React Native</code>的植入过程同时需要<code>React</code>和<code>React Native</code>两个<code>node</code>依赖包。我们把具体的依赖包记录在<code>package.json</code>文件中。如果项目根目录中没有这个文件，那就自己创建一个。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><strong>package.json</strong></h3><p>我这里的做法是在项目的根目录下创建一个专门存放<code>react native</code>相关的文件夹，就像这样：</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-3f0a8009194f63bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RNComponent文件夹"></p><p>然后在这个文件夹下创建一个<code>package.json</code>文件，就像这样：</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-cadd6341c8ddd797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="package.json文件"></p><p>在<code>package.json</code>文件中的内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;NativeRN&quot;,</span><br><span class="line">&quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">&quot;private&quot;: true,</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">&quot;react&quot;: &quot;16.0.0-alpha.6&quot;,</span><br><span class="line">&quot;react-native&quot;: &quot;0.44.0&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释一下：</strong></p><ul><li><p><code>version</code>字段没有太大意义（除非你要把你的项目发布到npm仓库）。</p></li><li><p><code>scripts</code>中是用于启动<code>packager</code>服务的命令。</p></li><li><p><code>dependencies</code>中的<code>react</code>和<code>react-native</code>的版本取决于你的具体需求。一般来说我们推荐使用最新版本。你可以使用<code>npm info react</code>和<code>npm info react-native</code>来查看当前的最新版本。另外，<code>react-native</code>对<code>react</code>的版本有严格要求，高于或低于某个范围都不可以。</p></li></ul><p><strong>本文无法在这里列出所有<code>react native</code>和对应的<code>react</code>版本要求，只能提醒读者先尝试执行<code>npm install</code>，然后注意观察安装过程中的报错信息，例如require react@某.某.某版本, but none was installed，然后根据这样的提示，执行npm i -S react@某.某.某版本。</strong></p><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a><strong>安装依赖包</strong></h3><p>使用npm（node包管理器，Node package manager）来安装React和React Native模块。这些模块会被安装到项目根目录下的node_modules/目录中。 在包含有package.json文件的目录（一般也就是项目根目录,我这里因为创建了RNComponent文件夹，所以是在这个文件夹目录下执行这个命令）中运行下列命令来安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>运行完成后会出现<code>node_modules</code>这样一个文件夹，这个文件夹下包含了RN的一些模块，就像这样：</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-12fe957bf08f258a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行命令安装模块"></p><h2 id="React-Native框架"><a href="#React-Native框架" class="headerlink" title="React Native框架"></a><strong>React Native框架</strong></h2><p>React Native框架整体是作为node模块安装到项目中的。下一步我们需要在CocoaPods的Podfile中指定我们所需要使用的组件。</p><h3 id="Subspecs"><a href="#Subspecs" class="headerlink" title="Subspecs"></a><strong>Subspecs</strong></h3><p>在你开始把<code>React Native</code>植入到你的应用中之前，首先要决定具体整合的是<code>React Native</code>框架中的哪些部分。而这就是<code>subspec</code>要做的工作。在创建<code>Podfile</code>文件的时候，需要指定具体安装哪些<code>React Native</code>的依赖库。所指定的每一个库就称为一个<code>subspec</code>。</p><p>可用的<code>subspec</code>都列在<code>node_modules/react-native/React.podspec</code>中，基本都是按其功能命名的。一般来说你首先需要添加<code>Core</code>，这一<code>subspec</code>包含了必须的<code>AppRegistry</code>、<code>StyleSheet</code>、<code>View</code>以及其他的一些<code>React Native</code>核心库。如果你想使用<code>React Native</code>的<code>Text</code>库（即<code>&lt;Text&gt;</code>组件），那就需要添加<code>RCTText</code>的<code>subspec</code>。同理，<code>Image</code>需要加入<code>RCTImage</code>，等等。</p><h3 id="Podfile"><a href="#Podfile" class="headerlink" title=" Podfile"></a><strong> Podfile</strong></h3><p>在<code>React</code>和<code>React Native</code>模块成功安装到<code>node_modules</code>目录之后，你就可以开始创建<code>Podfile</code>以便选择所需的组件安装到应用中。</p><p>创建podfile在这里不在多说，相信只要用过cocoapods的朋友都知道。</p><p>podfile创建完成之后，在文件里添加一下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># target的名字一般与你的项目名字相同</span><br><span class="line">target &apos;NativeRN&apos; do</span><br><span class="line"></span><br><span class="line">  # &apos;node_modules&apos;目录一般位于根目录中</span><br><span class="line">  # 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`</span><br><span class="line">  pod &apos;React&apos;, :path =&gt; &apos;./RNComponent/node_modules/react-native&apos;, :subspecs =&gt; [</span><br><span class="line">    &apos;Core&apos;,</span><br><span class="line">    &apos;RCTText&apos;,</span><br><span class="line">    &apos;RCTNetwork&apos;,</span><br><span class="line">    &apos;RCTWebSocket&apos;, # 这个模块是用于调试功能的</span><br><span class="line">    # 在这里继续添加你所需要的模块</span><br><span class="line">  ]</span><br><span class="line">  # 如果你的RN版本 &gt;= 0.42.0，请加入下面这行</span><br><span class="line">  pod &quot;Yoga&quot;, :path =&gt; &quot;./RNComponent/node_modules/react-native/ReactCommon/yoga&quot;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后执行下面的👇命令，开始安装React Native的pod包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure><h2 id="代码集成"><a href="#代码集成" class="headerlink" title="代码集成"></a><strong>代码集成</strong></h2><h3 id="index-ios-js"><a href="#index-ios-js" class="headerlink" title="index.ios.js"></a><strong>index.ios.js</strong></h3><p>首先创建一个空的index.ios.js文件。一般来说我们把它放置在项目根目录下。就像👇：</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-8dc08f6aaa420e74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="index.ios.js"></p><p>index.ios.js是React Native应用在iOS上的入口文件。<strong>而且它是不可或缺的！</strong>它可以是个很简单的文件，简单到可以只包含一行require/import导入语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在项目根目录执行以下命令创建文件：</span><br><span class="line">$ touch index.ios.js</span><br></pre></td></tr></table></figure><h3 id="添加你自己的React-Native代码"><a href="#添加你自己的React-Native代码" class="headerlink" title="添加你自己的React Native代码"></a><strong>添加你自己的React Native代码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">  StyleSheet,</span><br><span class="line">  Text,</span><br><span class="line">  View</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">export default class NativeRN extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;</span><br><span class="line">          Welcome to React Native!</span><br><span class="line">        &lt;/Text&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.instructions&#125;&gt;</span><br><span class="line">          To get started, edit index.ios.js</span><br><span class="line">        &lt;/Text&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.instructions&#125;&gt;</span><br><span class="line">          Press Cmd+R to reload,&#123;&apos;\n&apos;&#125;</span><br><span class="line">          Cmd+D or shake for dev menu</span><br><span class="line">        &lt;/Text&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    flex: 1,</span><br><span class="line">    justifyContent: &apos;center&apos;,</span><br><span class="line">    alignItems: &apos;center&apos;,</span><br><span class="line">    backgroundColor: &apos;#F5FCFF&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  welcome: &#123;</span><br><span class="line">    fontSize: 20,</span><br><span class="line">    textAlign: &apos;center&apos;,</span><br><span class="line">    margin: 10,</span><br><span class="line">  &#125;,</span><br><span class="line">  instructions: &#123;</span><br><span class="line">    textAlign: &apos;center&apos;,</span><br><span class="line">    color: &apos;#333333&apos;,</span><br><span class="line">    marginBottom: 5,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;NativeRN&apos;, () =&gt; NativeRN);</span><br></pre></td></tr></table></figure><h3 id="集成到原生项目中"><a href="#集成到原生项目中" class="headerlink" title="集成到原生项目中"></a><strong>集成到原生项目中</strong></h3><p>我这里先创建了一个ViewController，👇这样：</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-57083f070895282e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RNViewController"></p><p>然后导入<code>#import &lt;RCTRootView.h&gt;</code>头文件,👇这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    NSString * strUrl = @&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;;</span><br><span class="line">    NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];</span><br><span class="line">    </span><br><span class="line">    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">                                                         moduleName:@&quot;NativeRN&quot;</span><br><span class="line">                                                  initialProperties:nil</span><br><span class="line">                                                      launchOptions:nil];</span><br><span class="line">    self.view = rootView;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在info.plist文件中配置一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class="line">  &lt;dict&gt;</span><br><span class="line">    &lt;key&gt;NSExceptionDomains&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">      &lt;key&gt;localhost&lt;/key&gt;</span><br><span class="line">      &lt;dict&gt;</span><br><span class="line">       &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt;</span><br><span class="line">       &lt;true/&gt;</span><br><span class="line">      &lt;/dict&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">  &lt;/dict&gt;</span><br></pre></td></tr></table></figure><p>配置后的效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-df627970cb9285f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置info.plist"></p><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a><strong>运行项目</strong></h2><p>在运行项目前，先在react native文件夹目录下，启动开发服务器。也就是在本文中的RNComponent目录下，启动命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br></pre></td></tr></table></figure><p>运行项目，看到效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-6f3af1947e1b9f4d.gif?imageMogr2/auto-orient/strip" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你正准备从头开始制作一个新的应用，那么React Native会是个非常好的选择。但如果你只想给现有的原生应用中添加一两个视图或是业务流程，React Native也同样不在话下。只需简单几步，你就可以给原有应用加上新的基于React Native的特性、画面和视图等。&lt;/p&gt;
    
    </summary>
    
      <category term="react-native学习笔记" scheme="http://yoursite.com/categories/react-native%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>不思考，不读书</title>
    <link href="http://yoursite.com/2017/05/03/studying-thinking/"/>
    <id>http://yoursite.com/2017/05/03/studying-thinking/</id>
    <published>2017-05-03T02:01:06.000Z</published>
    <updated>2018-04-16T07:56:07.611Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493786655792&amp;di=f05339bf58c9f91345d8bffe016d8df4&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.zjknews.com%2Ffile%2F201703%2F27%2F58d7b03c64fa6d87f68bbdaf3cc2e80c.jpg%3FimageView2%2F2%2Fw%2F600" alt="读书"></p><p>越来越感觉脑子不够用了。最近在学习一些新的东西，也许是自己的基础不扎实，导致学起来很乱，没有侧重点，完完全全就是一团乱麻。常常是刚刚想出来一个解决办法，继续往下写的时候，突然发现之前的方法不太好，然后就推翻重来，如此循环往复，没有看到一点显著的成果，才让我心生焦虑。</p><a id="more"></a><p>最近还有一件事情使我非常苦恼，其实也算不上苦恼，归根结底的原因就是因为自己贪玩。是这样的，现在《王者荣耀》这款手游简直是火的不得了，我也未能免受其害。可游戏这东西，玩多了真的会上瘾，所以最近花在游戏上的时间有点多。一方面慨叹于光阴的易逝，而另一方面还在召唤师峡谷里忘情厮杀。之前卸载过几次，狠话也说了很多，可就是控制不住自己。思来想去，自己就是太爱玩了，也太没有自制力了。最近想到一个办法，就是用读书来转移玩游戏的注意力。暂时还不知道管不管用，以后除了工作，要尽可能的摆脱对手机的依赖，多去读书，多去思考，多出去走走。</p><p>之前看过一个节目，里面有人讲到“读书永不毕业”，我觉得说的挺对的。中国不也有句老话叫“活到老，学到老”吗？就我自己来讲，学习可以使我觉得我的大脑还可以思想，还在运转，再说大一点，就是还能感觉到自己活着。倘若让我每天重复的，机械的做一些事情，而没有时间去思考，我肯定会受不了。有时候仔细想想，万一真的有一天，自己的大脑停止思想了，真的是挺可怕的一件事。之所以长个脑子，不就是用来思考的吗？学习，思考，真的是一生都需要做的一件事。</p><p>年轻的大好光阴，不用来学习，很可惜，不是吗？</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1493786793295&amp;di=20f4de82a6affac573be5e75e9e0d51a&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20160427%2Fa6850906863b46eb8cb519723b97fc21.jpg" alt="不思考，不读书"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1493786655792&amp;amp;di=f05339bf58c9f91345d8bffe016d8df4&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg.zjknews.com%2Ffile%2F201703%2F27%2F58d7b03c64fa6d87f68bbdaf3cc2e80c.jpg%3FimageView2%2F2%2Fw%2F600&quot; alt=&quot;读书&quot;&gt;&lt;/p&gt;
&lt;p&gt;越来越感觉脑子不够用了。最近在学习一些新的东西，也许是自己的基础不扎实，导致学起来很乱，没有侧重点，完完全全就是一团乱麻。常常是刚刚想出来一个解决办法，继续往下写的时候，突然发现之前的方法不太好，然后就推翻重来，如此循环往复，没有看到一点显著的成果，才让我心生焦虑。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="读书，思考" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%EF%BC%8C%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>React-Native Fetch网络请求</title>
    <link href="http://yoursite.com/2017/04/27/react-native-fetch/"/>
    <id>http://yoursite.com/2017/04/27/react-native-fetch/</id>
    <published>2017-04-27T05:56:46.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>在react-native开发中，使用Fetch进行网络请求。<a href="http://reactnative.cn/docs/0.43/network.html#content" target="_blank" rel="noopener">官方文档上的网络请求</a></p><a id="more"></a><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a><strong>基本使用方法</strong></h2><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a><strong>GET请求</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(@&quot;http://www.baidu.com&quot;)</span><br><span class="line">  .then((response) =&gt; response.json()) </span><br><span class="line">  .then((responseJson) =&gt; &#123;</span><br><span class="line">    console.log(responseJson);//打印返回的数据</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error)=&gt;&#123;</span><br><span class="line">    console.log(error);//打印报的错</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><strong>catch住fetch可能抛出的异常，否则出错时你可能看不到任何提示。</strong></p><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a><strong>POST请求</strong></h3><p>Fetch还有可选的第二个参数，可以用来定制HTTP请求一些参数。你可以指定header参数，或是指定使用POST方法，又或是提交数据等等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;https://mywebsite.com/endpoint/&apos;, &#123;</span><br><span class="line">  method: &apos;POST&apos;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &apos;Accept&apos;: &apos;application/json&apos;,</span><br><span class="line">    &apos;Content-Type&apos;: &apos;application/json&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  body: JSON.stringify(&#123;</span><br><span class="line">    firstParam: &apos;yourValue&apos;,</span><br><span class="line">    secondParam: &apos;yourOtherValue&apos;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果你的服务器无法识别上面POST的数据格式，那么可以尝试传统的form格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;https://mywebsite.com/endpoint/&apos;, &#123;</span><br><span class="line">  method: &apos;POST&apos;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  body: &apos;key1=value1&amp;key2=value2&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" target="_blank" rel="noopener">Fetch请求文档</a>来查看所有可用的参数。</p><h2 id="简单封装"><a href="#简单封装" class="headerlink" title="简单封装"></a><strong>简单封装</strong></h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a><strong>GET</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">     *  get请求</span><br><span class="line">     *  url:请求地址</span><br><span class="line">     *  params:参数</span><br><span class="line">     *  callback:回调函数</span><br><span class="line">     * */</span><br><span class="line">    static get(url,params,callback)&#123;</span><br><span class="line">        if (params) &#123;</span><br><span class="line">            let paramsArray = [];</span><br><span class="line">            //拼接参数</span><br><span class="line">            Object.keys(params).forEach(key =&gt; paramsArray.push(key + &apos;=&apos; + params[key]))</span><br><span class="line">            if (url.search(/\?/) === -1) &#123;</span><br><span class="line">                url += &apos;?&apos; + paramsArray.join(&apos;&amp;&apos;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                url += &apos;&amp;&apos; + paramsArray.join(&apos;&amp;&apos;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //fetch请求</span><br><span class="line">        fetch(url,&#123;</span><br><span class="line">            method: &apos;GET&apos;,</span><br><span class="line">        &#125;)</span><br><span class="line">            .then((response) =&gt; &#123;</span><br><span class="line">                callback(response)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch((error) =&gt; &#123;</span><br><span class="line">                alert(error)</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a><strong>POST</strong></h3><p>post有两种形式：</p><ul><li><strong>第一种：’Content-Type’: ‘application/json’</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">     *  post请求</span><br><span class="line">     *  url:请求地址</span><br><span class="line">     *  params:参数,这里的参数格式是：&#123;param1: &apos;value1&apos;,param2: &apos;value2&apos;&#125;</span><br><span class="line">     *  callback:回调函数</span><br><span class="line">     * */</span><br><span class="line">    static postJSON(url,params,callback)&#123;</span><br><span class="line">        //fetch请求</span><br><span class="line">        fetch(url,&#123;</span><br><span class="line">            method: &apos;POST&apos;,</span><br><span class="line">            headers: &#123;</span><br><span class="line">              &apos;Accept&apos;: &apos;application/json&apos;,</span><br><span class="line">                &apos;Content-Type&apos;: &apos;application/json&apos;,</span><br><span class="line">            &#125;,</span><br><span class="line">            body:JSON.stringify(params)</span><br><span class="line">        &#125;)</span><br><span class="line">            .then((response) =&gt; response.json())</span><br><span class="line">            .then((responseJSON) =&gt; &#123;</span><br><span class="line">                callback(responseJSON)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch((error) =&gt; &#123;</span><br><span class="line">                console.log(&quot;error = &quot; + error)</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>第二种： form表单形式</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">     *  post请求</span><br><span class="line">     *  url:请求地址</span><br><span class="line">     *  params:参数,这里的参数要用这种格式：&apos;key1=value1&amp;key2=value2&apos;</span><br><span class="line">     *  callback:回调函数</span><br><span class="line">     * */</span><br><span class="line">    static postForm(url,params,callback)&#123;</span><br><span class="line">        //fetch请求</span><br><span class="line">        fetch(url,&#123;</span><br><span class="line">            method: &apos;POST&apos;,</span><br><span class="line">            headers: &#123;</span><br><span class="line">                &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">            &#125;,</span><br><span class="line">            body: params</span><br><span class="line">        &#125;)</span><br><span class="line">            .then((response) =&gt; response.json())</span><br><span class="line">            .then((responseJSON) =&gt; &#123;</span><br><span class="line">                callback(responseJSON)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch((error) =&gt; &#123;</span><br><span class="line">                console.log(&quot;error = &quot; + error)</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a><strong>调用</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//post请求</span><br><span class="line">let params = &#123;&apos;key1&apos;:&apos;value1&apos;,&apos;key2&apos;:&apos;value2&apos;&#125;;</span><br><span class="line">        NetRequest.postJSON(&apos;http://www.baidu.com/&apos;,params,function (set) &#123;</span><br><span class="line">            //下面的就是请求来的数据</span><br><span class="line">            console.log(set)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">//get请求,以百度为例,没有参数,没有header</span><br><span class="line">       NetRequest.get(&apos;https://www.baidu.com/&apos;,&apos;&apos;,function (set) &#123;</span><br><span class="line">            //下面是请求下来的数据</span><br><span class="line">            console.log(set)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p><strong>解释一下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将`JSON`数据转换成字符串</span><br><span class="line">JSON.stringify(params)</span><br><span class="line"></span><br><span class="line">//将数据JSON化</span><br><span class="line">JSON.parse(responseJSON)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在react-native开发中，使用Fetch进行网络请求。&lt;a href=&quot;http://reactnative.cn/docs/0.43/network.html#content&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档上的网络请求&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="react-native学习笔记" scheme="http://yoursite.com/categories/react-native%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="fetch" scheme="http://yoursite.com/tags/fetch/"/>
    
      <category term="rn网络请求" scheme="http://yoursite.com/tags/rn%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>iOS 获取crash日志</title>
    <link href="http://yoursite.com/2017/04/21/getCrashBlog/"/>
    <id>http://yoursite.com/2017/04/21/getCrashBlog/</id>
    <published>2017-04-21T02:39:05.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目上架到App Store以后，谁也不能保证没有一个错误，可能在测试期间连测试人员都没有发现的隐藏小bug在上线之后被用户发现了，这就无疑给用户造成了困扰。所以作为开发人员，要及时的收集这些crash日志信息，然后修复这些问题。</p><a id="more"></a><p>这里我用了一种方法，就是当应用在用户使用时发生崩溃现象，会获取到崩溃的日志，然后调起邮箱让用户通过邮件发送给我们。</p><p>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 获取异常日志</span><br><span class="line"></span><br><span class="line">- (void)installUncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line">void UncaughtExceptionHandler(NSException *exception) &#123;</span><br><span class="line"></span><br><span class="line">    NSArray *arr = [exception callStackSymbols];</span><br><span class="line">    NSString *reason = [exception reason];</span><br><span class="line">    NSString *name = [exception name];</span><br><span class="line">    NSString *currentVersion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleVersion&quot;];</span><br><span class="line">    NSString *urlStr = [NSString stringWithFormat:@&quot;mailto://developer@qq.com?subject=Crash报告&amp;body=您的建议会让我们做的更好，感谢您的配合！&lt;br&gt;&lt;br&gt;&lt;br&gt;&quot;&quot;错误详情(%@):&lt;br&gt;%@&lt;br&gt;-----------------------&lt;br&gt;%@&lt;br&gt;---------------------&lt;br&gt;%@&quot;,currentVersion,name,reason,[arr componentsJoinedByString:@&quot;&lt;br&gt;&quot;]];</span><br><span class="line">    NSURL *url = [NSURL URLWithString:[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];</span><br><span class="line">    [[UIApplication sharedApplication]openURL:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>AppDelegate</code>里的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;</span><br><span class="line"></span><br><span class="line">//获取异常报告</span><br><span class="line">    [self installUncaughtExceptionHandler];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中调用就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目上架到App Store以后，谁也不能保证没有一个错误，可能在测试期间连测试人员都没有发现的隐藏小bug在上线之后被用户发现了，这就无疑给用户造成了困扰。所以作为开发人员，要及时的收集这些crash日志信息，然后修复这些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 实用" scheme="http://yoursite.com/categories/iOS-%E5%AE%9E%E7%94%A8/"/>
    
    
      <category term="Crash Blog" scheme="http://yoursite.com/tags/Crash-Blog/"/>
    
  </entry>
  
  <entry>
    <title>ARC下的内存泄漏</title>
    <link href="http://yoursite.com/2017/04/18/ARCMemoryLeak/"/>
    <id>http://yoursite.com/2017/04/18/ARCMemoryLeak/</id>
    <published>2017-04-18T02:59:54.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>已习惯于arc帮我们管理内存的我们，写起代码来，比MRC似乎肆意妄为了许多，总有些有恃无恐的感觉，其实arc下面还是很容易引起内存溢出的。<br><a id="more"></a></p><p>ARC 是帮助我们做对象内存管理的一套机制，使得我们以前在 MRC 模式下管理内存工作量能在 ARC 模式下得到缓解。正如苹果官方文档上所描述的：<br>Automatic Reference Counting (ARC) is a compiler feature that provides automatic memory management of Objective-C objects.<br>可见 ARC 是编译时特性，它没有改变 Objective-C 引用计数式内存管理的本质，更不是 GC（垃圾回收）。<br>也就是说只要我们稍不注意，隐式的持有或复制对象就会造成内存泄露。</p><h1 id="NSNotificationcenter"><a href="#NSNotificationcenter" class="headerlink" title="NSNotificationcenter"></a><strong>NSNotificationcenter</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(method:) name:@&quot;notiName&quot; object:nil];</span><br></pre></td></tr></table></figure><p>这里添加观察者其实是不会造成内存泄漏的，但是，但是，但是……如果self被销毁，当在调用post消息的时候，就会报对象被释放的错误，导致闪退，所以在添加观察者的对象，一定要在它被销毁的时候从消息中心删除！</p><p>就是在注册通知的地方加上这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line"></span><br><span class="line">    [[NSNotificationCenter defaultCenter]removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a><strong>NSTimer</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(method:) userInfo:nil repeats:YES];</span><br></pre></td></tr></table></figure><p>上面的timer为了防止 target 被释放而导致的程序异常，timer 会持有 target， self 持有 timer，timer 在初始化时持有 self，造成循环引用。解决的方法就是使用 <code>invalidate</code> 方法销掉 timer。</p><h1 id="delegate属性的强引用"><a href="#delegate属性的强引用" class="headerlink" title="delegate属性的强引用"></a><strong>delegate属性的强引用</strong></h1><p>把<code>delegate</code>声明为<code>strong</code>属性容易导致内存溢出 。</p><p>解决办法是把<code>delegate</code>属性的<code>strong</code>改为<code>assign</code>或者<code>weak</code>即可。</p><blockquote><ul><li>当用<code>weak</code>或<code>assign</code>修饰的时候，指明该对象并不负责保持<code>delegate</code>这个对象，<code>delegate</code>这个对象的销毁由外部控制。</li></ul></blockquote><blockquote><ul><li>当用<code>strong</code>修饰的时候，该对象强引用<code>delegate</code>，外界不能销毁<code>delegate</code>对象，会导致循环引用(<code>Retain Cycles</code>)。</li></ul></blockquote><h1 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a><strong>WKWebView</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_webView.configuration.userContentController addScriptMessageHandler:self name:clickName];</span><br></pre></td></tr></table></figure><p>添加addScriptMessageHandler之后，必须在vc销毁前把它移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_webView.configuration.userContentController removeScriptMessageHandlerForName:clickName];</span><br></pre></td></tr></table></figure><p>和<code>NSNotification</code> 很类似。</p><h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a><strong>Block</strong></h1><p><img src="http://img.blog.csdn.net/20170418105339918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVGhyZWVfWmhhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>上面图片中就是一典型案例，红色部分就是修改之前导致内存溢出的代码，我们来分析一下： </p><p>上面的success block应该是self持有，而在success中有持有了self，导致self和 block 的循环引用，造成内存泄露！ </p><p>说到底还是造成了循环引用导致了内存泄漏，所以我们要打破循环，释放对象，这里我们把self变成了弱引用，打破循环引用。</p><p><strong>以上几种情况可能通过instrument 是查看不出来的，至少是没有小红叉的。我们通过instruments查看所有VC的引用计数才找到那些VC是发生了内存泄露。</strong></p><p><a href="http://blog.csdn.net/zhuchuanwu2013/article/details/51284733" target="_blank" rel="noopener">参考他的</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已习惯于arc帮我们管理内存的我们，写起代码来，比MRC似乎肆意妄为了许多，总有些有恃无恐的感觉，其实arc下面还是很容易引起内存溢出的。&lt;br&gt;
    
    </summary>
    
      <category term="iOS 实用" scheme="http://yoursite.com/categories/iOS-%E5%AE%9E%E7%94%A8/"/>
    
    
      <category term="ARC内存泄漏" scheme="http://yoursite.com/tags/ARC%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>金山城市沙滩游</title>
    <link href="http://yoursite.com/2017/04/16/visitJinShanCityBeach/"/>
    <id>http://yoursite.com/2017/04/16/visitJinShanCityBeach/</id>
    <published>2017-04-16T07:38:24.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>一大早就从床上爬起来，已经很久都没有起的这么早了，洗漱完毕，准备出发。聪明的我已经于昨晚查好了路线，确认无误后，正式出发。<br><a id="more"></a></p><p>对于大海，早就向往之，之前不知道上海的什么地方可以看到，一直耽搁未成行。但现在万事俱备，又恰逢这三四月舒爽的季节，还犹豫什么呢？</p><p>对于我这样一个在中原长大的孩子，高山、大海都可以让我惊奇不已（说出来很尴尬，还是在去年才真正的爬了一次山）。虽然很累，但心愿已了。说真的，我是特别喜欢这种山山水水的自然风光，一方面慨叹于大自然的鬼斧神工，另一方面可以使自己放松身心，心旷神怡。带着对大海的期许，在车上睡着了。。。</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-44c3c8cb6db3edf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="坐上了公交车去海边"></p><p>金山这个地方距离我住的地方真的很远，从747换到了上石线，坐上没多久我就睡着了，中间醒了好几次，竟然还没有到，然后就无聊的玩手机了。不知道过了多久，终于到了。下车没走多久就看到了4号口，走近才发现是出口，只让出不让进（只好改道咯）！问了出口的保安，给指了指5号口的方向，大踏步的前进吧！到了之后，掏钱买票。。。等等，，，没带钱？？？翻遍了全身的口袋，找到了三块钱（两个硬币和一张纸币）。WTF!这下可怎么办，不过，经历过大风大浪的我，怎么可能让这点小事难倒。瞬间就想到了这是21世纪，接着在电光石火间就想到可以美团啊。哈哈哈，这点小事怎么可能难倒我。然而，售票的妹子（虽然以我的眼力一眼看不出她的年龄，姑且叫她大妹子吧）告诉我这个入口网上订的票不能进，要去3号口，QNMLGB。心里碎碎念了好久，这能怪谁呢？能怪我没带现金吗？当然不能，只能怪他们的设施不够现代化，接着走吧，顶着一轮明日，终于来到了。当然，拍个照先。</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-78afd1bb1de88185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一个看样子可以从水上起飞的飞机，厉害了"></p><p>买票，进去，我看这次谁还敢拦我！</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-3098e55082fc894e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通行证，20大洋"></p><p>现在是非泳期，但是是周末，所以票价是20。来都来了，再贵也得进啊。马上就能看到大海了，好激动。。。</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-9f8ec23ad4e2e8c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="看不出来这是大海是不是？"></p><p>这是什么鬼啊？这叫大海吗？这样的大海是带不走我的哀愁的吧？</p><p>远处被一道像是大坝的东西给围住了，过来的浪一个个小的可怜，完全不是我想象中的样子。看到一块大石头，心想着，怎么着也得上去吟诗一首吧，跳上去刚刚站好，直抒胸臆的“啊”还没出口，背后响起了“帅哥，快下来，那里不让上噢”的声音，刚刚涌上来的灵感，汇成了一句“好的，马上下来”喷涌而出。</p><p>继续往前走，沙滩上的沙子是真的沙子，我没有脱鞋去感受，因为我怕扎了脚。</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-3946c6600eaebba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="又是围栏"></p><p>终于到了可以近距离接触到水的地方了，可还是被围栏围起来了，很煞风景有没有？没有比基尼美女（这个天气也不可能有，这才四月份）也就算了，就这点水还围起来，真是够了！沙滩上的一群大妈在热火朝天的聊着，时不时的还扭几下，难道是传说中的“沙滩舞蹈队”？正在我暗暗猜测她们的真正身份的时候，突然，三个大妈从人群中走了出来，背对着大海站好，她们对面还站着一位拍照的大妈，在拍照大妈的口令声中：“1”，“2”，“3”，三个大妈突然像少女般的跳了起来，而且还摆出了pose，全身闪起了青春的光芒，光芒四射，刺痛了我的眼睛。当然pose还未摆好，就已经从空中着陆了，毕竟跳起的高度有限。</p><p>再往前走，一股下水道污泥的味道扑面而来。只好调整方向，然后沙雕映入眼帘。</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-1653707b71091b84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="沙雕1"></p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-ba59eeb356c72d70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="沙雕2"></p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-cc426c17a96e948f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="应该是维护安全的炮楼"></p><p>再往前走，视线开阔了一些，能看到远处的海域，似有若无的小岛。迎面的海风吹来，真的有点大海的感觉了。还有乘坐快艇在水中驰骋的乘客。好了，没有优美的词再去赞美这个地方了，能想到的就这么多。😁大概用了不到一个小时，就把这里全转了个遍，而且还是在我故意放慢脚步的情况下。总的来说，这里满足不了对大海的憧憬，充其量就算是个亲子乐园吧。最后放上拍的看起来还不错的图用以以后怀念这里吧，反正绝对不会再来第二次了。</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-8f92d2a52b6f08d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这个角度看起来还不错"></p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-2861ca5258d9ef92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="疾驰的快艇和悠悠的帆船"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一大早就从床上爬起来，已经很久都没有起的这么早了，洗漱完毕，准备出发。聪明的我已经于昨晚查好了路线，确认无误后，正式出发。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>iOS 本地推送（通知）</title>
    <link href="http://yoursite.com/2017/04/14/localNotification/"/>
    <id>http://yoursite.com/2017/04/14/localNotification/</id>
    <published>2017-04-14T03:17:32.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前一直迷惑，本地推送到底有什么用，后来仔细想了想，确实有用（废话，不然苹果爸爸干嘛开发这个？手动鄙视自己！）<br><a id="more"></a></p><p><strong>本地通知服务 主要处理基于时间行为的通知。比如定时通知用户该起床撒尿了。</strong></p><p>就是这么个用处！嗯，是这样吧？是的！</p><p>在iOS10苹果废弃了之前的<code>UILocalNotification</code>，而采用了新的<code>UserNotifications Framework</code>来推送通知。现在先说一下iOS10之前的本地推送流程！</p><h2 id="iOS-10之前"><a href="#iOS-10之前" class="headerlink" title="iOS 10之前"></a><strong>iOS 10之前</strong></h2><h3 id="注册通知"><a href="#注册通知" class="headerlink" title="注册通知"></a><strong>注册通知</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if ([[UIDevice currentDevice].systemVersion floatValue] &gt; 8.0) &#123;</span><br><span class="line">        </span><br><span class="line">        UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil];</span><br><span class="line">        [application registerUserNotificationSettings:settings];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a><strong>发送通知</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建一个本地通知</span><br><span class="line">    UILocalNotification *localNote = [[UILocalNotification alloc] init];</span><br><span class="line">    </span><br><span class="line">    // 1.1.设置通知发出的时间</span><br><span class="line">    localNote.fireDate = [NSDate dateWithTimeIntervalSinceNow:5];</span><br><span class="line">    </span><br><span class="line">    // 1.2.设置通知内容</span><br><span class="line">    localNote.alertBody = @&quot;这是一个本地推送&quot;;</span><br><span class="line">    </span><br><span class="line">    // 1.3.设置锁屏时,字体下方显示的一个文字</span><br><span class="line">    localNote.alertAction = @&quot;看我&quot;;</span><br><span class="line">    localNote.hasAction = YES;</span><br><span class="line">    </span><br><span class="line">    // 1.4.设置启动图片(通过通知打开的)</span><br><span class="line">    localNote.alertLaunchImage = @&quot;../Documents/1.jpg&quot;;</span><br><span class="line">    </span><br><span class="line">    // 1.5.设置通过到来的声音</span><br><span class="line">    localNote.soundName = UILocalNotificationDefaultSoundName;</span><br><span class="line">    </span><br><span class="line">    // 1.6.设置应用图标左上角显示的数字</span><br><span class="line">    localNote.applicationIconBadgeNumber = 1;</span><br><span class="line">    </span><br><span class="line">    // 1.7.设置一些额外的信息</span><br><span class="line">    localNote.userInfo = @&#123;@&quot;hello&quot; : @&quot;how are you&quot;, @&quot;msg&quot; : @&quot;success&quot;&#125;;</span><br><span class="line">    </span><br><span class="line">    // 2.执行通知</span><br><span class="line">    [[UIApplication sharedApplication] scheduleLocalNotification:localNote];</span><br></pre></td></tr></table></figure><p>这里要说一点，就是iOS系统限制了注册本地推送的数量，最大的注册量为64条。</p><h3 id="接收推送"><a href="#接收推送" class="headerlink" title="接收推送"></a><strong>接收推送</strong></h3><ul><li>应用在前台或后台，未被杀死时。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//程序处于前台或后台时调用</span><br><span class="line">- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;333这里被调用&quot;);</span><br><span class="line">    UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@&quot;Title&quot; message:@&quot;程序在前台或后台，未被杀死，点击通知栏调用&quot; delegate:self cancelButtonTitle:@&quot;cancel&quot; otherButtonTitles:@&quot;ok&quot;, nil];</span><br><span class="line">    [alert show];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序已被杀死时</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (launchOptions[UIApplicationLaunchOptionsLocalNotificationKey]) &#123;</span><br><span class="line">        //添加处理代码</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;666这里被调用&quot;);</span><br><span class="line">        UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@&quot;Title&quot; message:@&quot;程序已被杀死，点击通知栏调用&quot; delegate:self cancelButtonTitle:@&quot;cancel&quot; otherButtonTitles:@&quot;ok&quot;, nil];</span><br><span class="line">        [alert show];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iOS-10之后"><a href="#iOS-10之后" class="headerlink" title="iOS 10之后"></a><strong>iOS 10之后</strong></h2><p>先导入这个东西<code>#import &lt;UserNotifications/UserNotifications.h&gt;</code></p><h3 id="注册通知-1"><a href="#注册通知-1" class="headerlink" title="注册通知"></a><strong>注册通知</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line">    </span><br><span class="line">    // 使用 UNUserNotificationCenter 来管理通知</span><br><span class="line">    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">    //监听回调事件</span><br><span class="line">    center.delegate = self;</span><br><span class="line">    </span><br><span class="line">    //iOS 10 使用以下方法注册，才能得到授权</span><br><span class="line">    [center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert + UNAuthorizationOptionSound + UNAuthorizationOptionBadge)</span><br><span class="line">                          completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</span><br><span class="line">                              // Enable or disable features based on authorization.</span><br><span class="line">                          &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送通知-1"><a href="#发送通知-1" class="headerlink" title="发送通知"></a><strong>发送通知</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 使用 UNUserNotificationCenter 来管理通知</span><br><span class="line">    UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];</span><br><span class="line">    </span><br><span class="line">    //需创建一个包含待通知内容的 UNMutableNotificationContent 对象，注意不是 UNNotificationContent ,此对象为不可变对象。</span><br><span class="line">    UNMutableNotificationContent* content = [[UNMutableNotificationContent alloc] init];</span><br><span class="line">    content.title = [NSString localizedUserNotificationStringForKey:@&quot;本地推送Title&quot; arguments:nil];</span><br><span class="line">    content.body = [NSString localizedUserNotificationStringForKey:@&quot;本地推送Body&quot;     arguments:nil];</span><br><span class="line">    content.sound = [UNNotificationSound defaultSound];</span><br><span class="line">    </span><br><span class="line">    // 在 设定时间 后推送本地推送</span><br><span class="line">    UNTimeIntervalNotificationTrigger* trigger = [UNTimeIntervalNotificationTrigger</span><br><span class="line">                                                  triggerWithTimeInterval:5 repeats:NO];</span><br><span class="line">    </span><br><span class="line">    UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:@&quot;FiveSecond&quot;</span><br><span class="line">                                                                          content:content trigger:trigger];</span><br><span class="line">    </span><br><span class="line">    //添加推送成功后的处理！</span><br><span class="line">    [center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><h3 id="通知处理"><a href="#通知处理" class="headerlink" title="通知处理"></a><strong>通知处理</strong></h3><p>实现<code>UNUserNotificationCenterDelegate</code>代理方法:</p><ul><li>第一个代理方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 处理完成后条用 completionHandler ，用于指示在前台显示通知的形式</span><br><span class="line">    completionHandler(UNNotificationPresentationOptionSound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中的那句话就是，当应用在前台的时候，收到本地通知，是用什么方式来展现。系统给了三种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, UNNotificationPresentationOptions) &#123;</span><br><span class="line">    UNNotificationPresentationOptionBadge   = (1 &lt;&lt; 0),</span><br><span class="line">    UNNotificationPresentationOptionSound   = (1 &lt;&lt; 1),</span><br><span class="line">    UNNotificationPresentationOptionAlert   = (1 &lt;&lt; 2),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二个代理方法：</li></ul><p>这个方法是在后台或者程序被杀死的时候，点击通知栏调用的，在前台的时候不会被调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler&#123;</span><br><span class="line"></span><br><span class="line">    UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@&quot;Title&quot; message:@&quot;message&quot; delegate:self cancelButtonTitle:@&quot;cancel&quot; otherButtonTitles:@&quot;ok&quot;, nil];</span><br><span class="line">    [alert show];</span><br><span class="line">    </span><br><span class="line">    completionHandler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前一直迷惑，本地推送到底有什么用，后来仔细想了想，确实有用（废话，不然苹果爸爸干嘛开发这个？手动鄙视自己！）&lt;br&gt;
    
    </summary>
    
      <category term="iOS 推送" scheme="http://yoursite.com/categories/iOS-%E6%8E%A8%E9%80%81/"/>
    
    
      <category term="本地推送" scheme="http://yoursite.com/tags/%E6%9C%AC%E5%9C%B0%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS UITableView的一些琐碎</title>
    <link href="http://yoursite.com/2017/04/13/handleUITableView/"/>
    <id>http://yoursite.com/2017/04/13/handleUITableView/</id>
    <published>2017-04-13T09:36:27.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>表格UITableView基本上开发中应用最常用的控件之一了，关于tableview你又了解多少呢，反正我是只知道一些常规的用法，现在把之前写过的项目中应用到的一些小细节总结一下。<br><a id="more"></a></p><h1 id="cell分割线"><a href="#cell分割线" class="headerlink" title="cell分割线"></a><strong>cell分割线</strong></h1><p>这个不知道是不是我自己的问题，第一次遇到要将cell分割线与屏幕边缘没有间距的需求时，试了好多方法！</p><h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a><strong>第一种方法</strong></h2><p>下面的这个在Objective-C里写了没有什么效果，但在Swift中可以完美执行，我不知道是不是我一个人的问题。贴出来这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableView.separatorInset = UIEdgeInsetsZero;</span><br></pre></td></tr></table></figure><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a><strong>第二种方法</strong></h2><p>这个方法是在论坛里看到的，试了试，可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line"></span><br><span class="line">    cell.separatorInset = UIEdgeInsetsZero;</span><br><span class="line">    cell.layoutMargins = UIEdgeInsetsZero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tableView的这个代理方法是在cell将要出现在屏幕的时候调用。但是这种方法和第一种方法有个什么问题呢？就是不能将<code>tableView.separatorStyle</code>设置为<code>UITableViewCellSeparatorStyleNone</code>,这样就导致了如果cell的个数不足以充满屏幕的话，会在cell的底部看到空余的cell分割线，这对于我这个强迫症是不能忍的，当然了也有解决办法，就是添加一句：<code>tableView.tableFooterView = [UIView new];</code>就OK了。</p><h2 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a><strong>第三种方法</strong></h2><p>自从在oc中知道第一种方法不能用之后，基本上我都在用这种方法，就是在自定义的cell里重新画线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line"></span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    </span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    CGContextSetFillColorWithColor(context, [UIColor clearColor].CGColor);</span><br><span class="line">    CGContextFillRect(context, rect);</span><br><span class="line">    </span><br><span class="line">    CGContextSetStrokeColorWithColor(context, [UIColor colorWithRed:225.0/255.0 green:225.0/255.0 blue:225.0/255.0 alpha:1.0].CGColor);</span><br><span class="line">    CGContextStrokeRect(context, CGRectMake(0, 0, SCREEN_WIDTH, 0.5));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    CGContextSetStrokeColorWithColor(context, [UIColor colorWithRed:225.0/255.0 green:225.0/255.0 blue:225.0/255.0 alpha:1.0].CGColor);</span><br><span class="line">    CGContextStrokeRect(context, CGRectMake(0, rect.size.height-0.5, SCREEN_WIDTH, 0.5));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新绘制的话，可以设置分割线的颜色，长度，高度。</p><h1 id="卡片式cell"><a href="#卡片式cell" class="headerlink" title="卡片式cell"></a><strong>卡片式cell</strong></h1><p>就是下面这种效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-d29da2b87b099b3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="卡片式cell"></p><p>实现这种效果我已知的有三种效果：</p><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a><strong>第一种</strong></h2><p>通过设置<code>cell</code>的<code>contentView</code>来间接实现，在<code>cell</code>的<code>contentView</code>的顶部或者底部留下一定的间距，这样就会有<code>cell</code>间就有间距的效果。但是这种方式在<code>cell</code>有点击效果的时候，会很明显的看出有分层，因为这时候<code>cell</code>是被点击的，<code>contentView</code>都会有系统点击的阴影效果。这种方式在<code>cell</code>左滑删除，置顶等操作的时候，左滑出的视图会高出一部分（左滑显示出的高度=（cell的高度-留下的间距高度）+ 留下的间距高度），很显然这种方式有致命缺陷。</p><p><strong>建议还是不要第一种方法</strong></p><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a><strong>第二种</strong></h2><p>通过分组的方式间接的实现，每组的Header可以当做是cell之间的间距，每组中只有一个cell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; </span><br><span class="line">    </span><br><span class="line">    return 10;</span><br><span class="line">&#125; </span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123; </span><br><span class="line"></span><br><span class="line">return 10;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; </span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; </span><br><span class="line"></span><br><span class="line">return 100;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是呢，这还是会出现一个问题，因为系统默认分组的时候每组的Header会停留在tableview的顶部，这要怎么处理呢？网上也有一种解决办法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; </span><br><span class="line"></span><br><span class="line">if (scrollView == self.tableView) &#123; </span><br><span class="line"></span><br><span class="line">CGFloat sectionHeaderHeight = 10; </span><br><span class="line"></span><br><span class="line">if (scrollView.contentOffset.y &lt;= sectionHeaderHeight &amp;&amp; scrollView.contentOffset.y &gt;= 0) &#123; </span><br><span class="line"></span><br><span class="line">scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0); </span><br><span class="line">&#125; else if (scrollView.contentOffset.y &gt;= sectionHeaderHeight) &#123; </span><br><span class="line"></span><br><span class="line">scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方式是通过scroll偏移量来监听和改变tableview的contentInset，因为只要UITableView在滚动就一直在运行，不是很好。</p><h2 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a><strong>第三种</strong></h2><p>重写cell的setFrame方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)setFrame:(CGRect)frame &#123;</span><br><span class="line"></span><br><span class="line">    frame.origin.x = 15;</span><br><span class="line">    frame.size.width -= 2 * frame.origin.x;</span><br><span class="line">    frame.size.height -= 15;</span><br><span class="line">    frame.origin.y += 10;</span><br><span class="line">    [super setFrame:frame];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式看上去很优雅，其实也有缺点，就是不适合有编辑的情况，因为在编辑的时候会不停调用setFrame方法，导致错乱，此时建议使用上面的第二种方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;表格UITableView基本上开发中应用最常用的控件之一了，关于tableview你又了解多少呢，反正我是只知道一些常规的用法，现在把之前写过的项目中应用到的一些小细节总结一下。&lt;br&gt;
    
    </summary>
    
      <category term="iOS 实用" scheme="http://yoursite.com/categories/iOS-%E5%AE%9E%E7%94%A8/"/>
    
    
      <category term="UItableView" scheme="http://yoursite.com/tags/UItableView/"/>
    
  </entry>
  
  <entry>
    <title>iOS 常用操作之文件操作</title>
    <link href="http://yoursite.com/2017/04/13/fileOperations/"/>
    <id>http://yoursite.com/2017/04/13/fileOperations/</id>
    <published>2017-04-13T09:13:35.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目开发中，不可避免的会遇到将一些东西存到本地，或者在本地创建新的文件或文件夹，特地在此总结了一下。</p><a id="more"></a><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h1><h2 id="获取Documents文件夹路径"><a href="#获取Documents文件夹路径" class="headerlink" title="获取Documents文件夹路径"></a><strong>获取Documents文件夹路径</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  获取Documents文件夹路径</span><br><span class="line">*</span><br><span class="line">*  @return 文件夹路径</span><br><span class="line">*/</span><br><span class="line">+ (NSString *)getDocumentsFolderPath&#123;</span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">return [paths objectAtIndex:0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取Documents文件路径"><a href="#获取Documents文件路径" class="headerlink" title="获取Documents文件路径"></a><strong>获取Documents文件路径</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  获取Documents文件路径</span><br><span class="line">*</span><br><span class="line">*  @param fileName 文件名称</span><br><span class="line">*</span><br><span class="line">*  @return 文件路径</span><br><span class="line">*/</span><br><span class="line">+ (NSString *)getDocumentsFilePath:(NSString *)fileName</span><br><span class="line">&#123;</span><br><span class="line">return [[self getDocumentsFolderPath] stringByAppendingPathComponent:fileName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取一个目录所占的空间大小"><a href="#获取一个目录所占的空间大小" class="headerlink" title="获取一个目录所占的空间大小"></a><strong>获取一个目录所占的空间大小</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">*  获取一个目录所占的空间大小</span><br><span class="line">*</span><br><span class="line">*  @param filePath 文件目录路径</span><br><span class="line">*</span><br><span class="line">*  @return 目录空间大小</span><br><span class="line">*/</span><br><span class="line">+ (long long)fileSizeAtPath:(NSString*) filePath&#123;</span><br><span class="line">NSFileManager* manager = [NSFileManager defaultManager];</span><br><span class="line">if ([manager fileExistsAtPath:filePath])&#123;</span><br><span class="line">return [[manager attributesOfItemAtPath:filePath error:nil] fileSize];</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件是否存在"><a href="#文件是否存在" class="headerlink" title="文件是否存在"></a><strong>文件是否存在</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*文件是否存在*/  </span><br><span class="line">+ (BOOL)isFileExisted:(NSString *)fileName&#123;  </span><br><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];  </span><br><span class="line">if(![fileManager fileExistsAtPath:[self getFilePath:fileName]])&#123;  </span><br><span class="line">return NO;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">return YES;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建指定名字的文件"><a href="#创建指定名字的文件" class="headerlink" title="创建指定名字的文件"></a><strong>创建指定名字的文件</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*创建指定名字的文件*/  </span><br><span class="line">+ (BOOL)createFileAtPath:(NSString *)fileName&#123;  </span><br><span class="line">NSArray *array = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);  </span><br><span class="line">NSString *path = [[array objectAtIndex:0] stringByAppendingPathComponent:fileName];  </span><br><span class="line">NSLog(@&quot;-----%@:&quot;, path);  </span><br><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];  </span><br><span class="line">if(![fileManager fileExistsAtPath:path])&#123;  </span><br><span class="line">[fileManager createFileAtPath:path contents:nil attributes:nil];  </span><br><span class="line">return YES;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">return NO;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建指定名字的文件夹"><a href="#创建指定名字的文件夹" class="headerlink" title="创建指定名字的文件夹"></a><strong>创建指定名字的文件夹</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*创建指定名字的文件夹*/  </span><br><span class="line">+ (BOOL)createDirectoryAtPath:(NSString *)fileName&#123;  </span><br><span class="line">NSArray *array = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);  </span><br><span class="line">NSString *path = [[array objectAtIndex:0] stringByAppendingPathComponent:fileName];  </span><br><span class="line">NSLog(@&quot;-----%@:&quot;, path);  </span><br><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];  </span><br><span class="line">if(![fileManager fileExistsAtPath:path])&#123;  </span><br><span class="line">NSError *error = nil;  </span><br><span class="line">[fileManager createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:&amp;error];  </span><br><span class="line">return YES;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">return NO;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a><strong>删除文件</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)deleteFileAtPath:(NSString *)fileName&#123;  </span><br><span class="line">NSArray *array = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);  </span><br><span class="line">NSString *path = [[array objectAtIndex:0] stringByAppendingPathComponent:fileName];  </span><br><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];  </span><br><span class="line"></span><br><span class="line">if(![fileManager fileExistsAtPath:path])&#123;  </span><br><span class="line">return NO;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">[fileManager removeItemAtPath:path error:nil];  </span><br><span class="line">return YES;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a><strong>NSUserDefaults</strong></h1><p><strong>保存和取出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">保存</span><br><span class="line"></span><br><span class="line">@param value &lt;#value description#&gt;</span><br><span class="line">@param key &lt;#key description#&gt;</span><br><span class="line">*/</span><br><span class="line">+(void)saveValue:(id) value forKey:(NSString *)key&#123;</span><br><span class="line"></span><br><span class="line">NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">[userDefaults setObject:value forKey:key];</span><br><span class="line">[userDefaults synchronize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">取出</span><br><span class="line"></span><br><span class="line">@param key &lt;#key description#&gt;</span><br><span class="line">@return &lt;#return value description#&gt;</span><br><span class="line">*/</span><br><span class="line">+(id)valueForKey:(NSString *)key&#123;</span><br><span class="line"></span><br><span class="line">NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">return [userDefaults objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">根据key取出NSString的value</span><br><span class="line"></span><br><span class="line">@param key &lt;#key description#&gt;</span><br><span class="line">@return &lt;#return value description#&gt;</span><br><span class="line">*/</span><br><span class="line">+(id)StringForKey:(NSString *)key&#123;</span><br><span class="line"></span><br><span class="line">NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">return [userDefaults stringForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">根据key取出Bool型的值</span><br><span class="line"></span><br><span class="line">@param key &lt;#key description#&gt;</span><br><span class="line">@return &lt;#return value description#&gt;</span><br><span class="line">*/</span><br><span class="line">+(BOOL)boolValueForKey:(NSString *)key&#123;</span><br><span class="line"></span><br><span class="line">NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">return [userDefaults boolForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">保存Bool型的值</span><br><span class="line"></span><br><span class="line">@param value value</span><br><span class="line">@param key key</span><br><span class="line">*/</span><br><span class="line">+(void)saveBoolValue:(BOOL)value forKey:(NSString *)key&#123;</span><br><span class="line"></span><br><span class="line">NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">[userDefaults setBool:value forKey:key];</span><br><span class="line">[userDefaults synchronize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">获取userDefaults存储的所有信息</span><br><span class="line">*/</span><br><span class="line">+(void)printAllUserDefault&#123;</span><br><span class="line"></span><br><span class="line">NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">NSDictionary *dic = [userDefaults dictionaryRepresentation];</span><br><span class="line">NSLog(@&quot;%@&quot;,dic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目开发中，不可避免的会遇到将一些东西存到本地，或者在本地创建新的文件或文件夹，特地在此总结了一下。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 实用" scheme="http://yoursite.com/categories/iOS-%E5%AE%9E%E7%94%A8/"/>
    
    
      <category term="本地存储" scheme="http://yoursite.com/tags/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>swiftOptional</title>
    <link href="http://yoursite.com/2017/04/07/swiftOptional/"/>
    <id>http://yoursite.com/2017/04/07/swiftOptional/</id>
    <published>2017-04-07T01:13:35.000Z</published>
    <updated>2018-04-16T07:56:55.115Z</updated>
    
    <content type="html"><![CDATA[<p>学习<code>swift</code>的过程中不可避免的会遇到<code>？</code>或<code>！</code>这种东西，这就是今天要说的可选型（<code>Optional</code>)了。大家都知道，<code>swift</code>是苹果官方推出的一款较于<code>Objective-C</code>安全性较高的语言，而可选型就是<code>swift</code>最为突出的特性之一。</p><a id="more"></a><h1 id="Optional是什么？"><a href="#Optional是什么？" class="headerlink" title="Optional是什么？"></a><strong>Optional是什么？</strong></h1><p><code>Optional</code> 是 <code>Swift</code> 新加入的类型。可选型的意思简单理解是：有值得时候就有值，无值的时候就是 <code>nil</code> 。<code>Swift</code> 中的 <code>nil</code> 和其他语言中的 <code>nil</code> 还有些不一样，<code>nil</code> 自己本身就是一种类型，没有就是 <code>nil</code> ，是和其他类型严格区分开的。<br>可选型的定义很简单：类型 + ? 。比如  <code>String?</code>、<code>Int?</code>、<code>Float?</code> 等，这里需要注意的是 <code>String?</code> 和 <code>String</code> 是完全不同的两个类型，前者是 <code>String</code> 类型的可选型，后者是 <code>String</code> 类型，注意区分。举个例子，在 OC 中我们可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *name = @&quot;jack&quot;;</span><br><span class="line">name = nil;</span><br></pre></td></tr></table></figure><p>而在swift中如果像下面这种写法是会报错的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//这种写法是会报错的，说的是 nil 是不可以分配给 String 类型的，这也说明在 swift 中 nil 是和其他类型严格区分的。</span><br><span class="line">var name: String = &quot;jack&quot;</span><br><span class="line">name = nil</span><br></pre></td></tr></table></figure><p>改为可选型之后就可以了，像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;name&quot;</span><br><span class="line">name = nil</span><br></pre></td></tr></table></figure><p>可选型，顾名思义就是可以选择，比如 <code>String?</code> 的意思就是可以在 <code>String</code> 和 <code>nil</code> 之间选择，可以是 <code>String</code> 也可以是 <code>nil</code> 。如果一个变量定义成 <code>String</code>，那么这个变量就会是 <code>String</code> 类型，而不可能是<code>nil</code>。</p><p>还有一点需要注意的是声明可选型必须是显示的声明也就是必须是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = nil</span><br></pre></td></tr></table></figure><p>而不能是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name = nil</span><br></pre></td></tr></table></figure><p>这样，因为 Swift 在做类型判断的时候无法判断 name 到底是 String 类型的可选型还是其他类型的可选型，因此会导致编译错误。</p><blockquote><p>Tips: 当然枚举类型的写法还可以如</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; var name: Optional&lt;String&gt; = Optional.Some(&quot;Loveway&quot;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这样，只不过我们一般都用</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; var name: String? = nil</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这样的简写。</p></blockquote><h1 id="Optional的解包"><a href="#Optional的解包" class="headerlink" title="Optional的解包"></a><strong>Optional的解包</strong></h1><p>可选型是不能够被直接使用的（因为 Swift 是类型安全的，可选型的值又可能会是 nil，如果不做处理可能导致程序 crash），如果我们想使用可选型的值，那么在这之前我们需要做的一项工作就是：解包（unwarp）！</p><ul><li><strong>1.强制解包</strong></li></ul><p>所谓的强制解包意思就是我知道这个类型是可选型，但是在我的程序执行到这里的时候我可以保证它是有值得，所以我要在这里使用它。具体表现形式就是在可选型后面加个 <code>!</code>，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;jack&quot;</span><br><span class="line">print(&quot;My name is &quot; + name!)</span><br></pre></td></tr></table></figure><p>但是这样的解包是不安全，因为你不知道什么时候你的这个可选型就会变成 nil，如果我们代码非常多的话，一不小心为 nil了，可能会导致程序崩溃。这个时候我们会想到一种方法：判空！如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;loveway&quot;</span><br><span class="line">if name != nil &#123; </span><br><span class="line">  print(&quot;My name is &quot; + name!)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  print(&quot;name is nil&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写似乎是没有什么问题了，但是需要注意的是，你在判断非 nil 的作用域内使用 name 的时候还必须把 ! 带上，这样代码比较多的时候还是比较麻烦。于是我们可以使用下面这种方式:</p><ul><li><strong>2.使用 <code>if let</code> 解包</strong></li></ul><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;jack&quot;</span><br><span class="line">if let name = name &#123;</span><br><span class="line"> print(&quot;My name is &quot; + name)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  print(&quot;name is nil&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解包方式可以保证 name 是解包过的，不会再是 nil 这种情况，其实逻辑是和上面做非空判断一样的。当然你把  <code>let</code> 换成 <code>var</code> 也是可以的，效果是一样的，只不过我们一般要用的是解包后的值，而不会去改变它，所以平常使用中一般都是用  <code>if let</code> 。</p><p>同时  <code>if let</code> 可以同时一次性解包多个可选型，用  <code>,</code> 隔开，使语句简洁，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;loveway&quot;</span><br><span class="line">var age: Int? = 18</span><br><span class="line">if let name = name, age = age &#123;</span><br><span class="line"> print(&quot;My name is &quot; + name + &quot;My age is&quot; + &quot;\(age)&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  print(&quot;name is nil&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，既然这里使用的是 if ，那么同样我们可以如下这样用，来进行进一步的判断筛选:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;loveway&quot;</span><br><span class="line">var age: Int? = 18</span><br><span class="line">if let name = name, age = age where age == 18 &#123;</span><br><span class="line">  print(&quot;My name is \(name), age is \(String(age))&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  print(&quot;name is nil&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可选链式调用（Optional-Chaining）"><a href="#可选链式调用（Optional-Chaining）" class="headerlink" title="可选链式调用（Optional Chaining）"></a><strong>可选链式调用（Optional Chaining）</strong></h1><p>可选链式调用（Optional Chaining）是一种可以在当前值可能为 nil 的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功，如果可选值是 nil ，那么调用将返回 nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为 nil ，整个调用链都会失败，即返回 nil 。</p><p>下面我们就来举个例子具体说明可选链，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;loveway&quot;</span><br><span class="line">if let name = name &#123;</span><br><span class="line">    print(name.uppercaseString)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;name is nil&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来解包 name ，如果有值就打印出 name 的大写，如果没有就输出 name is nil ，其实上面这段代码完全等同于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;loveway&quot;</span><br><span class="line">name?.uppercaseString</span><br></pre></td></tr></table></figure><p>上面这句代码的意思就是如果可选型变量 name 有值，那么就对 name 进行解包，并得到 name 的uppercaseString 值，如果没有，那么这句代码就会返回一个 nil 。这样就符合 Swift 的类型安全，完全是没有问题的。但是如果你写成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name: String? = &quot;loveway&quot;</span><br><span class="line">name!.uppercaseString</span><br></pre></td></tr></table></figure><p>也是可以的，不过不安全，因为如果 name 没有值，你进行强制解包，就会报错。</p><p>所以我们以后可能会用到类似于 person?.name?.uppercaseString 这样的一层层解包的，这种就是可选链。</p><h1 id="Nil-Coalescing-Operator（空合运算符）"><a href="#Nil-Coalescing-Operator（空合运算符）" class="headerlink" title="Nil Coalescing Operator（空合运算符）"></a><strong>Nil Coalescing Operator（空合运算符）</strong></h1><p>如上，如果我们想把解包后的值存起来的话，可以这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let newName = name == nil ? &quot;no name&quot; : name!</span><br></pre></td></tr></table></figure><p>上面代码的意思就是如果 name 为 nil ，newName 就是 “no name”，否则 newName 就是 name!（name的解包）。其实 Swift 为我们提供了更简洁的语法，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let newName2 = name ?? &quot;no name&quot;</span><br></pre></td></tr></table></figure><p>上面代码的意思就是 name 如果有值 newName2 的值就是 name! ,否则就是 no name 。这里需要注意的是 ??是空合运算符，这样写的可阅读性强，比较简洁。</p><p>当然关于 ?? 远不止这些，有兴趣的同学可以看 <a href="http://www.jianshu.com/p/3ede1ec31351" target="_blank" rel="noopener">聊聊swift语言中的“??”</a> 这篇文章。</p><h1 id="隐式可选型"><a href="#隐式可选型" class="headerlink" title="隐式可选型"></a><strong>隐式可选型</strong></h1><p>上面我们都知道了，创建一个显示可选型是: 类型 + <code>?</code>。这里创建隐式可选型的就是： 类型 + <code>!</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name: String! = &quot;loveway&quot;</span><br></pre></td></tr></table></figure><p>这里可能有的童鞋会疑惑，已经有了显示的可选型，为什么还需要有隐式的可选型。这里其实隐式的可选型也是有一定作用的。比如你有一个变量，声明为隐式的可选型（!），它的作用就是，当你这个类没有被初始化的时候他是没有值的，但是当你这个类初始化以后，你可以确保他是有值的，所以这里声明为隐式的可选型，而不是显示的。同样需要注意的是隐式的可选型也是可选型，如果你需要用它的值，你也是要进行判断的。如果不进行判断而直接使用，可能会造成不可预料的后果！<br>差不多可选型就到这里了，如果还有什么遗漏，欢迎大家指正！</p><p>转自<a href="http://www.jianshu.com/p/1c26b364e0e6" target="_blank" rel="noopener">重读 Swift 之一：Optional（可选型）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习&lt;code&gt;swift&lt;/code&gt;的过程中不可避免的会遇到&lt;code&gt;？&lt;/code&gt;或&lt;code&gt;！&lt;/code&gt;这种东西，这就是今天要说的可选型（&lt;code&gt;Optional&lt;/code&gt;)了。大家都知道，&lt;code&gt;swift&lt;/code&gt;是苹果官方推出的一款较于&lt;code&gt;Objective-C&lt;/code&gt;安全性较高的语言，而可选型就是&lt;code&gt;swift&lt;/code&gt;最为突出的特性之一。&lt;/p&gt;
    
    </summary>
    
      <category term="swift学习笔记" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
      <category term="Optional" scheme="http://yoursite.com/tags/Optional/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 Swift 中的 map 和 flatMap</title>
    <link href="http://yoursite.com/2017/04/06/swiftMapAndFlatMap/"/>
    <id>http://yoursite.com/2017/04/06/swiftMapAndFlatMap/</id>
    <published>2017-04-06T01:59:45.000Z</published>
    <updated>2018-04-16T07:57:21.587Z</updated>
    
    <content type="html"><![CDATA[<p><code>map</code> 和 <code>flatMap</code> 是 <code>Swift</code> 中两个常用的函数，它们体现了 <code>Swift</code> 中很多的特性。对于简单的使用来说，它们的接口并不复杂，但它们内部的机制还是非常值得研究的，能够帮助我们够好的理解 <code>Swift</code> 语言。</p><a id="more"></a><h1 id="map-简介"><a href="#map-简介" class="headerlink" title="map 简介"></a><strong>map 简介</strong></h1><p>首先，咱们说说 map 函数如何使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [1,2,3,4]</span><br><span class="line">let result = numbers.map &#123; $0 + 2 &#125;</span><br><span class="line">print(result)  // [3,4,5,6]</span><br></pre></td></tr></table></figure><p><code>map</code> 方法接受一个闭包作为参数， 然后它会遍历整个 <code>numbers</code> 数组，并对数组中每一个元素执行闭包中定义的操作。 相当于对数组中的所有元素做了一个映射。 比如咱们这个例子里面的闭包是讲所有元素都加 <code>2</code> 。 这样它产生的结果数据就是 <code>[3,4,5,6]</code>。</p><p>初步了解之后，我们来看一下 <code>map</code> 的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]</span><br></pre></td></tr></table></figure><p>咱们抛开一些和关键逻辑无关的修饰符 <code>@noescape</code>,<code>throws</code> 这些，在整理一下就是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func map&lt;T&gt;(transform: (Self.Generator.Element) -&gt; T) rethrows -&gt; [T]</span><br></pre></td></tr></table></figure><p><code>map</code> 函数接受一个闭包， 这个闭包的定义是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Self.Generator.Element) -&gt; T</span><br></pre></td></tr></table></figure><p>它接受 <code>Self.Generator.Element</code> 类型的参数， 这个类型代表数组中当前元素的类型。 而这个闭包的返回值，是可以和传递进来的值不同的。 比如我们可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let stringResult = numbers.map &#123; &quot;No. \($0)&quot; &#125;</span><br><span class="line">// [&quot;No. 1&quot;, &quot;No. 2&quot;, &quot;No. 3&quot;, &quot;No. 4&quot;]</span><br></pre></td></tr></table></figure><p>这次我们在闭包装把传递进来的数字拼接到一个字符串中， 然后返回一个组数， 这个数组中包含的数据类型，就是我们拼接好的字符串。</p><p>这就是关于 <code>map</code> 的初步了解， 我们继续来看 <code>flatMap</code>。</p><h1 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><strong>flatMap</strong></h1><p><code>map</code> 可以对一个集合类型的所有元素做一个映射操作。 那么 <code>flatMap</code> 呢？</p><p>让我们来看一个 <code>flatMap</code> 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = numbers.flatMap &#123; $0 + 2 &#125;</span><br><span class="line">// [3,4,5,6]</span><br></pre></td></tr></table></figure><p>我们对同样的数组使用 <code>flatMap</code> 进行处理， 得到了同样的结果。 那 <code>flatMap</code> 和 <code>map</code> 到底有什么区别呢？</p><p>咱们再来看另一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let numbersCompound = [[1,2,3],[4,5,6]];</span><br><span class="line">var res = numbersCompound.map &#123; $0.map&#123; $0 + 2 &#125; &#125;</span><br><span class="line">// [[3, 4, 5], [6, 7, 8]]</span><br><span class="line">var flatRes = numbersCompound.flatMap &#123; $0.map&#123; $0 + 2 &#125; &#125;</span><br><span class="line">// [3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><p>这里就看出差别了。 对于二维数组， <code>map</code> 和 <code>flatMap</code> 的结果就不同了。 我们先来看第一个调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var res = numbersCompound.map &#123; $0.map&#123; $0 + 2 &#125; &#125;</span><br><span class="line">// [[3, 4, 5], [6, 7, 8]]</span><br></pre></td></tr></table></figure><p><code>numbersCompound.map { ... }</code> 这个调用实际上是遍历了这里两个数组元素 <code>[1,2,3]</code> 和 <code>[4,5,6]</code>。 因为这两个元素依然是数组，所以我们可以对他们再次调用 <code>map</code> 函数：<code>$0.map{ $0 + 2 }</code>。 这个内部的调用最终将数组中所有的元素加 <code>2</code>。</p><p>再来看看 <code>flatMap</code> 的调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var flatRes = numbersCompound.flatMap &#123; $0.map&#123; $0 + 2 &#125; &#125;</span><br><span class="line">// [3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><p><code>flatMap</code> 依然会遍历数组的元素，并对这些元素执行闭包中定义的操作。 但唯一不同的是，它对最终的结果进行了所谓的 “降维” 操作。 本来原始数组是一个二维的， 但经过 <code>flatMap</code> 之后，它变成一维的了。</p><p><code>flatMap</code> 是如何做到的呢，它的原理是什么，为什么会存在这样一个函数呢？ 相信此时你脑海中肯定会浮现出类似的问题。</p><p>下面咱们再来看一下 <code>flatMap</code> 的定义, 还是抛去 <code>@noescape</code>, <code>rethrows</code> 这些无关逻辑的关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func flatMap&lt;T&gt;(transform: (Self.Generator.Element) throws -&gt; T?) -&gt; [T]</span><br><span class="line">func flatMap&lt;S : SequenceType&gt;(transform: (Self.Generator.Element) -&gt; S) -&gt; [S.Generator.Element]</span><br></pre></td></tr></table></figure><p>和 <code>map</code> 不同， <code>flatMap</code> 有两个重载。 参照我们刚才的示例， 我们调用的其实是第二个重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func flatMap&lt;S : SequenceType&gt;(transform: (Self.Generator.Element) -&gt; S) -&gt; [S.Generator.Element]</span><br></pre></td></tr></table></figure><p><code>flatMap</code> 的闭包接受的是数组的元素，但返回的是一个 <code>SequenceType</code> 类型，也就是另外一个数组。 这从我们刚才这个调用中不难看出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbersCompound.flatMap &#123; $0.map&#123; $0 + 2 &#125; &#125;</span><br></pre></td></tr></table></figure><p>我们传入给 <code>flatMap</code> 一个闭包 <code>$0.map{ $0 + 2 }</code> , 这个闭包中，又对 <code>$0</code> 调用了 <code>map</code> 方法， 从 <code>map</code> 方法的定义中我们能够知道，它返回的还是一个集合类型，也就是 <code>SequenceType</code>。 所以我们这个 <code>flatMap</code> 的调用对应的就是第二个重载形式。</p><p>那么为什么 <code>flatMap</code> 调用后会对数组降维呢？ 我们可以从它的源码中窥探一二（<code>Swift</code> 不是开源了吗~）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extension Sequence &#123;</span><br><span class="line">    </span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">public func flatMap&lt;S : Sequence&gt;(</span><br><span class="line">    @noescape transform: ($&#123;GElement&#125;) throws -&gt; S</span><br><span class="line">  ) rethrows -&gt; [S.$&#123;GElement&#125;] &#123;</span><br><span class="line">    var result: [S.$&#123;GElement&#125;] = []</span><br><span class="line">    for element in self &#123;</span><br><span class="line">      result.append(contentsOf: try transform(element))</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 <code>flatMap</code> 的完整源码了， 它的源码也很简单， 对遍历的每一个元素调用 <code>try transform(element)</code>。 <code>transform</code> 函数就是我们传递进来的闭包。</p><p>然后将闭包的返回值通过 <code>result.append(contentsOf:)</code> 函数添加到 <code>result</code> 数组中。</p><p>那我们再来看一下 <code>result.append(contentsOf:)</code> 都做了什么， 它的文档定义是这样：</p><blockquote><p>Append the elements of newElements to self.</p></blockquote><p>简单说就是将一个集合中的所有元素，添加到另一个集合。 还以我们刚才这个二维数组为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbersCompound = [[1,2,3],[4,5,6]];</span><br><span class="line">var flatRes = numbersCompound.flatMap &#123; $0.map&#123; $0 + 2 &#125; &#125;</span><br><span class="line">// [3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><p><code>flatMap</code> 首先会遍历这个数组的两个元素 <code>[1,2,3]</code> 和 <code>[4,5,6]</code>， 因为这两个元素依然是数组， 所以我们可以对他们再进行 <code>map</code> 操作： <code>$0.map{ $0 + 2 }</code>。</p><p>这样， 内部的 <code>$0.map{ $0 + 2 }</code> 调用返回值类型还是数组， 它会返回 <code>[3,4,5]</code> 和 <code>[6,7,8]</code>。</p><p>然后， <code>flatMap</code> 接收到内部闭包的这两个返回结果， 进而调用 <code>result.append(contentsOf:)</code> 将它们的数组中的内容添加到结果集中，而不是数组本身。</p><p>那么我们最终的调用结果理所当然就应该是 <code>[3, 4, 5, 6, 7, 8]</code> 了。</p><p>仔细想想是不是这样呢~</p><h1 id="flatMap-的另一个重载"><a href="#flatMap-的另一个重载" class="headerlink" title="flatMap 的另一个重载"></a><strong>flatMap 的另一个重载</strong></h1><p>我们刚才分析了半天， 其实只分析到 <code>flatMap</code> 的一种重载情况， 那么另外一种重载又是怎么回事呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func flatMap&lt;T&gt;(transform: (Self.Generator.Element) -&gt; T?) -&gt; [T]</span><br></pre></td></tr></table></figure><p>从定义中我们看出， 它的闭包接收的是 <code>Self.Generator.Element</code> 类型， 返回的是一个 <code>T?</code> 。 我们都知道，在 <code>Swift</code> 中类型后面跟随一个 <code>?</code>， 代表的是 <code>Optional</code> 值。 也就是说这个重载中接收的闭包返回的是一个 <code>Optional</code> 值。 更进一步来说，就是闭包可以返回 <code>nil</code>。</p><p>我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let optionalArray: [String?] = [&quot;AA&quot;, nil, &quot;BB&quot;, &quot;CC&quot;];</span><br><span class="line">var optionalResult = optionalArray.flatMap&#123; $0 &#125;</span><br><span class="line">// [&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;]</span><br></pre></td></tr></table></figure><p>这样竟然没有报错， 并且 <code>flatMap</code> 的返回结果中， 成功的将原数组中的 <code>nil</code> 值过滤掉了。 再仔细观察，你会发现更多。 使用 <code>flatMap</code> 调用之后， 数组中的所有元素都被解包了， 如果同样使用 <code>print</code> 函数输出原始数组的话， 大概会得到这样的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Optional(&quot;AA&quot;), nil, Optional(&quot;BB&quot;), Optional(&quot;CC&quot;)]</span><br></pre></td></tr></table></figure><p>而使用 <code>print</code> 函数输出 <code>flatMap</code> 的结果集时，会得到这样的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;]</span><br></pre></td></tr></table></figure><p>也就是说原始数组的类型是 <code>[String?]</code> 而 <code>flatMap</code> 调用后变成了 <code>[String]</code>。 这也是 <code>flatMap</code> 和 <code>map</code> 的一个重大区别。 如果同样的数组，我们使用 <code>map</code> 来调用， 得到的是这样的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Optional(&quot;AA&quot;), nil, Optional(&quot;BB&quot;), Optional(&quot;CC&quot;)]</span><br></pre></td></tr></table></figure><p>这就和原始数组一样了。 这两者的区别就是这样。 map 函数值对元素进行变换操作。 但不会对数组的结构造成影响。 而 flatMap 会影响数组的结构。再进一步分析之前，我们暂且这样理解。</p><p><code>flatMap</code> 的这种机制，而已帮助我们方便的对数据进行验证，比如我们有一组图片文件名， 我们可以使用 <code>flatMap</code> 将无效的图片过滤掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var imageNames = [&quot;test.png&quot;, &quot;aa.png&quot;, &quot;icon.png&quot;];</span><br><span class="line">imageNames.flatMap&#123; UIImage(named: $0) &#125;</span><br></pre></td></tr></table></figure><p>那么 <code>flatMap</code> 是如何实现过滤掉 <code>nil</code> 值的呢？ 我们还是来看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extension Sequence &#123;</span><br><span class="line">  </span><br><span class="line">  // ... </span><br><span class="line">  public func flatMap&lt;T&gt;(</span><br><span class="line">    @noescape transform: ($&#123;GElement&#125;) throws -&gt; T?</span><br><span class="line">  ) rethrows -&gt; [T] &#123;</span><br><span class="line">    var result: [T] = []</span><br><span class="line">    for element in self &#123;</span><br><span class="line">      if let newElement = try transform(element) &#123;</span><br><span class="line">        result.append(newElement)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // ... </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然是遍历所有元素，并应用 <code>try transform(element)</code> 闭包的调用， 但关键一点是，这里面用到了 <code>if let</code> 语句， 对那些只有解包成功的元素，才会添加到结果集中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let newElement = try transform(element) &#123;</span><br><span class="line">    result.append(newElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样， 就实现了我们刚才看到的自动去掉 <code>nil</code> 值的效果了。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a><strong>结尾</strong></h1><p>关于 <code>Swift</code> 中的 <code>map</code> 和 <code>flatMap</code>， 看完这篇内容是不会会对你有所启发呢。 当然， 关于这两个函数我们这里并没有完全讨论完。 它们背后还有着更多的思想。 关于本篇文章的代码，大家还可以来 <code>Github</code> 上面 <a href="https://github.com/swiftcafex/mapAndFlatmap" target="_blank" rel="noopener">参看.</a></p><p>转自：<a href="https://www.swiftcafe.io/2016/03/28/about-map/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.swiftcafe.io/2016/03/28/about-map/?utm_source=tuicool&amp;utm_medium=referral</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;flatMap&lt;/code&gt; 是 &lt;code&gt;Swift&lt;/code&gt; 中两个常用的函数，它们体现了 &lt;code&gt;Swift&lt;/code&gt; 中很多的特性。对于简单的使用来说，它们的接口并不复杂，但它们内部的机制还是非常值得研究的，能够帮助我们够好的理解 &lt;code&gt;Swift&lt;/code&gt; 语言。&lt;/p&gt;
    
    </summary>
    
      <category term="swift学习笔记" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="map" scheme="http://yoursite.com/tags/map/"/>
    
      <category term="flatMap" scheme="http://yoursite.com/tags/flatMap/"/>
    
  </entry>
  
  <entry>
    <title>雨夜</title>
    <link href="http://yoursite.com/2017/03/31/rainNight/"/>
    <id>http://yoursite.com/2017/03/31/rainNight/</id>
    <published>2017-03-31T01:02:16.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个夜，一个下雨的夜。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/2074437-6b28f7f3cf6cb6db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="雨夜"></p><p>我喜欢此时此刻的气氛，一个人窝在被窝里，窗外淅淅沥沥的雨滴敲打着窗户上的玻璃，正应了那句话“大珠小珠落玉盘”。房间里很安静，安静的只能听到自己的呼吸声，窗外时不时的传来一声汽车呼啸而过的声音。这种环境，这种氛围，让我觉得很舒服，恰到好处。</p><p>一个人在这种环境下，思想会变得格外的清晰和明朗，会想明白很多一直想不明白的问题。于我自己而言，喜欢黑夜甚于白天。尤其是这样的一个静谧的夜。</p><p><img src="http://upload-images.jianshu.io/upload_images/2074437-245d5be38b96141c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="静谧的夜"></p><p>上海的生活节奏快的可怕，初来乍到之时，手忙脚乱，慌不择路。慢慢的习惯了这种生活，喜欢在一片喧嚣之中觅得一方清幽之所，独处，享受。</p><p>一个人生活，有好处，也有坏处。好处就是可以经常反思自己，可以依靠自己来约束自己。坏处就是缺少与人交流，没有交流，进步就会异常缓慢。就现在来说，我还挺满意自己如今的生活状态，虽说朝九晚五，但也是异常充实，知道每天需要做些什么来填补自己。年龄在一天天的增长，我要做的就是让经历，经验，学识都要与之增长。</p><p>本来说好了，这不是一篇鸡汤文，但写着写着，总想写一些话来安慰或鼓励自己一下。学而不思则罔，思而不学则殆。快节奏的生活中，会思考显得弥足珍贵。我们不要只顾风雨兼程，还要时不时的停下来，审视自己。以人为镜，正己。</p><p>夜，是思绪放飞的时刻。会想到一些人，会想到一些事。想昨天，想明天。想一切能想到的。思想的触角漫无边际，任其四通八达，通向未来。</p><p>窗外的雨还在淅淅沥沥的下着，夜已深。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个夜，一个下雨的夜。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>极光推送开发环境可以收到,生产环境收不到推送</title>
    <link href="http://yoursite.com/2017/03/30/jpush/"/>
    <id>http://yoursite.com/2017/03/30/jpush/</id>
    <published>2017-03-29T16:00:00.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先阐述一下我遇到的问题：</p><p>我们项目连通了极光推送，以前写过的项目也是这样，在开发环境下测试，好使了，但是打包ADHoc时候，就不好使了，<a id="more"></a>当时也没在意，因为网上好多人说，只要测试好使了，证书显示配置成功了（绿灯），那就没问题了。</p><p>　　so，上线，然后上线以后，发现推送功能完全不好使！这就尴尬了，赶紧下架。</p><p>　　因为我们项目使用的是别名推送，使用极光网站推送时候，我使用了广播，别名推送，regID推送，结果 都能收到（开发环境）；然后我在生产环境－－－－－＞再次发送－－－－－＞广播，别名，regID，结果，很显然，别名收不到，这就纠结了，开始查看问题吧。</p><p>　　经过两天的爬坑，终于找到了问题所在，也正在积极解决。在这里再次感谢极光官方两位大牛，如果没有你们的帮忙，我想我还会纠结好久。    <a href="https://community.jiguang.cn/users/Lris/activity" target="_blank" rel="noopener">Lris12</a>            <a href="https://community.jiguang.cn/users/helperhaps/activity" target="_blank" rel="noopener">Helperhaps</a> </p><p>　　好了，废话少说，阐述问题跟代码</p><hr><p>　　初次发现这个问题的时候，首先排查的就是证书配置，这里再次建议大家好好仔细的看看开发文档，因为很多错误都是细节处不注意造成的，<a href="https://docs.jiguang.cn/jpush/client/iOS/ios_sdk/" target="_blank" rel="noopener">附上开发文档地址</a>。因为这个项目是接手别人已经做得差不多的，我就负责收尾，所以，证书这方面我会优先查看，是否错误。</p><p>　　在developer.apple.com 中，我已经看到</p><p><img src="http://upload-images.jianshu.io/upload_images/3902605-0a2777d161ddf364.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="developer.apple.com"></p><p>　　很明显，开发环境的证书跟生产环境的证书，都已经配置完成，那么证书是没有问题的，下面我们看看极光官网的配置：</p><p><img src="http://upload-images.jianshu.io/upload_images/3902605-11a65f1d008826fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="极光官网的配置"></p><p>　　也是已验证，这就奇怪了，到这，我表示，可能是代码出错了，好吧，我们来看代码。</p><p><img src="http://upload-images.jianshu.io/upload_images/3902605-8d52a21aec08c89d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码"></p><p>　　别名设置，相信在官方文档中大家都明白怎么写。反复查看文档，我发现并没有任何问题这么写。经过跟  Lris12 大神的交流，觉得很可能是因为网络原因，在注册极光还没有返回成功的时候，就绑定别名，导致regID跟别名没有绑定成功。</p><p>　　解决方法：</p><p>　　添加5个监听，在监听到extern NSString * const kJPFNetworkDidLoginNotification; // 登录成功，之后再设置别名。</p><p>　　<a href="https://docs.jiguang.cn/jpush/client/iOS/ios_guide_new/#jpush-sdk1" target="_blank" rel="noopener">极光集成指南</a></p><p><img src="http://upload-images.jianshu.io/upload_images/3902605-9f2192a8e364ecc9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码"></p><p><strong>Ps：这里强烈建议这么写，安全第一 安全第一！！！</strong></p><p>　　这里附上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">NSNotificationCenter *defaultCenter = [NSNotificationCenter defaultCenter];</span><br><span class="line"></span><br><span class="line">[defaultCenter addObserver:self selector:@selector(networkDidReceiveMessage:) name:kJPFNetworkDidLoginNotification object:nil];</span><br><span class="line"></span><br><span class="line">[JPUSHService registerDeviceToken:deviceToken];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//通知方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)networkDidReceiveMessage:(NSNotification *)notification &#123;</span><br><span class="line"></span><br><span class="line">[JPUSHService setTags:nil aliasInbackground:[OpenUDID value]];</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">[JPUSHService setTags:nil alias:[OpenUDID value] fetchCompletionHandle:^(int iResCode, NSSet *iTags, NSString *iAlias)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>//销毁通知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] removeObserver:self name:kJPFNetworkDidLoginNotification object:nil];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　然而，问题依旧没有解决，但是这个时候，我们登录极光官网推送。我在生产环境，再次发送，广播，别名，regID，结果，都收到了！！正当我高兴的时候，发现 api推送依旧收不到！！收不到！！绝望！！</p><p>　　继续排查！！！按照开发文档，设置xcode配置，嗯 ，依旧没用。</p><p>　　这里我重点说一下 ：iOS9 之后 卸载重装后会改变token，所以registrationID会改变，如果你没有用到idfa。如果你的项目使用的是regID推送，那么你要注意，每次更新app，新用户下载app，重新下载app等一系列状况下，regID改变的问题。还有如果注册成功后，会返回，设置成功，有callback为0。这个也要注意下。</p><p>　　好，回归正题。这时候时间已经过去一天半了， 最后我觉得，我所有的代码，配置，证书，环境，都没有问题！再去极光官网看看，到底咋回事。</p><p>　　好吗 这一看 终于发现了问题所在！</p><p><img src="http://upload-images.jianshu.io/upload_images/3902605-313a8945d475fa99.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="极光官网"></p><p><img src="http://upload-images.jianshu.io/upload_images/3902605-1f8d59529c776d8d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="极光官网"></p><p>　　大家看没看到，这里写的是推送平台iOS-dev？卧槽！！后台给我推送的居然是开发环境！！果断找后台理论！！！</p><p>　　Lris大神告诉我：「发布版本后无法有效推送」 or 「生产环境下收不到消息」 按以下步骤排查问题： 客户端－－－－＞客户端是否打包证书－－－－＞检查当前环境是否正确－－－－－＞设备里面的手机应用有没有添加/配置这个tag/ 别名－－－＞服务端注意改变环境参数，option的apns_production的值（true：生产）（false开发）。根据客户端环境改变服务端推送环境。环境要一致才能收到推送。</p><p>　　然后我们后台给我发送了一段代码 堵住了我的嘴：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$platform = &apos;android,ios&apos; ;</span><br><span class="line"></span><br><span class="line">$msg_content = json_encode(array(&apos;n_builder_id&apos;=&gt;0, &apos;n_title&apos;=&gt;$n_title, &apos;n_content&apos;=&gt;$n_content,&apos;content-available&apos;=&gt;1,&apos;apns_production&apos;=&gt;1));</span><br><span class="line"></span><br><span class="line">$obj = new jpush($masterSecret,$appkeys);</span><br></pre></td></tr></table></figure><p>　　我标红的位置，人家已经设置了1，为什么还不好用？经过Helperhaps大神的解释，好吧，我懂了！我们后台使用的过期的V2 api。</p><p>　　特别提示：建议不要在客户端里写代码直接调用此 API。因为 Android apk 比较容易破解，别人很容易从客户端代码里找出来调用 JPush Remote API 所需要的保密信息，从而可以模拟到你的身份来发起恶意的推送。</p><p>　　建议的使用方式是：调用 JPush Remote API 的代码放在你自己的应用服务器上。你自己的应用服务器对自己的客户端提供接口来推送消息。具体请参考推聊的作法：示例与代码。</p><p>　　升级到 v3 Push API：建议开发者升级到 v3 版本。此版本会继续支持到 2015 年。至此，这个问题才算是解决（至少对前端来说）。第一次发这样的帖子感觉有点乱 嗯。。。</p><p>　　下次大家在推送上有问题的话。。先看开发文档走一遍流程，然后看看极光个人推送，广播能否收到，然后就可以考虑跟服务端干一仗了！！</p><p>　　最后祝大家 永无BUG！！！！！！！！！！！！！</p><p>　　转自：<a href="http://www.jianshu.com/p/0d382c4d98ff" target="_blank" rel="noopener">http://www.jianshu.com/p/0d382c4d98ff</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先阐述一下我遇到的问题：&lt;/p&gt;
&lt;p&gt;我们项目连通了极光推送，以前写过的项目也是这样，在开发环境下测试，好使了，但是打包ADHoc时候，就不好使了，
    
    </summary>
    
      <category term="iOS 推送" scheme="http://yoursite.com/categories/iOS-%E6%8E%A8%E9%80%81/"/>
    
    
      <category term="jpush" scheme="http://yoursite.com/tags/jpush/"/>
    
  </entry>
  
  <entry>
    <title>React-Native 奇葩报错</title>
    <link href="http://yoursite.com/2017/03/22/rnPortCrash/"/>
    <id>http://yoursite.com/2017/03/22/rnPortCrash/</id>
    <published>2017-03-22T07:47:20.000Z</published>
    <updated>2017-06-07T13:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚写了一个react-native小demo，完美运行，心中窃喜，于是关闭项目。过了一会儿，想再一睹刚才如行云流水般运行的项目，于是，运行，结果……纳尼？出现了一片姨妈红有没有？心中一万头草泥马呼啸而过有没有？到底发生了什么？<br><a id="more"></a></p><p>NA！阿sir啊，我说了我没动过代码啦，出现下面这种错误不关我的事啊：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProjectName has not been registered. </span><br><span class="line">This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.</span><br></pre></td></tr></table></figure></p><p>分析错误原因：</p><h2 id="1-第一种情况："><a href="#1-第一种情况：" class="headerlink" title="1.第一种情况："></a><strong>1.第一种情况：</strong></h2><p>程序入口处项目名称不一致。检查发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppRegistry.registerComponent(&apos;ProjectName&apos;, () =&gt; ProjectName);</span><br></pre></td></tr></table></figure><p>一模一样！为了担心怕自己的眼睛看到的不是真实的，特地粘贴复制了一遍！</p><p>第一种情况排除！</p><h2 id="2-第二种情况"><a href="#2-第二种情况" class="headerlink" title="2.第二种情况"></a><strong>2.第二种情况</strong></h2><p><strong>8081端口被占用</strong></p><p><code>检验方法：到项目根目录下---------&gt;&gt;&gt;打开终端---------&gt;&gt;&gt;输入命令行：react-native start</code></p><p>如果出现了<code>Packager can&#39;t listen on port 8081</code>,好的恭喜你，找到了症结所在，下面就是根据提示来就好了：</p><p><1>.lsof -i : 8081 //列出被占用的端口</1></p><p><2>.kill -9 &lt; PID &gt;  //找出与之对应的PID，杀死就ok了</2></p><p><3>.重新运行项目</3></p><p><4>.依旧完美</4></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚写了一个react-native小demo，完美运行，心中窃喜，于是关闭项目。过了一会儿，想再一睹刚才如行云流水般运行的项目，于是，运行，结果……纳尼？出现了一片姨妈红有没有？心中一万头草泥马呼啸而过有没有？到底发生了什么？&lt;br&gt;
    
    </summary>
    
      <category term="react-native学习笔记" scheme="http://yoursite.com/categories/react-native%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="8081port" scheme="http://yoursite.com/tags/8081port/"/>
    
  </entry>
  
</feed>
