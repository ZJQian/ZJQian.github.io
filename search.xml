<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python 之词云]]></title>
    <url>%2F2018%2F11%2F06%2Fpython-%E4%B9%8B%E8%AF%8D%E4%BA%91%2F</url>
    <content type="text"><![CDATA[1.爬取词源网页在这我是爬取的自己博客的一些标签 1234567891011121314#获取htmldef getHtml(): url = 'https://zjqian.github.io/tags/index.html' res = requests.get(url) return res.text #通过BeautifulSoup解析网页，得到标签def getContent(): soup = BeautifulSoup(getHtml(),'lxml') text = '' for item in soup.find('div', class_='tag-cloud-tags'): text += item.string return text 2.生成词云12345678910111213141516171819202122232425262728293031def getWordCloud(): d = path.dirname(__file__) #词云所依照的图片格式 coloring = np.array(Image.open(path.join(d, "WordArt.png"))) #设置WordCloud属性 wc = WordCloud(background_color="white", max_words=2000, mask=coloring, max_font_size=50, random_state=42, font_path='fangsong_GB2312.ttf') wc.generate(getContent()) # 设置词的颜色 color_to_words = &#123; # 使用RGB来设置词的颜色 &#125; # 设置词默认的颜色 default_color = "black" grouped_color_func = GroupedColorFunc(color_to_words, default_color) # 设置词云的颜色 wc.recolor(color_func=grouped_color_func) # create coloring from image # image_colors = ImageColorGenerator(coloring) wc.to_file("路径/word-cloud.png") # 保存图片 plt.figure() plt.imshow(wc, interpolation="bilinear") plt.axis("off") plt.show() 3.词云效果图: 对比一下,第二张是源图片]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>pythton</tag>
        <tag>词云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native之run-android报错SDK location not found]]></title>
    <url>%2F2018%2F11%2F01%2Freact-native%E4%B9%8Brun-android%E6%8A%A5%E9%94%99-SDK-location-not-found%2F</url>
    <content type="text"><![CDATA[react-native 项目运行 Android 时报错,错误信息如下: 解决办法 1.cd到项目文件夹 android目录下2.创建local.properties 文件(命令行创建方法: touch local.properties)3.编辑local.properties文件,添加 sdk.dir = /Users/用户名/Library/Android/sdk(等号右侧为sdk 的路径)4.完成!]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
      <tags>
        <tag>run-android</tag>
        <tag>SDK location not found</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native之原生跳转RN]]></title>
    <url>%2F2018%2F10%2F30%2Freact-native%E4%B9%8B%E5%8E%9F%E7%94%9F%E8%B7%B3%E8%BD%ACRN%2F</url>
    <content type="text"><![CDATA[上一篇文章记录了一下RN跳转原生的一些操作, 这次记录一下原生跳转 RN 页面的一些具体操作. 1.创建 rn 页面并注册创建页面 1234567891011121314151617import React, &#123;Component&#125; from 'react';import &#123; View, Text&#125; from 'react-native';export default class Test extends Component&#123; render() &#123; return( &lt;View style=&#123;&#123;flex: 1,backgroundColor: 'red'&#125;&#125;&gt; &lt;Text style=&#123;&#123;marginTop: 100&#125;&#125;&gt; 这是 RN 页面&lt;/Text&gt; &lt;/View&gt; ) &#125;&#125; 在入口函数中注册组件 12AppRegistry.registerComponent('test',()=&gt;test); 2.在原生文件中加载具体方案 1234• 建立一个NSObject类，让其实现RCTBridgeDelegate协议• 这个类添加一个bridge属性作为一个全局的bridge，每一次新建RN页面使用这个bridge• 类中实现预加载方法，在适当的时候可以预加载RCTRootView• 类中实现RCTRootView的管理，将预加载的RCTRootView保存起来，在用到的时候直接提取 新建一个继承自NSObject的类ReactRootViewManager: 123456789101112131415161718192021222324252627282930313233343536373839404142//.h文件#import &lt;Foundation/Foundation.h&gt;#import &lt;React/RCTRootView.h&gt;#import &lt;React/RCTBundleURLProvider.h&gt;#import &lt;React/RCTBridge.h&gt;NS_ASSUME_NONNULL_BEGIN@interface ReactRootViewManager : NSObject&lt;RCTBridgeDelegate&gt;/* 全局唯一的bridge */@property (nonatomic, strong, readonly) RCTBridge * bridge;/** 获取单例*/+ (instancetype)manager;/* * 根据viewName预加载bundle文件 * param: * viewName RN界面名称 * initialProperty: 初始化参数 */- (void)preLoadRootViewWithName:(NSString *)viewName;- (void)preLoadRootViewWithName:(NSString *)viewName initialProperty:(NSDictionary *)initialProperty;/* * 根据viewName获取rootView * param: * viewName RN界面名称 * * return: 返回匹配的rootView */- (RCTRootView *)rootViewWithName:(NSString *)viewName;@endNS_ASSUME_NONNULL_END 具体实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#import "ReactRootViewManager.h"@interface ReactRootViewManager ()// 以 viewName-rootView 的形式保存需预加载的RN界面@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, RCTRootView*&gt; * rootViewMap;@end@implementation ReactRootViewManager- (void)dealloc &#123; _rootViewMap = nil; [_bridge invalidate];&#125;+ (instancetype)manager &#123; static ReactRootViewManager * _rootViewManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _rootViewManager = [[ReactRootViewManager alloc] init]; &#125;); return _rootViewManager;&#125;- (instancetype)init &#123; if (self = [super init]) &#123; _rootViewMap = [NSMutableDictionary dictionaryWithCapacity:0]; _bridge = [[RCTBridge alloc] initWithDelegate:self launchOptions:nil]; &#125; return self;&#125;- (void)preLoadRootViewWithName:(NSString *)viewName &#123; [self preLoadRootViewWithName:viewName initialProperty:nil];&#125;- (void)preLoadRootViewWithName:(NSString *)viewName initialProperty:(NSDictionary *)initialProperty &#123; if (!viewName &amp;&amp; [_rootViewMap objectForKey:viewName]) &#123; return; &#125; // 由bridge创建rootView RCTRootView * rnView = [[RCTRootView alloc] initWithBridge:self.bridge moduleName:viewName initialProperties:initialProperty]; [_rootViewMap setObject:rnView forKey:viewName];&#125;- (RCTRootView *)rootViewWithName:(NSString *)viewName &#123; if (!viewName) &#123; return nil; &#125; return [self.rootViewMap objectForKey:viewName];&#125;#pragma mark - RCTBridgeDelegate- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge &#123; return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index" fallbackResource:nil];&#125;@end 3.创建一个 controller 加载 RN 页面1234567//test为注册组件时定义的名称- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. self.view=[[ReactRootViewManager manager] rootViewWithName:@"test"];&#125; 4.跳转操作预加载 RN 页面 在原生的 controller 里预加载 RN 页面 1234//RN页面预加载 NSString *pageName = @"test"; [[ReactRootViewManager manager] preLoadRootViewWithName:pageName initialProperty:nil]; 进行跳转 在按钮的 click 事件里进行跳转: 1234567- (void)jumpToRN &#123; RNRootViewController *vc = [[RNRootViewController alloc] init]; [self.navigationController pushViewController:vc animated:YES]; &#125; 效果:]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
      <tags>
        <tag>原生跳转RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native之RN跳转原生界面]]></title>
    <url>%2F2018%2F10%2F29%2Freact-native%E4%B9%8BRN%E8%B7%B3%E8%BD%AC%E5%8E%9F%E7%94%9F%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[混合开发中不可避免的会遇到原生页面与非原生页面之间的跳转, 这篇文章记录一下 RN 页面跳转原生页面的一些具体操作. 1.配置原生文件在 AppDelegate.h 文件中声明一个属性 nav: 12@property (nonatomic, strong) UINavigationController * nav; 在 AppDelegate.m 文件中配置导航栏: 1234567self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];UIViewController *rootViewController = [UIViewController new];rootViewController.view = rootView;_nav = [[UINavigationController alloc] initWithRootViewController:rootViewController];self.window.rootViewController = _nav;[self.window makeKeyAndVisible]; 2.创建文件实现RCTBridgeModule协议创建一个继承 NSObject 的类: 12345678910111213//.h文件#import &lt;Foundation/Foundation.h&gt;#import &lt;React/RCTBridgeModule.h&gt;NS_ASSUME_NONNULL_BEGIN@interface RNToNative : NSObject&lt;RCTBridgeModule&gt;@endNS_ASSUME_NONNULL_END 12345678910111213141516171819202122232425262728293031323334//.m文件#import "RNToNative.h"#import &lt;React/RCTBridge.h&gt;#import "NativeViewController.h"#import "AppDelegate.h"@implementation RNToNativeRCT_EXPORT_MODULE(RNToNative);//无参RCT_EXPORT_METHOD(jumpToNative) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NativeViewController *vc = [[NativeViewController alloc] init]; AppDelegate *app = (AppDelegate *)UIApplication.sharedApplication.delegate; [app.nav pushViewController:vc animated:YES]; &#125;);&#125;//有参RCT_EXPORT_METHOD(jump2Native:(NSString *)para) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NativeViewController *vc = [[NativeViewController alloc] init]; vc.para = para; AppDelegate *app = (AppDelegate *)UIApplication.sharedApplication.delegate; [app.nav pushViewController:vc animated:YES]; &#125;);&#125;@end 3.在 RN 文件中配置直接贴源码好了: 1234567891011121314151617181920212223242526272829303132//RNToNative为在原生文件中定义的类名称.jumpToNative()&#123; var jump = NativeModules.RNToNative; InteractionManager.runAfterInteractions(() =&gt; &#123; //jumpToNative为在原生文件中定义的函数名称, 此为无参的函数 jump.jumpToNative(); &#125;)&#125;;jumpToNativeWithPara() &#123; var jump = NativeModules.RNToNative; InteractionManager.runAfterInteractions(() =&gt; &#123; //jump2Native为在原生文件中定义的函数名称, 此为带参的函数 jump.jump2Native("hello"); &#125;)&#125;render() &#123; return ( &lt;View style=&#123;&#123;flex: 1,justifyContent: 'space-around'&#125;&#125;&gt; &lt;TouchableOpacity activeOpacity=&#123;0.5&#125; onPress=&#123;this.jumpToNative&#125; style=&#123;styles.btn&#125;&gt; &lt;Text&gt;跳转原生(无参数)&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity activeOpacity=&#123;0.5&#125; onPress=&#123;this.jumpToNativeWithPara&#125; style=&#123;styles.btn&#125;&gt; &lt;Text&gt;跳转原生(带参数)&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; )&#125; 效果如下:]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
      <tags>
        <tag>RN跳转原生界面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行命令统计iOS工程代码总行数]]></title>
    <url>%2F2018%2F10%2F27%2F%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%BB%9F%E8%AE%A1iOS%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%80%BB%E8%A1%8C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我们有时候想要统计一下我们的工程的总代码行数，来获取一些成就感或者作为别的用图，这里就介绍一些如何便捷地统计代码的行数，非常简单，方法如下： 打开终端； 通过cd命令到达我们的工程文件，这里注意如果要避免统计引用的第三方库的代码量，我们就要进一步进到我们自己写的代码文件中去，一般是一个与工程文件同名的文件； 统计代码行数： 如果想列出每个文件的行数，输入命令： 1find . -name "*.m" -or -name "*.h" -or -name "*.xib" -or -name "*.c" |xargs wc -l 如果想直接列出总代码行数，输入命令： 1find . -name "*.m" -or -name "*.h" -or -name "*.xib" -or -name "*.c" |xargs grep -v "^$"|wc -l 这样就可以直接得出数量了，而且非常快，是不是很方便\~ 这个统计过程会去掉空行，但注释是会计算在内的。]]></content>
      <categories>
        <category>实用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MAC 终端上传代码到Github 或者 Gitlab]]></title>
    <url>%2F2018%2F10%2F27%2FMAC%20%E7%BB%88%E7%AB%AF%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0Github%20%E6%88%96%E8%80%85%20Gitlab%2F</url>
    <content type="text"><![CDATA[1.创建远程仓库。 Project name：项目名称 Project description (optional)：项目介绍 Visibility Level ：项目的访问权限 2.创建完成后操作,终端cd 到你需要克隆到的文件夹目录下： 12345 a. cd &lt;你本地文件夹目录&gt; b.git clone &lt;你自己刚创建的远程仓库目录&gt; c.把代码导入你clone 下来的目录下 3.提交代码 123a. git add * b.git commit -m"&lt;注释&gt;" c.git push origin master是简单的代码上传过程。 注：你自己也可以在终端创建远程仓库 4.打开git命令窗口:123456789git clone 远程代码仓库的地址cd （git clone的文件夹路径）git pull origin master//更新 必须做的操作// git remote add origin 你刚才建立的项目连接git add .git commit -m '注释'git push -u origin master 将代码推送到gitlab端 5,创建并切换分支本地分支并推送到远程服务器；12345678910111213git branch : 查看我们的git仓库有几个分支，而我们目前工作处于那个分支，前面有个*号的就为我们目前所处的分支。git branch -a : 查看远程分支。git branch name : 创建分支，而这个分支的指针就指向最新的commit对象，也就和HEAD指向同一对象。如git branch test，表示创建本地test分支。git checkout name : 切换到目的分支，我们默认的主分支为master。git checkout –b name：创建并切换分支。git push origin name： 将本地name分支推送到远程服务器。git status : 查看文件更改状态。在添加文件之前或之后，我们会用git status 查看有变化的文件（一般有变化的文件会以红色显示出来）。//设置显示隐藏文件夹defaults write com.apple.finder AppleShowAllFiles YES 6，遇到的问题，即解决办法：123! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to 'git@github.com:******/Demo.git'hint: Updates were rejected because the tip of your current branch is behind . 使用强制push的方法： 1$ git push -u origin master -f 这样会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候。 . push前先将远程repository修改pull下来 $ git pull origin master $ git push -u origin master . 若不想merge远程和本地修改，可以先创建新的分支： 1$ git branch [name] 然后push 1$ git push -u origin [name] 方法一很暴力，但很实用，可以轻易本地文件同步到远程服务器端。多人协作使用，慎用！ 7.tag 的简单使用 git push –tags 把本地的tag推送到远程 git fetch origin tag 获取远程tag]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native 之常用组件]]></title>
    <url>%2F2018%2F10%2F27%2FReact%20Native%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本文收录了,React Native中常用的一些相关组件, 摘录的过程中,可能有所差错,不足之处还望指出. 希望大家可以互相学习,互帮互助! 第一部分基于react-navigation组件的自定义 head 视图 react-native-carousel 轮播图 react-native-countdown 倒计时 react-native-device-info 设备信息 react-native-fileupload 文件上传 react-native-icons 图标 react-native-image-picker 图片选择器 react-native-keychain iOSKeyChain管理 react-native-picker 滚轮选择器 react-native-picker-Android 安卓滚轮选择器 react-native-refreshable-listview 可刷新列表 react-native-scrollable-tab-view 可滚动标签 react-native-side-menu 侧边栏 react-native-swiper 轮播 react-native-video 视频播放 react-native-viewpager 分页浏览 react-native-scrollable-tab-view 可滑动的底部或上部导航栏框架 react-native-tab-navigator 底部或上部导航框架(不可滑动) react-native-check-box CheckBox react-native-splash-screen 启动白屏问题 react-native-simple-router 简易路由跳转框架 react-native-storage 持久化存储 react-native-sortable-listview 分类ListView react-native-htmlview 将 HTML 目录作为本地视图的控件，其风格可以定制 react-native-easy-toast 一款简单易用的 Toast 组件 第二部分选项卡 https://github.com/exponentjs/react-native-tab-navigator material组件库 https://github.com/xinthink/react-native-material-kit base组件库 http://nativebase.io/docs/v0.4.6/components#anatomy https://github.com/GeekyAnts/NativeBase 按钮 https://github.com/mastermoo/react-native-action-button https://github.com/ide/react-native-button 表单验证 https://github.com/gcanti/tcomb-form-native https://github.com/FaridSafi/react-native-gifted-form https://github.com/bartonhammond/snowflake 带动画效果的TextInput https://github.com/halilb/react-native-textinput-effects https://github.com/zbtang/React-Native-TextInputLayout 聊天 https://github.com/FaridSafi/react-native-gifted-chat 蓝牙通信 http://blog.csdn.net/withings/article/details/71378562 谷歌地图 https://github.com/lelandrichardson/react-native-maps 高德地图 https://github.com/Eleme-IMF/dodo 时间轴,快递流程图效果 https://github.com/24ark/react-native-step-indicator https://github.com/thegamenicorus/react-native-timeline-listview 动画效果 https://github.com/oblador/react-native-animatable 加载Loading动画 https://github.com/maxs15/react-native-spinkit 抽屉效果 https://github.com/root-two/react-native-drawer https://github.com/react-native-fellowship/react-native-side-menu 侧滑按钮 https://github.com/dancormier/react-native-swipeout https://github.com/jemise111/react-native-swipe-list-view 图表/制图 https://github.com/tomauty/react-native-chart 股票金融 https://github.com/7kfpun/FinanceReactNative 时间组件 https://github.com/xgfe/react-native-datepicker 日历组件 https://github.com/wix/react-native-calendars 电子签名 https://github.com/jgrancher/react-native-sketch 下拉放大(回弹效果) https://github.com/lelandrichardson/react-native-parallax-view 日历组件 https://github.com/cqm1994617/react-native-myCalendar https://github.com/vczero/react-native-calendar 多语言 https://github.com/joshswan/react-native-globalize 单选/多选组件 https://github.com/hinet/react-native-checkboxlist 二维码 https://github.com/ideacreation/react-native-barcodescanner 制作本地库 https://github.com/frostney/react-native-create-library 影音相关 https://github.com/MisterAlex95/react-native-record-sound 提示消息(横条Bar) https://github.com/KBLNY/react-native-message-bar iOS原生TableView https://github.com/aksonov/react-native-tableview 点击弹出视图 https://github.com/jeanregisser/react-native-popover https://github.com/instea/react-native-popup-menu 3D Touch https://github.com/madriska/react-native-quick-actions 双平台兼容的ActionSheet https://github.com/beefe/react-native-actionsheet 照片墙 https://github.com/ldn0x7dc/react-native-gallery 键盘遮挡问题 https://github.com/reactnativecn/react-native-inputscrollview https://github.com/wix/react-native-keyboard-aware-scrollview 本地存储 https://github.com/sunnylqm/react-native-storage 小星星评分(动画效果) https://github.com/djchie/react-native-star-rating 扫描二维码 https://github.com/lazaronixon/react-native-qrcode-reader 通讯录 https://github.com/rt2zz/react-native-contacts 加密 https://www.npmjs.com/package/crypto-js 清除缓存 https://github.com/reactnativecn/react-native-http-cache ListView的优化 https://github.com/sghiassy/react-native-sglistview 图片base64转码 https://github.com/xfumihiro/react-native-image-to-base64 白屏问题 https://github.com/mehcode/rn-splash-screen Text跑马灯效果 https://github.com/remobile/react-native-marquee-label WebView相关 https://github.com/alinz/react-native-webview-bridge 判断横竖屏 https://github.com/yamill/react-native-orientation PDF https://github.com/cnjon/react-native-pdf-view 获取设备信息 https://github.com/rebeccahughes/react-native-device-info 手势放大/缩小/移动 https://github.com/kiddkai/react-native-gestures https://github.com/johanneslumpe/react-native-gesture-recognizers 上拉-刷新/下拉-加载 https://github.com/FaridSafi/react-native-gifted-listview https://github.com/jsdf/react-native-refreshable-listview https://github.com/greatbsky/react-native-pull/wiki 下拉选 https://github.com/alinz/react-native-dropdown 图片查看 https://github.com/oblador/react-native-lightbox 照片选择 https://github.com/marcshilling/react-native-image-picker https://github.com/ivpusic/react-native-image-crop-picker 图片加载进度条 https://github.com/oblador/react-native-image-progress 轮播视图 https://github.com/race604/react-native-viewpager https://github.com/FuYaoDe/react-native-app-intro https://github.com/appintheair/react-native-looped-carousel https://github.com/leecade/react-native-swiper 模态视图 https://github.com/maxs15/react-native-modalbox https://github.com/brentvatne/react-native-modal https://github.com/bodyflex/react-native-simple-modal 毛玻璃效果 https://github.com/react-native-fellowship/react-native-blur HTML 相关 https://github.com/jsdf/react-native-htmlview 推荐一款最近用到的日历组件(iOS android 两端通用)———–2018-01-25 日历组件 https://github.com/xgfe/react-native-datepicker 下拉选组件(ios,android 两端通用)———2018-01-25 Picker组件 https://github.com/beefe/react-native-picker 短信倒计时（支持后台持续计时） ——2018-04-09 https://github.com/kkkelicheng/ReactNative-CountDownButton]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
      <tags>
        <tag>react-native</tag>
        <tag>常用组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native 之react-native-swiper 动态赋值]]></title>
    <url>%2F2018%2F10%2F27%2FReact-native%20%E4%B9%8B%20react-native-swiper%20%E5%8A%A8%E6%80%81%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[在实际开发中, 经常会遇到轮播图, 轮播图的数据通常情况下都是网络获取的. 这里简单的记录一下接口获取轮播图数据, 然后动态赋值给 swiper. 轮播图组件是通过 react-native-swiper 实现, 这里不再多说. 直接源码说明: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596export default class MainPage extends Component &#123; static navigationOptions = &#123; headerTitle: '首页', &#125;; constructor(props) &#123; super(props); this.state = &#123; bannerData: null, &#125; &#125;; componentDidMount() &#123; this.fetchData(); &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;ScrollView style=&#123;styles.container&#125;&gt; &lt;View style=&#123;styles.cycle_view&#125;&gt; &#123; this.state.bannerData == null ? &lt;View style=&#123;styles.slide&#125;/&gt; : &lt;Swiper style=&#123;styles.swiper&#125; height=&#123;width/720*407&#125; loop=&#123;true&#125; autoplay=&#123;true&#125; autoplayTimeout=&#123;3&#125; horizontal=&#123;true&#125; paginationStyle=&#123;&#123;bottom: 10&#125;&#125; showsPagination=&#123;false&#125;&gt; &#123;this.renderSwiper()&#125; &lt;/Swiper&gt; &#125; &lt;/View&gt; &lt;/ScrollView&gt; &lt;/View&gt; ); &#125;;//请求数据 fetchData() &#123; NetRequest.get('你的接口 url地址',null,null).then((response) =&gt; &#123; this.setState(&#123; bannerData: response['data'] &#125;) &#125;, (error) =&gt; &#123; Alert.alert('error') &#125;) &#125;; // 渲染 renderSwiper()&#123; var itemArr = []; for (var i = 0; i &lt; this.state.bannerData.length; i++) &#123; let data = this.state.bannerData[i]; itemArr.push( &lt;TouchableOpacity key=&#123;i&#125;&gt; &lt;Image source=&#123;&#123;uri: data['imagePath']&#125;&#125; style=&#123;styles.swiper_image&#125; /&gt; &lt;/TouchableOpacity&gt; ); &#125; return itemArr; &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: color.view_background, flex: 1, &#125;, cycle_view: &#123; height: width/720*407, &#125;, slide: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#9DD6EB', &#125;, swiper: &#123; &#125;, swiper_image: &#123; height: width/720*407, &#125;, &#125;); 其实很简单, 就是通过请求的数据来动态的创建每一个 swiperItem ! react-native 小白交流群: 860196537 或者 234713941 enjoy it!]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
      <tags>
        <tag>react-native</tag>
        <tag>react-native-swiper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native 之九宫格列表]]></title>
    <url>%2F2018%2F10%2F27%2Freact-native%20%E4%B9%8B%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[就是类似这种的列表. 在 iOS 中有 UICollectionView 可以直接写这种类型的列表, 但在React-native 中直接就可以用 FlatList 完成, 也就是说这种类型的列表和普通的列表没什么区别, 只是在布局的时候要些许的差异. Let’s do it! 先上效果图: 1.渲染一个列表12345678910111213render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123;this.state.data&#125; renderItem=&#123;this.renderItem&#125; keyExtractor=&#123;(item, index) =&gt; index&#125; contentContainerStyle=&#123;styles.list_container&#125; /&gt; &lt;/View&gt; ) &#125;; 2. 给列表一个样式1234567891011list_container: &#123; // 主轴方向 flexDirection:'row', justifyContent: 'space-between', // 一行显示不下,换一行 flexWrap:'wrap', // 侧轴方向 alignItems:'center', // 必须设置,否则换行不起作用 paddingHorizontal: 20, &#125;, 这里注意: flexDirection flexWrap alignItems 这三个属性是必须设置的. 其实写九宫格列表最重要的就是这一块. 完整代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const &#123;width, height&#125; = Dimensions.get('window')const cols = 2;const vMargin = 20;const cellWH = (width-2*vMargin-15)/cols;const hMargin = 25;export default class AllRecommend extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; data: [], &#125; &#125;; componentDidMount() &#123; this.fetchData(); &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123;this.state.data&#125; renderItem=&#123;this.renderItem&#125; keyExtractor=&#123;(item, index) =&gt; index&#125; contentContainerStyle=&#123;styles.list_container&#125; /&gt; &lt;/View&gt; ) &#125;; renderItem(&#123;item, index&#125;) &#123; return ( &lt;TouchableOpacity activeOpacity=&#123;0.5&#125;&gt; &lt;View style=&#123;styles.item&#125;&gt; &lt;Image source=&#123;&#123;uri: item['image']&#125;&#125; style=&#123;&#123;width: cellWH,height:cellWH, borderRadius: 5&#125;&#125;/&gt; &lt;Text style=&#123;&#123;marginTop: 5, textAlign: 'center'&#125;&#125; numberOfLines=&#123;1&#125;&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125; fetchData() &#123; NetRequest.get('https://api.douban.com/v2/music/search?q=李志',null,null).then((response) =&gt; &#123; this.setState(&#123; data: response['musics'] &#125;) &#125;, (error) =&gt; &#123; &#125;) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: color.white, paddingVertical: 15, &#125;, list_container: &#123; // 主轴方向 flexDirection:'row', justifyContent: 'space-between', // 一行显示不下,换一行 flexWrap:'wrap', // 侧轴方向 alignItems:'center', // 必须设置,否则换行不起作用 paddingHorizontal: 20, &#125;, item: &#123; width:cellWH, marginTop:hMargin, alignItems: 'center', &#125;&#125;) 每一个 item 的大小尺寸可以根据自己的实际需求去设置. enjoy it! 小白开发交流群: 860196537]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
      <tags>
        <tag>react-native</tag>
        <tag>九宫格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬取拉勾网数据(破解反爬虫机制)]]></title>
    <url>%2F2018%2F10%2F27%2FPython%E7%88%AC%E5%8F%96%E6%8B%89%E5%8B%BE%E7%BD%91%E6%95%B0%E6%8D%AE(%E7%A0%B4%E8%A7%A3%E5%8F%8D%E7%88%AC%E8%99%AB%E6%9C%BA%E5%88%B6)%2F</url>
    <content type="text"><![CDATA[人生苦短, 我学 Python! 这篇文章主要记录一下我学习 Python 爬虫的一个小例子, 是爬取的拉勾网的数据. 1.准备配置 Python 环境什么的就不说了, 网上教程很多, 自行解决. 2.扒源码先打开[拉勾网][1]的网页. 我们要爬取这部分的数据, 即搜索结果列表数据: 检查源码, 打开如下图所示位置: 然后发现,这部分数据是我们所要爬取的数据: ok! 开始撸代码! 12345678910111213141516171819202122import requestsdef main(): url='https://www.lagou.com/jobs/positionAjax.json?city=%E4%B8%8A%E6%B5%B7&amp;needAddtionalResult=false' headers = &#123; 'User-Agent':'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Mobile Safari/537.36', 'Host':'www.lagou.com', 'Referer':'https://www.lagou.com/jobs/list_python?city=%E4%B8%8A%E6%B5%B7&amp;cl=false&amp;fromSearch=true&amp;labelWords=&amp;suginput=', 'X-Anit-Forge-Code':'0', 'X-Anit-Forge-Token':None, 'X-Requested-With': 'XMLHttpRequest' &#125; form_data = &#123; 'first': 'true', 'pn': '1', 'kd': 'Python' &#125; response = requests.post(url,headers=headers,data=form_data) print(response.text)if __name__ == '__main__': main() 解释一下: headers的获取: 这样就能获取到列表数据了, 为了方便操作这些数据, 还可以转换成 json 格式, 这样就可以为所欲为了! enjoy it!]]></content>
      <categories>
        <category>python学习笔记</category>
      </categories>
      <tags>
        <tag>pythton</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-navigation 使用详解]]></title>
    <url>%2F2018%2F04%2F12%2Freact-navigation-detail%2F</url>
    <content type="text"><![CDATA[转自: 这里 一、开源库介绍今年1月份，新开源的react-natvigation库备受瞩目。在短短不到3个月的时间，github上星数已达4000+。Fb推荐使用库，并且在React Native当前最新版本0.44中将Navigator删除。react-navigation据称有原生般的性能体验效果。 可能会成为未来React Native导航组件的主流军。本篇内容基于【 ^1.0.0-beta.9 】版本来介绍关于该库的使用和实战技巧。可以看到，虽然是beta版本，不过基本稳定，大家可放心在项目中使用。 该库包含三类组件： （1）StackNavigator：用来跳转页面和传递参数（2）TabNavigator：类似底部导航栏，用来在同一屏幕下切换不同界面（3）DrawerNavigator：侧滑菜单导航栏，用于轻松设置带抽屉导航的屏幕 二、react-navigation使用具体内容大致分为如下： （1）react-navigation库属性介绍 （2）StackNavigator、TabNavigator实现界面间跳转，Tab切换 （3）StackNavigator界面间跳转、传值、取值 （4）DrawerNavigator实现抽屉导航菜单 （5）DrawerNavigator扩展功能 1、StackNavigator属性介绍 navigationOptions：配置StackNavigator的一些属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344title：标题，如果设置了这个导航栏和标签栏的title就会变成一样的，不推荐使用 header：可以设置一些导航的属性，如果隐藏顶部导航栏只要将这个属性设置为null headerTitle：设置导航栏标题，推荐 headerBackTitle：设置跳转页面左侧返回箭头后面的文字，默认是上一个页面的标题。可以自定义，也可以设置为null headerTruncatedBackTitle：设置当上个页面标题不符合返回箭头后的文字时，默认改成&quot;返回&quot; headerRight：设置导航条右侧。可以是按钮或者其他视图控件 headerLeft：设置导航条左侧。可以是按钮或者其他视图控件 headerStyle：设置导航条的样式。背景色，宽高等 headerTitleStyle：设置导航栏文字样式 headerBackTitleStyle：设置导航栏‘返回’文字样式 headerTintColor：设置导航栏颜色 headerPressColorAndroid：安卓独有的设置颜色纹理，需要安卓版本大于5.0 gesturesEnabled：是否支持滑动返回手势，iOS默认支持，安卓默认关闭 screen：对应界面名称，需要填入import之后的页面 mode：定义跳转风格 card：使用iOS和安卓默认的风格 modal：iOS独有的使屏幕从底部画出。类似iOS的present效果 headerMode：返回上级页面时动画效果 float：iOS默认的效果 screen：滑动过程中，整个页面都会返回 none：无动画 cardStyle：自定义设置跳转效果 transitionConfig： 自定义设置滑动返回的配置 onTransitionStart：当转换动画即将开始时被调用的功能 onTransitionEnd：当转换动画完成，将被调用的功能 path：路由中设置的路径的覆盖映射配置 initialRouteName：设置默认的页面组件，必须是上面已注册的页面组件 initialRouteParams：初始路由参数 注：大家可能对于path不太理解。path属性适用于其他app或浏览器使用url打开本app并进入指定页面。path属性用于声明一个界面路径，例如：【/pages/Home】。此时我们可以在手机浏览器中输入：app名称://pages/Home来启动该App，并进入Home界面。 2、TabNavigator属性介绍 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162screen：和导航的功能是一样的，对应界面名称，可以在其他页面通过这个screen传值和跳转。 navigationOptions：配置TabNavigator的一些属性 title：标题，会同时设置导航条和标签栏的title tabBarVisible：是否隐藏标签栏。默认不隐藏(true) tabBarIcon：设置标签栏的图标。需要给每个都设置 tabBarLabel：设置标签栏的title。推荐 导航栏配置 tabBarPosition：设置tabbar的位置，iOS默认在底部，安卓默认在顶部。（属性值：&apos;top&apos;，&apos;bottom&apos;） swipeEnabled：是否允许在标签之间进行滑动 animationEnabled：是否在更改标签时显示动画 lazy：是否根据需要懒惰呈现标签，而不是提前，意思是在app打开的时候将底部标签栏全部加载，默认false,推荐为true trueinitialRouteName： 设置默认的页面组件 backBehavior：按 back 键是否跳转到第一个Tab(首页)， none 为不跳转 tabBarOptions：配置标签栏的一些属性iOS属性 activeTintColor：label和icon的前景色 活跃状态下 activeBackgroundColor：label和icon的背景色 活跃状态下 inactiveTintColor：label和icon的前景色 不活跃状态下 inactiveBackgroundColor：label和icon的背景色 不活跃状态下 showLabel：是否显示label，默认开启 style：tabbar的样式 labelStyle：label的样式安卓属性 activeTintColor：label和icon的前景色 活跃状态下 inactiveTintColor：label和icon的前景色 不活跃状态下 showIcon：是否显示图标，默认关闭 showLabel：是否显示label，默认开启 style：tabbar的样式 labelStyle：label的样式 upperCaseLabel：是否使标签大写，默认为true pressColor：material涟漪效果的颜色（安卓版本需要大于5.0） pressOpacity：按压标签的透明度变化（安卓版本需要小于5.0） scrollEnabled：是否启用可滚动选项卡 tabStyle：tab的样式 indicatorStyle：标签指示器的样式对象（选项卡底部的行）。安卓底部会多出一条线，可以将height设置为0来暂时解决这个问题 labelStyle：label的样式 iconStyle：图标样式 3、DrawerNavigator属性介绍123456789101112131415161718192021DrawerNavigatorConfig drawerWidth - 抽屉的宽度 drawerPosition - 选项是左或右。 默认为左侧位置 contentComponent - 用于呈现抽屉内容的组件，例如导航项。 接收抽屉的导航。 默认为DrawerItems contentOptions - 配置抽屉内容 initialRouteName - 初始路由的routeName order - 定义抽屉项目顺序的routeNames数组。 路径 - 提供routeName到路径配置的映射，它覆盖routeConfigs中设置的路径。 backBehavior - 后退按钮是否会切换到初始路由？ 如果是，设置为initialRoute，否则为none。 默认为initialRoute行为 DrawerItems的contentOptions属性 activeTintColor - 活动标签的标签和图标颜色 activeBackgroundColor - 活动标签的背景颜色 inactiveTintColor - 非活动标签的标签和图标颜色 inactiveBackgroundColor - 非活动标签的背景颜色 内容部分的样式样式对象 labelStyle - 当您的标签是字符串时，要覆盖内容部分中的文本样式的样式对象从上述中大致了解了react-navigation三种组件的一些基本属性，所以到我们甩起袖子撸代码见证下奇迹了。4、使用StackNavigator + TabNavigator实现Tab界面切换、界面间导航 API定义：StackNavigator(RouteConfigs, StackNavigatorConfig)、TabNavigator(RouteConfigs, TabNavigatorConfig) （1）集成 react-navigation：在终端执行 【 npm install react-navigation –save 】 （2）界面中导入必要组件： 123import &#123;StackNavigator,TabNavigator,TabBarBottom&#125; from 'react-navigation'; import HomeScreen from './pages/HomePage'; import MineScreen from './pages/MinePage'; （3）定义TabNavigator： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const Tab = TabNavigator( &#123; Home:&#123; screen:HomeScreen, navigationOptions:(&#123;navigation&#125;) =&gt; (&#123; tabBarLabel:'首页', tabBarIcon:(&#123;focused,tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require('./imgs/nav_fav@2x.png')&#125; selectedImage=&#123;require('./imgs/nav_fav_actived@3x.png')&#125; /&gt; ) &#125;), &#125;, Mine:&#123; screen:MineScreen, navigationOptions:(&#123;navigation&#125;) =&gt; (&#123; tabBarLabel:'我', tabBarIcon:(&#123;focused,tintColor&#125;) =&gt; ( &lt;TabBarItem tintColor=&#123;tintColor&#125; focused=&#123;focused&#125; normalImage=&#123;require('./imgs/tab_me_nor@3x.png')&#125; selectedImage=&#123;require('./imgs/tab_me_selected@2x.png')&#125; /&gt; ) &#125;), &#125;, &#125;, &#123; tabBarComponent:TabBarBottom, tabBarPosition:'bottom', swipeEnabled:false, animationEnabled:false, lazy:true, tabBarOptions:&#123; activeTintColor:'#06c1ae', inactiveTintColor:'#979797', style:&#123;backgroundColor:'#ffffff',&#125;, labelStyle: &#123; fontSize: 20, // 文字大小 &#125;, &#125; &#125; ); TabBarItem为封装的组件： 1234567891011121314import React,&#123;Component&#125; from 'react'; import &#123;Image&#125; from 'react-native'; export default class TabBarItem extends Component &#123; render() &#123; return( &lt;Image source=&#123; this.props.focused ? this.props.selectedImage : this.props.normalImage &#125; style=&#123; &#123; tintColor:this.props.tintColor,width:25,height:25 &#125; &#125; /&gt; ) &#125; &#125; 可以看到，我们定义了一个名称为【Tab】的TabNavigator的导航组件。在组件中，分为两层参数： （1）第一层参数定义了要切换的界面，即【首页】、【我】两个界面组件，通过screen属性指定。并且通过navigationOptions属性设置相关属性参数。 （2）设置导航栏的属性参数。 TabNavigator定义好之后，需要用StackNavigator，顾名思义，StackNavigator就是以栈的方式来存放整个界面的，而TabNavigator是作为一个界面内不同子界面之间切换。所以还需要我们定义StackNavigator： 123456789101112131415161718const Navigator = StackNavigator( &#123; Tab:&#123;screen:Tab&#125;, Product:&#123;screen:ProductScreen&#125; &#125;, &#123; navigationOptions:&#123; headerBackTitle:null, headerTintColor:'#333333', showIcon:true, swipeEnabled:false, animationEnabled:false, &#125;, mode:'card', &#125;); 看起来和TabNavigator很相似，同样是指定了两个参数： （1）指定要跳转的界面组件。同样是screen属性标识界面组件，不多赘述。 （2）定义跳转属性参数，即顶部导航栏的一些参数设置和跳转方式。 可以看到，我们将Tab作为一个界面设置到了StackNavigator。这样就可以实现Tab导航和界面间跳转的效果了。 最后就是在render中引用StackNavigator： 12345678export default class Demo extends Component &#123; render() &#123; return ( &lt;Navigator /&gt; ); &#125; &#125; StackNavigator还提供了onNavigationStateChange回调方法，用来监听导航状态的改变。具体不再赘述。实现了界面跳转和切换，那么就该来增加下界面之间的感情了，来看看如何实现界面之间的传值和取值。 5、界面间跳转、传值、取值 在界面组件注入到StackNavigator中时，界面组件就被赋予了navigation属性，即在界面组件中可以通过【this.props.navigation】获取并进行一些操作。 navigation属性中提供了很多的函数简化界面间操作，简单列举几点： （1）通过navigate函数实现界面之间跳转： 1this.props.navigation.navigate('Mine'); 参数为我们在StackNavigator注册界面组件时的名称。同样也可以从当前页面返回到上一页： 12// 返回上一页 this.props.navigation.goBack(); （2）跳转时传值： 1this.props.navigation.navigate('Mine',&#123;info:'传值过去'&#125;); 第一个参数同样为要跳转的界面组件名称，第二个参数为要传递的参数，info可以理解为key，后面即传递的参数。 （3）获取值： 1&#123;this.props.navigation.state.params.info&#125; 通过state.params来获取传来的参数，后面为key值。此处为info。 以上实现完成，我们就可以愉快的玩耍啦~~ 什么？忽然发现在Android上的效果和IOS效果不一样。老板要界面一致哇~ 怎么办？那就需要我们进行简单的适配了。 三、DrawerNavigator实现抽屉导航1、导航实现 API定义：DrawerNavigator（RouteConfigs，DrawerNavigatorConfig） （1）界面中定义DrawerNavigator： 123456789101112131415161718192021222324252627import &#123;StackNavigator,TabNavigator,DrawerNavigator&#125; from 'react-navigation'; import HomeScreen from './pages/HomePage'; import MineScreen from './pages/MinePage'; export default class Demo extends Component &#123; render() &#123; return ( &lt;Navigator /&gt; ); &#125; &#125; const Navigator = DrawerNavigator(&#123; Home:&#123;screen:HomeScreen&#125;, Mine:&#123;screen:MineScreen&#125;, &#125;); const styles = StyleSheet.create(&#123; container: &#123; flex: 1, &#125;, &#125;); AppRegistry.registerComponent('Demo', () =&gt; Demo); 定义方式和StackNavigator基本类似，不再赘述。 （2）HomeScreen界面和MineScreen界面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export default class HomePage extends Component &#123; static navigationOptions = &#123; drawerLabel: '首页', drawerIcon:(&#123;tintColor&#125;) =&gt; ( &lt;Image source=&#123;require('./../imgs/ic_happy.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125;/&gt; ), &#125;; render() &#123; return( &lt;View style=&#123;&#123;flex:1&#125;&#125;&gt; &lt;Text onPress=&#123;this._skip.bind(this)&#125;&gt;点击跳转&lt;/Text&gt; &lt;/View&gt; ); &#125; _skip() &#123; this.props.navigation.navigate("Mine"); &#125; &#125; export default class MinePage extends Component &#123; static navigationOptions = &#123; drawerLabel:'我', drawerIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Image source=&#123;require('./../imgs/ic_h.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125; /&gt; ), &#125;; render() &#123; return( &lt;View style=&#123;&#123;flex:1&#125;&#125;&gt; &lt;Text onPress=&#123;this._skip.bind(this)&#125;&gt;返回上一界面&lt;/Text&gt; &lt;/View&gt; ); &#125; /** * 跳转 */ _skip() &#123; this.props.navigation.goBack(); &#125; &#125; 代码很简单，实现了界面之间的跳转。 2、扩展功能 （1）默认DrawerView不可滚动。要实现可滚动视图，必须使用contentComponent自定义容器，如下所示： 12345&#123; drawerWidth：200， 抽屉位置：“对” contentComponent：props =&gt; &lt;ScrollView&gt; &lt;DrawerItems &#123;... props&#125; /&gt; &lt;/ ScrollView&gt; &#125; （2）可以覆盖导航使用的默认组件，使用DrawerItems自定义导航组件： 1234567import &#123;DrawerItems&#125; from 'react-navigation'; const CustomDrawerContentComponent = (props) =&gt; ( &lt;View style = &#123;style.container&#125;&gt; &lt;DrawerItems &#123;... props&#125; /&gt; &lt;/View&gt; ); （3）嵌套抽屉导航 如果您嵌套DrawerNavigation，抽屉将显示在父导航下方。 五、效果图抽屉导航： 以上就是我们实战中常用的属性和技巧。具体的操作还需要大家在实践过程中测试体会。 源码参考]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
      <tags>
        <tag>navigator</tag>
        <tag>tabNavigator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Method Swizzling 和 AOP 实践]]></title>
    <url>%2F2018%2F04%2F03%2FMethod_Swizzling_and_AOP%2F</url>
    <content type="text"><![CDATA[转自: http://tech.glowing.com/cn/method-swizzling-aop/ 上一篇介绍了 Objective-C Messaging。利用 Objective-C 的 Runtime 特性，我们可以给语言做扩展，帮助解决项目开发中的一些设计和技术问题。这一篇，我们来探索一些利用 Objective-C Runtime 的黑色技巧。这些技巧中最具争议的或许就是 Method Swizzling 。 介绍一个技巧，最好的方式就是提出具体的需求，然后用它跟其他的解决方法做比较。 所以，先来看看我们的需求：对 App 的用户行为进行追踪和分析。简单说，就是当用户看到某个 View 或者点击某个 Button 的时候，就把这个事件记下来。 手动添加最直接粗暴的方式就是在每个 viewDidAppear 里添加记录事件的代码。 1234567891011121314151617181920@implementation MyViewController ()- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated]; // Custom code // Logging [Logging logWithEventName:@“my view did appear”];&#125;- (void)myButtonClicked:(id)sender&#123; // Custom code // Logging [Logging logWithEventName:@“my button clicked”];&#125; 这种方式的缺点也很明显：它破坏了代码的干净整洁。因为 Logging 的代码本身并不属于 ViewController 里的主要逻辑。随着项目扩大、代码量增加，你的 ViewController 里会到处散布着 Logging 的代码。这时，要找到一段事件记录的代码会变得困难，也很容易忘记添加事件记录的代码。 你可能会想到用继承或类别，在重写的方法里添加事件记录的代码。代码可以是长的这个样子： 123456789101112131415161718192021@implementation UIViewController ()- (void)myViewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated]; // Custom code // Logging [Logging logWithEventName:NSStringFromClass([self class])];&#125;- (void)myButtonClicked:(id)sender&#123; // Custom code // Logging NSString *name = [NSString stringWithFormat:@“my button in %@ is clicked”, NSStringFromClass([self class])]; [Logging logWithEventName:name];&#125; Logging的代码都很相似，通过继承或类别重写相关方法是可以把它从主要逻辑中剥离出来。但同时也带来新的问题： 你需要继承 UIViewController, UITableViewController,UICollectionViewController 所有这些 ViewController ，或者给他们添加类别； 每个 ViewController 里的 ButtonClick 方法命名不可能都一样； 你不能控制别人如何去实例化你的子类； 对于类别，你没办法调用到原来的方法实现。大多时候，我们重写一个方法只是为了添加一些代码，而不是完全取代它。 如果有两个类别都实现了相同的方法，运行时没法保证哪一个类别的方法会给调用。 Method SwizzlingMethod Swizzling 利用 Runtime 特性把一个方法的实现与另一个方法的实现进行替换。 上一篇文章 有讲到每个类里都有一个 Dispatch Table ，将方法的名字（SEL）跟方法的实现（IMP，指向 C 函数的指针）一一对应。Swizzle 一个方法其实就是在程序运行时在 Dispatch Table 里做点改动，让这个方法的名字（SEL）对应到另个IMP 。 首先定义一个类别，添加将要 Swizzled 的方法： 12345678910@implementation UIViewController (Logging)- (void)swizzled_viewDidAppear:(BOOL)animated&#123; // call original implementation [self swizzled_viewDidAppear:animated]; // Logging [Logging logWithEventName:NSStringFromClass([self class])];&#125; 代码看起来可能有点奇怪，像递归不是么。当然不会是递归，因为在 runtime 的时候，函数实现已经被交换了。调用 viewDidAppear: 会调用你实现的 swizzled_viewDidAppear:，而在 swizzled_viewDidAppear: 里调用 swizzled_viewDidAppear: 实际上调用的是原来的 viewDidAppear: 。 接下来实现 swizzle 的方法 ： 12345678910111213141516171819@implementation UIViewController (Logging)void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector) &#123; // the method might not exist in the class, but in its superclass Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // class_addMethod will fail if original method already exists BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); // the method doesn’t exist and we just added one if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125; 这里唯一可能需要解释的是 class_addMethod 。要先尝试添加原 selector 是为了做一层保护，因为如果这个类没有实现 originalSelector ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。所以我们先尝试添加 orginalSelector ，如果已经存在，再用 method_exchangeImplementations 把原方法的实现跟新的方法实现给交换掉。 最后，我们只需要确保在程序启动的时候调用 swizzleMethod 方法。比如，我们可以在之前 UIViewController 的 Logging 类别里添加 +load: 方法，然后在 +load: 里把 viewDidAppear 给替换掉： 123456@implementation UIViewController (Logging)+ (void)load&#123; swizzleMethod([self class], @selector(viewDidAppear:), @selector(swizzled_viewDidAppear:));&#125; 一般情况下，类别里的方法会重写掉主类里相同命名的方法。如果有两个类别实现了相同命名的方法，只有一个方法会被调用。但 +load: 是个特例，当一个类被读到内存的时候， runtime 会给这个类及它的每一个类别都发送一个 +load: 消息。 其实，这里还可以更简化点：直接用新的 IMP取代原 IMP ，而不是替换。只需要有全局的函数指针指向原IMP 就可以。 1234567891011121314151617181920void (gOriginalViewDidAppear)(id, SEL, BOOL);void newViewDidAppear(UIViewController *self, SEL _cmd, BOOL animated) &#123; // call original implementation gOriginalViewDidAppear(self, _cmd, animated); // Logging [Logging logWithEventName:NSStringFromClass([self class])];&#125;+ (void)load&#123; Method originalMethod = class_getInstanceMethod(self, @selector(viewDidAppear:)); gOriginalViewDidAppear = (void *)method_getImplementation(originalMethod); if(!class_addMethod(self, @selector(viewDidAppear:), (IMP) newViewDidAppear, method_getTypeEncoding(originalMethod))) &#123; method_setImplementation(originalMethod, (IMP) newViewDidAppear); &#125;&#125; 通过 Method Swizzling ，我们成功把逻辑代码跟处理事件记录的代码解耦。当然除了 Logging ，还有很多类似的事务，如 Authentication 和 Caching。这些事务琐碎，跟主要业务逻辑无关，在很多地方都有，又很难抽象出来单独的模块。这种程序设计问题，业界也给了他们一个名字 - Cross Cutting Concerns。 而像上面例子用 Method Swizzling 动态给指定的方法添加代码，以解决 Cross Cutting Concerns 的编程方式叫：Aspect Oriented Programming Aspect Oriented Programming （面向切面编程）Wikipedia 里对 AOP 是这么介绍的: An aspect can alter the behavior of the base code by applying advice(additional behavior) at various join points (points in a program)specified in a quantification or query called a pointcut (that detectswhether a given join point matches). 在 Objective-C 的世界里，这句话意思就是利用 Runtime 特性给指定的方法添加自定义代码。有很多方式可以实现 AOP ，Method Swizzling 就是其中之一。而且幸运的是，目前已经有一些第三方库可以让你不需要了解 Runtime ，就能直接开始使用 AOP 。 Aspects 就是一个不错的 AOP 库，封装了 Runtime ， Method Swizzling 这些黑色技巧，只提供两个简单的API： 12345678+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; 使用 Aspects 提供的API，我们之前的例子会进化成这个样子： 1234567891011@implementation UIViewController (Logging)+ (void)load&#123; [UIViewController aspect_hookSelector:@selector(viewDidAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; NSString *className = NSStringFromClass([[aspectInfo instance] class]); [Logging logWithEventName:className]; &#125; error:NULL];&#125; 你可以用同样的方式在任何你感兴趣的方法里添加自定义代码，比如 IBAction 的方法里。更好的方式，你提供一个 Logging 的配置文件作为唯一处理事件记录的地方： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@implementation AppDelegate (Logging)+ (void)setupLogging&#123; NSDictionary *config = @&#123; @"MainViewController": @&#123; GLLoggingPageImpression: @"page imp - main page", GLLoggingTrackedEvents: @[ @&#123; GLLoggingEventName: @"button one clicked", GLLoggingEventSelectorName: @"buttonOneClicked:", GLLoggingEventHandlerBlock: ^(id&lt;AspectInfo&gt; aspectInfo) &#123; [Logging logWithEventName:@"button one clicked"]; &#125;, &#125;, @&#123; GLLoggingEventName: @"button two clicked", GLLoggingEventSelectorName: @"buttonTwoClicked:", GLLoggingEventHandlerBlock: ^(id&lt;AspectInfo&gt; aspectInfo) &#123; [Logging logWithEventName:@"button two clicked"]; &#125;, &#125;, ], &#125;, @"DetailViewController": @&#123; GLLoggingPageImpression: @"page imp - detail page", &#125; &#125;; [AppDelegate setupWithConfiguration:config];&#125;+ (void)setupWithConfiguration:(NSDictionary *)configs&#123; // Hook Page Impression [UIViewController aspect_hookSelector:@selector(viewDidAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; NSString *className = NSStringFromClass([[aspectInfo instance] class]); [Logging logWithEventName:className]; &#125; error:NULL]; // Hook Events for (NSString *className in configs) &#123; Class clazz = NSClassFromString(className); NSDictionary *config = configs[className]; if (config[GLLoggingTrackedEvents]) &#123; for (NSDictionary *event in config[GLLoggingTrackedEvents]) &#123; SEL selekor = NSSelectorFromString(event[GLLoggingEventSelectorName]); AspectHandlerBlock block = event[GLLoggingEventHandlerBlock]; [clazz aspect_hookSelector:selekor withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; block(aspectInfo); &#125; error:NULL]; &#125; &#125; &#125;&#125; 然后在 -application:didFinishLaunchingWithOptions: 里调用 setupLogging： 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. [self setupLogging]; return YES;&#125; 最后的话利用 objective-C Runtime 特性和 Aspect Oriented Programming ，我们可以把琐碎事务的逻辑从主逻辑中分离出来，作为单独的模块。它是对面向对象编程模式的一个补充。Logging 是个经典的应用，这里做个抛砖引玉，发挥想象力，可以做出其他有趣的应用。 使用 Aspects 完整的例子可以从这里获得：AspectsDemo。]]></content>
      <categories>
        <category>iOS 之 runtime</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 之简易涂鸦板]]></title>
    <url>%2F2017%2F06%2F08%2Fandroid-canvas%2F</url>
    <content type="text"><![CDATA[没有废话，简单粗暴。 1.创建一个自定义 view创建一个 DrawView，继承自 android.view.View 类。在这个类中，先定义所需的属性，再创建一个构造方法。 12345678910111213141516171819202122232425public class DrawView extends View &#123; private int view_width = 0;//画板宽度 private int view_height = 0;//画板高度 private float preX;//起始点的 x 坐标 private float preY;//起始点的 y 坐标 private Path path;//路径 public Paint paint = null;//画笔 Bitmap cacheBitmap = null;//定义一个内存中的图片，该图片作为缓冲区 Canvas cacheCanvas = null;//定义 cacheBitmap 上的 Canvas 对象 /*构造方法*/ public DrawView(Context context, AttributeSet set)&#123; super(context,set); &#125; /*重写 onDraw 方法*/ @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125;&#125; 2.修改 xml 文件修改 activity_main.xml 文件，并将自定义的 DrawView 添加到布局管理器中。 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" &gt; &lt;com.example.test.DrawView android:id="@+id/drawView1" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/FrameLayout&gt; 3.DrawView 的构造方法在 DrawView 的构造方法中，首先获取屏幕的宽度和高度，并创建一个与该 view 相同大小的缓存区，然后创建一个新的画面，并实例化一个路径，再讲内存中的位图绘制到 cacheCanvas 中，最后实例化一个画笔，并设置画笔的相关属性。 12345678910111213141516171819202122232425262728//获取屏幕宽度 view_width = context.getResources().getDisplayMetrics().widthPixels; //获取屏幕高度 view_height = context.getResources().getDisplayMetrics().heightPixels; cacheBitmap = Bitmap.createBitmap(view_width,view_height, Bitmap.Config.ARGB_8888); //创建一个新的画布 cacheCanvas = new Canvas(); path = new Path(); //在 cacheCanvas 上绘制 cacheBitmap cacheCanvas.setBitmap(cacheBitmap); paint = new Paint(Paint.DITHER_FLAG); //设置默认的画笔颜色 paint.setColor(Color.RED); //设置填充方式为描边 paint.setStyle(Paint.Style.STROKE); //设置笔刷的图形样式 paint.setStrokeJoin(Paint.Join.ROUND); //设置画笔转弯处的连接风格 paint.setStrokeCap(Paint.Cap.ROUND); //设置默认的画笔的宽度 paint.setStrokeWidth(1); //使用抗锯齿功能 paint.setAntiAlias(true); //使用抖动效果 paint.setDither(true); 4.重写 onDraw 方法在 DrawView 的 onDraw 方法中，设置背景颜色，绘制 cacheBitmap，绘制路径以及保存当前的状态到栈中，并调用 restore()方法恢复所保存的状态。 12345678910111213//设置背景颜色 canvas.drawColor(0xFFFFFFFF); //采用默认设置创建一个画笔 Paint bmpPaint = new Paint(); //绘制cacheBitmap canvas.drawBitmap(cacheBitmap,0,0,bmpPaint); //绘制路径 canvas.drawPath(path,paint); //保存 canvas 状态 canvas.save(Canvas.ALL_SAVE_FLAG); //恢复 canvas 之前的保存状态，防止保存后对 canvas 执行的操作最后续的绘制有影响 canvas.restore(); 5.重写 onTouchEvent 方法在 DrawView 类中，重写onTouchEvent() 方法，为该视图添加触摸时间监听器，在该方法中，首先获取触摸时间发生的位置，然后应用 switch 对时间的不同状态添加响应代码，最后调用invalidate()方法更新视图。 12345678910111213141516171819202122232425262728293031323334353637@Override public boolean onTouchEvent(MotionEvent event) &#123; //获取触摸时间发生的位置 float x = event.getX(); float y = event.getY(); switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: //将绘图的起始点移到（x，y）的坐标位置 path.moveTo(x,y); preX = x; preY = y; break; case MotionEvent.ACTION_MOVE: float dx = Math.abs(x-preX); float dy = Math.abs(y-preY); //判断是否在允许的范围内 if (dx&gt;=5 || dy &gt;= 5)&#123; path.quadTo(preX,preY,(x+preX)/2,(y+preY)/2); preX = x; preY = y; &#125; break; case MotionEvent.ACTION_UP: //绘制路径 cacheCanvas.drawPath(path,paint); path.reset(); break; &#125; invalidate(); //返回 true，表示处理方法已经处理该事件 return true; &#125; 6.编写 clear() 方法写一个 clear() 方法，用来实现橡皮擦功能。 1234567public void clear() &#123; //设置图形重叠时的处理方式 paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR)); //设置橡皮擦的宽度 paint.setStrokeWidth(50); &#125; 7.编写 save() 方法写一个方法，用来保存当前的绘图。 12345678910111213141516171819202122232425public void save() &#123; try &#123; saveBitmap("myPicture"); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;private void saveBitmap(String filename) throws IOException &#123; //创建文件对象 File file = new File("/sdcard/pictures/"+filename+".png"); //创建一个新文件 file.createNewFile(); //创建一个文件输出流对象 FileOutputStream out = new FileOutputStream(file); //将绘图内容压缩成 PNG 格式输出到输出流对象中 cacheBitmap.compress(Bitmap.CompressFormat.PNG,100,out); //将缓冲区的数据全部写出到输出流中 out.flush(); //关闭文件输出流对象 out.close(); &#125; 8.设置权限12&lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; 9.创建 menu 资源文件在 res 目录下，创建menu 文件夹，在 menu 文件夹下，创建 toolsmenu.xml 资源文件。 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item android:title="@string/color"&gt; &lt;menu &gt; &lt;!-- 定义一组单选菜单项 --&gt; &lt;group android:checkableBehavior="single" &gt; &lt;!-- 定义子菜单 --&gt; &lt;item android:id="@+id/red" android:title="@string/color_red"/&gt; &lt;item android:id="@+id/green" android:title="@string/color_green"/&gt; &lt;item android:id="@+id/blue" android:title="@string/color_blue"/&gt; &lt;/group&gt; &lt;/menu&gt; &lt;/item&gt; &lt;item android:title="@string/width"&gt; &lt;menu &gt; &lt;!-- 定义子菜单 --&gt; &lt;group&gt; &lt;item android:id="@+id/width_1" android:title="@string/width_1"/&gt; &lt;item android:id="@+id/width_2" android:title="@string/width_2"/&gt; &lt;item android:id="@+id/width_3" android:title="@string/width_3"/&gt; &lt;/group&gt; &lt;/menu&gt; &lt;/item&gt; &lt;item android:id="@+id/clear" android:title="@string/clear"/&gt; &lt;item android:id="@+id/save" android:title="@string/save"/&gt;&lt;/menu&gt; 10.添加选项菜单重写onCreateOptionsMenu方法在 activity 文件中，重写onCreateOptionsMenu()方法，在该方法中，实例化一个MenuInflater对象，并解析菜单资源文件。 123456@Override public boolean onCreateOptionsMenu(Menu menu) &#123; MenuInflater menuInflater = new MenuInflater(this); menuInflater.inflate(R.menu.toolsmenu,menu); return super.onCreateOptionsMenu(menu); &#125; 重写onOptionsItemSelected方法重写onOptionsItemSelected() 方法，分别对各个菜单项被选择时做出相应的处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Override public boolean onOptionsItemSelected(MenuItem item) &#123; //获取自定义视图 DrawView drawView = (DrawView)findViewById(R.id.drawView1); //取消擦除效果 drawView.paint.setXfermode(null); //初始化画笔的宽度 drawView.paint.setStrokeWidth(1); switch (item.getItemId())&#123; //设置画笔的颜色为红色 case R.id.red: drawView.paint.setColor(Color.RED); item.setChecked(true); break; //设置画笔的颜色为绿色 case R.id.green: drawView.paint.setColor(Color.GREEN); item.setChecked(true); break; //设置画笔的颜色为蓝色 case R.id.blue: drawView.paint.setColor(Color.BLUE); item.setChecked(true); break; //设置画笔的宽度为1 case R.id.width_1: drawView.paint.setStrokeWidth(1); break; //设置画笔的宽度为5 case R.id.width_2: drawView.paint.setStrokeWidth(5); break; //设置画笔的宽度为10 case R.id.width_3: drawView.paint.setStrokeWidth(10); break; //擦除绘画 case R.id.clear: drawView.clear(); break; //保存绘画 case R.id.save: drawView.save(); break; &#125; return true; &#125; 运行，就会得到一个简易的涂鸦板，可以改变画笔颜色，画笔宽度，擦除，保存等。 真是越来越有意思了呢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>paint</tag>
        <tag>draw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义 item 的 ListView]]></title>
    <url>%2F2017%2F06%2F05%2Fandroid-listView%2F</url>
    <content type="text"><![CDATA[从 iOS 的 TableView 突然转到 Android 的 ListView， 说实话，很恶心。各种不方便，不要问我为什么学 Android，我也不想，唉，牢骚归牢骚，既然学了，就得学到点什么，不然既浪费时间，又什么都没得到,太亏了。记录一下学习的历程。 在使用 ListView 的时候，大部分我们都会自定义 item，iOS 也一样，会自定义 cell。不然使用系统为我们提供的几种格式是满足不了我们的各式各样的需求的。 废话到此为止。 1.先在 xml 文件中布局：1234567&lt;ListView android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/main_listView" android:layout_alignParentTop="true" android:layout_alignParentLeft="true" android:layout_alignParentStart="true" /&gt; 2.创建模型文件相当于 iOS 中的 model 文件，每写一个东西，就得去 iOS 中找对应的东西，这属于思维固化了。慢慢改正，不过这样能方便快速的理解这些东西。 12345678910111213141516171819public class Teacher &#123; private String name; private int imageID; //setter和getter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getImageID() &#123; return imageID; &#125; public void setImageID(int imageID) &#123; this.imageID = imageID; &#125;&#125; 相比较而言，Android 的模型文件真的很麻烦，定义一个属性，就得写它的 getter 和 setter 方法。也许有其他的办法，只是我还不知道。 3.创建Adapter这个适配器，在我的理解中就相当于 iOS 中的自定义 cell 了，比 iOS 方便的是，iOS 的那些数据源方法都在这里实现。一般的话，自定义的 adapter 会继承于 BaseAdapter。 1.实现数据源方法123456789101112131415161718192021222324@Override public int getCount() &#123; //返回多少行数据 return mList.size(); &#125; @Override public Object getItem(int position) &#123; //获取每一行的数据 return mList.get(position); &#125; @Override public long getItemId(int position) &#123; //获取行号 return position; &#125; @Override public View getView(final int position, View convertView, ViewGroup parent) &#123;//UI 刷新的代码主要在这里实现 return null;&#125; 2.创建一个构造方法这里是举例说明： 1234public TeacherAdapter(ArrayList&lt;Teacher&gt; mList, Context mContext) &#123; this.mList = mList; this.mContext = mContext; &#125; 4.给 item 布局创建一个 item 的 xml 文件，每一个 item 的布局都在这个文件中进行。 12345678910111213&lt;ImageView android:layout_width="50dp" android:layout_height="50dp" android:id="@+id/item_imageView" android:layout_marginTop="5dp" android:layout_marginLeft="10dp"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/item_textView" android:layout_marginLeft="10dp" android:layout_gravity="center_vertical"/&gt; 这里我给每个 item 上定义了两个控件，一个 TextView，一个 ImageView。是线性布局。 5.给控件赋值接下来再回到 adapter 文件中的 getView 方法中，在这个方法中为控件赋值。 12345678910111213141516171819@Override public View getView(final int position, View convertView, ViewGroup parent) &#123;//UI 刷新的代码主要在这里实现 //获取老师的数据 final Teacher teacher = mlist.get(position); //根据layout文件创建布局 View oneTeacherView = LayoutInflater.from(mContext).inflate(R.layout.teacher_item,parent,false); //获取ImageView和TextView ImageView imageView = (ImageView) oneTeacherView.findViewById(R.id.item_imageView); TextView textView = (TextView) oneTeacherView.findViewById(R.id.item_textView); //根据数据分别为imageView和textView赋值 imageView.setImageResource(teacher.getImageID()); textView.setText(teacher.getName()); return oneTeacherView;&#125; 6.设置数据源接下来回到 Activity 文件中，获取 listView 对象： 12345678910111213141516//因为这里是本地数据，所以将 listView 设置为了局部变量，本地数据也不需要在开启线程去刷新UIArrayList&lt;Teacher&gt; teacherList = new ArrayList&lt;Teacher&gt;();Teacher teacher = new Teacher()；teacher.setName("jack");teacher.setImageID(R.mipmap.header_image);teacherList.add(teacher);//我这里只添加了一条数据，如果像添加的话，添加进这个数组就行ListView listView = (ListView)findViewById(R.id.main_listView);TeacherAdapter adapter = new TeacherAdapter(teacherList,this);listView.setAdapter(adapter); 到这里，一个完整的自定义 item 的 ListView 算是完成了。但是在实际开发中，大部分的应用场景都是从网络端获取数据，然后给 ListView 赋值。这个等我学到网络的时候再来介绍一下。 如有不对之处，请多多指正！达者为师，谢谢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android-listView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 响应按钮点击事件的4种写法]]></title>
    <url>%2F2017%2F05%2F10%2Fandroid-onClick%2F</url>
    <content type="text"><![CDATA[在android 开发中，按钮响应点击事件有四种写法。下面依次介绍。 1. 匿名内部类这种方式一般适用于自己写 demo 测试时使用，优点就是快速。 1234567891011121314@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_register); Button button = (Button)findViewById(R.id.btn); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //响应事件 &#125; &#125;); &#125; 2. 自定义事件监听类这种方式和第一种差不多，唯一的区别就是将响应事件的代码放到一个自定义的监听类里面。 1234567891011121314151617@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_register); Button button = (Button)findViewById(R.id.btn); button.setOnClickListener(new MyListener()); &#125; //让自定义监听类去实现 View 的 OnClickListener 接口 private class MyListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; //响应事件 &#125; &#125; 3. 由 Activity 实现 OnClickListener 接口这种方式是在项目中应用最多的写法。因为这种写法可以减少代码量，尤其是在 Activity 上有多个点击事件的时候。 123456789101112131415161718192021222324public class RegisterActivity extends Activity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_register); Button button = (Button)findViewById(R.id.btn); button.setOnClickListener(this); &#125; public void onClick(View v) &#123; //根据 id 来区分分别是哪个按钮的点击事件 switch (v.getId())&#123; case R.id.btn: //响应事件 break; default: break; &#125; &#125; &#125; 4. 在布局文件中添加 onClick 属性这种方式不用在 Activity 中声明组件对象就可以响应点击事件，虽然在看起来很轻便，但是在维护测试的时候，不容易找到 button 相对应的点击事件，所以不太推荐使用。 首先在 XML 布局文件中添加 onClick 属性123456&lt;Button android:onClick="btnClick" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/btn" android:id="@+id/btn" /&gt; 在 Activity 中实现方法123public void btnClick(View v)&#123; //响应事件 &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>onClick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 集成到iOS原生项目]]></title>
    <url>%2F2017%2F05%2F03%2Frn-integration-iosNative%2F</url>
    <content type="text"><![CDATA[如果你正准备从头开始制作一个新的应用，那么React Native会是个非常好的选择。但如果你只想给现有的原生应用中添加一两个视图或是业务流程，React Native也同样不在话下。只需简单几步，你就可以给原有应用加上新的基于React Native的特性、画面和视图等。 把React Native组件植入到iOS应用中有如下几个主要步骤： 首先当然要了解你要植入的React Native组件。 创建一个Podfile，在其中以subspec的形式填写所有你要植入的React Native的组件。 创建js文件，编写React Native组件的js代码。 添加一个事件处理函数，用于创建一个RCTRootView。这个RCTRootView正是用来承载你的React Native组件的，而且它必须对应你在index.ios.js中使用AppRegistry注册的模块名字。 启动React Native的Packager服务，运行应用。 根据需要添加更多React Native的组件。 调试。 准备部署发布 （比如可以利用react-native-xcode.sh脚本）。 发布应用，升职加薪，走向人生巅峰！😘 创建一个原生应用这个就不多说。 添加依赖包React Native的植入过程同时需要React和React Native两个node依赖包。我们把具体的依赖包记录在package.json文件中。如果项目根目录中没有这个文件，那就自己创建一个。 package.json我这里的做法是在项目的根目录下创建一个专门存放react native相关的文件夹，就像这样： 然后在这个文件夹下创建一个package.json文件，就像这样： 在package.json文件中的内容是这样的： 123456789101112&#123; "name": "NativeRN", "version": "0.0.1", "private": true, "scripts": &#123; "start": "node node_modules/react-native/local-cli/cli.js start" &#125;, "dependencies": &#123; "react": "16.0.0-alpha.6", "react-native": "0.44.0" &#125;&#125; 解释一下： version字段没有太大意义（除非你要把你的项目发布到npm仓库）。 scripts中是用于启动packager服务的命令。 dependencies中的react和react-native的版本取决于你的具体需求。一般来说我们推荐使用最新版本。你可以使用npm info react和npm info react-native来查看当前的最新版本。另外，react-native对react的版本有严格要求，高于或低于某个范围都不可以。 本文无法在这里列出所有react native和对应的react版本要求，只能提醒读者先尝试执行npm install，然后注意观察安装过程中的报错信息，例如require react@某.某.某版本, but none was installed，然后根据这样的提示，执行npm i -S react@某.某.某版本。 安装依赖包使用npm（node包管理器，Node package manager）来安装React和React Native模块。这些模块会被安装到项目根目录下的node_modules/目录中。 在包含有package.json文件的目录（一般也就是项目根目录,我这里因为创建了RNComponent文件夹，所以是在这个文件夹目录下执行这个命令）中运行下列命令来安装： 1$ npm install 运行完成后会出现node_modules这样一个文件夹，这个文件夹下包含了RN的一些模块，就像这样： React Native框架React Native框架整体是作为node模块安装到项目中的。下一步我们需要在CocoaPods的Podfile中指定我们所需要使用的组件。 Subspecs在你开始把React Native植入到你的应用中之前，首先要决定具体整合的是React Native框架中的哪些部分。而这就是subspec要做的工作。在创建Podfile文件的时候，需要指定具体安装哪些React Native的依赖库。所指定的每一个库就称为一个subspec。 可用的subspec都列在node_modules/react-native/React.podspec中，基本都是按其功能命名的。一般来说你首先需要添加Core，这一subspec包含了必须的AppRegistry、StyleSheet、View以及其他的一些React Native核心库。如果你想使用React Native的Text库（即&lt;Text&gt;组件），那就需要添加RCTText的subspec。同理，Image需要加入RCTImage，等等。 ** Podfile*\\*在React和React Native模块成功安装到node_modules目录之后，你就可以开始创建Podfile以便选择所需的组件安装到应用中。 创建podfile在这里不在多说，相信只要用过cocoapods的朋友都知道。 podfile创建完成之后，在文件里添加一下内容： 12345678910111213141516# target的名字一般与你的项目名字相同target 'NativeRN' do # 'node_modules'目录一般位于根目录中 # 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path` pod 'React', :path =&gt; './RNComponent/node_modules/react-native', :subspecs =&gt; [ 'Core', 'RCTText', 'RCTNetwork', 'RCTWebSocket', # 这个模块是用于调试功能的 # 在这里继续添加你所需要的模块 ] # 如果你的RN版本 &gt;= 0.42.0，请加入下面这行 pod "Yoga", :path =&gt; "./RNComponent/node_modules/react-native/ReactCommon/yoga"end 然后执行下面的👇命令，开始安装React Native的pod包。 1$ pod install 代码集成index.ios.js首先创建一个空的index.ios.js文件。一般来说我们把它放置在项目根目录下。就像👇： index.ios.js是React Native应用在iOS上的入口文件。而且它是不可或缺的！它可以是个很简单的文件，简单到可以只包含一行require/import导入语句。 12# 在项目根目录执行以下命令创建文件：$ touch index.ios.js 添加你自己的React Native代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View&#125; from 'react-native';export default class NativeRN extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Welcome to React Native! &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; To get started, edit index.ios.js &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; Press Cmd+R to reload,&#123;'\n'&#125; Cmd+D or shake for dev menu &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, welcome: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;, instructions: &#123; textAlign: 'center', color: '#333333', marginBottom: 5, &#125;,&#125;);AppRegistry.registerComponent('NativeRN', () =&gt; NativeRN); 集成到原生项目中我这里先创建了一个ViewController，👇这样： 然后导入#import &lt;RCTRootView.h&gt;头文件,👇这样： 1234567891011121314- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. NSString * strUrl = @"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true"; NSURL * jsCodeLocation = [NSURL URLWithString:strUrl]; RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@"NativeRN" initialProperties:nil launchOptions:nil]; self.view = rootView; &#125; 还需要在info.plist文件中配置一下： 1234567891011&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;localhost&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt; 配置后的效果： 运行项目在运行项目前，先在react native文件夹目录下，启动开发服务器。也就是在本文中的RNComponent目录下，启动命令行： 1$ npm start 运行项目，看到效果：]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不思考，不读书]]></title>
    <url>%2F2017%2F05%2F03%2Fstudying-thinking%2F</url>
    <content type="text"><![CDATA[越来越感觉脑子不够用了。最近在学习一些新的东西，也许是自己的基础不扎实，导致学起来很乱，没有侧重点，完完全全就是一团乱麻。常常是刚刚想出来一个解决办法，继续往下写的时候，突然发现之前的方法不太好，然后就推翻重来，如此循环往复，没有看到一点显著的成果，才让我心生焦虑。 最近还有一件事情使我非常苦恼，其实也算不上苦恼，归根结底的原因就是因为自己贪玩。是这样的，现在《王者荣耀》这款手游简直是火的不得了，我也未能免受其害。可游戏这东西，玩多了真的会上瘾，所以最近花在游戏上的时间有点多。一方面慨叹于光阴的易逝，而另一方面还在召唤师峡谷里忘情厮杀。之前卸载过几次，狠话也说了很多，可就是控制不住自己。思来想去，自己就是太爱玩了，也太没有自制力了。最近想到一个办法，就是用读书来转移玩游戏的注意力。暂时还不知道管不管用，以后除了工作，要尽可能的摆脱对手机的依赖，多去读书，多去思考，多出去走走。 之前看过一个节目，里面有人讲到“读书永不毕业”，我觉得说的挺对的。中国不也有句老话叫“活到老，学到老”吗？就我自己来讲，学习可以使我觉得我的大脑还可以思想，还在运转，再说大一点，就是还能感觉到自己活着。倘若让我每天重复的，机械的做一些事情，而没有时间去思考，我肯定会受不了。有时候仔细想想，万一真的有一天，自己的大脑停止思想了，真的是挺可怕的一件事。之所以长个脑子，不就是用来思考的吗？学习，思考，真的是一生都需要做的一件事。 年轻的大好光阴，不用来学习，很可惜，不是吗？]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书，思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native Fetch网络请求]]></title>
    <url>%2F2017%2F04%2F27%2Freact-native-fetch%2F</url>
    <content type="text"><![CDATA[在react-native开发中，使用Fetch进行网络请求。官方文档上的网络请求 基本使用方法GET请求123456789fetch(@"http://www.baidu.com") .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; console.log(responseJson);//打印返回的数据 &#125;); &#125;) .catch((error)=&gt;&#123; console.log(error);//打印报的错 &#125;) catch住fetch可能抛出的异常，否则出错时你可能看不到任何提示。 POST请求Fetch还有可选的第二个参数，可以用来定制HTTP请求一些参数。你可以指定header参数，或是指定使用POST方法，又或是提交数据等等： 1234567891011fetch('https://mywebsite.com/endpoint/', &#123; method: 'POST', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; firstParam: 'yourValue', secondParam: 'yourOtherValue', &#125;)&#125;) 如果你的服务器无法识别上面POST的数据格式，那么可以尝试传统的form格式： 1234567fetch('https://mywebsite.com/endpoint/', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', &#125;, body: 'key1=value1&amp;key2=value2'&#125;) 可以参考Fetch请求文档来查看所有可用的参数。 简单封装GET12345678910111213141516171819202122232425262728/* * get请求 * url:请求地址 * params:参数 * callback:回调函数 * */ static get(url,params,callback)&#123; if (params) &#123; let paramsArray = []; //拼接参数 Object.keys(params).forEach(key =&gt; paramsArray.push(key + '=' + params[key])) if (url.search(/\?/) === -1) &#123; url += '?' + paramsArray.join('&amp;') &#125; else &#123; url += '&amp;' + paramsArray.join('&amp;') &#125; &#125; //fetch请求 fetch(url,&#123; method: 'GET', &#125;) .then((response) =&gt; &#123; callback(response) &#125;) .catch((error) =&gt; &#123; alert(error) &#125;); &#125; POSTpost有两种形式： 第一种：’Content-Type’: ‘application/json’ 123456789101112131415161718192021222324/* * post请求 * url:请求地址 * params:参数,这里的参数格式是：&#123;param1: 'value1',param2: 'value2'&#125; * callback:回调函数 * */ static postJSON(url,params,callback)&#123; //fetch请求 fetch(url,&#123; method: 'POST', headers: &#123; 'Accept': 'application/json', 'Content-Type': 'application/json', &#125;, body:JSON.stringify(params) &#125;) .then((response) =&gt; response.json()) .then((responseJSON) =&gt; &#123; callback(responseJSON) &#125;) .catch((error) =&gt; &#123; console.log("error = " + error) &#125;); &#125; 第二种： form表单形式 1234567891011121314151617181920212223/* * post请求 * url:请求地址 * params:参数,这里的参数要用这种格式：'key1=value1&amp;key2=value2' * callback:回调函数 * */ static postForm(url,params,callback)&#123; //fetch请求 fetch(url,&#123; method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', &#125;, body: params &#125;) .then((response) =&gt; response.json()) .then((responseJSON) =&gt; &#123; callback(responseJSON) &#125;) .catch((error) =&gt; &#123; console.log("error = " + error) &#125;); &#125; 调用12345678910111213//post请求let params = &#123;'key1':'value1','key2':'value2'&#125;; NetRequest.postJSON('http://www.baidu.com/',params,function (set) &#123; //下面的就是请求来的数据 console.log(set) &#125;) //get请求,以百度为例,没有参数,没有header NetRequest.get('https://www.baidu.com/','',function (set) &#123; //下面是请求下来的数据 console.log(set) &#125;) 解释一下： 12345//将`JSON`数据转换成字符串JSON.stringify(params)//将数据JSON化JSON.parse(responseJSON)]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
      <tags>
        <tag>fetch</tag>
        <tag>rn网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 获取crash日志]]></title>
    <url>%2F2017%2F04%2F21%2FgetCrashBlog%2F</url>
    <content type="text"><![CDATA[在项目上架到App Store以后，谁也不能保证没有一个错误，可能在测试期间连测试人员都没有发现的隐藏小bug在上线之后被用户发现了，这就无疑给用户造成了困扰。所以作为开发人员，要及时的收集这些crash日志信息，然后修复这些问题。 这里我用了一种方法，就是当应用在用户使用时发生崩溃现象，会获取到崩溃的日志，然后调起邮箱让用户通过邮件发送给我们。 具体代码如下： 12345678910111213141516#pragma mark - 获取异常日志- (void)installUncaughtExceptionHandler &#123; NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);&#125;void UncaughtExceptionHandler(NSException *exception) &#123; NSArray *arr = [exception callStackSymbols]; NSString *reason = [exception reason]; NSString *name = [exception name]; NSString *currentVersion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleVersion"]; NSString *urlStr = [NSString stringWithFormat:@"mailto://developer@qq.com?subject=Crash报告&amp;body=您的建议会让我们做的更好，感谢您的配合！&lt;br&gt;&lt;br&gt;&lt;br&gt;""错误详情(%@):&lt;br&gt;%@&lt;br&gt;-----------------------&lt;br&gt;%@&lt;br&gt;---------------------&lt;br&gt;%@",currentVersion,name,reason,[arr componentsJoinedByString:@"&lt;br&gt;"]]; NSURL *url = [NSURL URLWithString:[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]]; [[UIApplication sharedApplication]openURL:url];&#125; 然后在AppDelegate里的 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;//获取异常报告 [self installUncaughtExceptionHandler];&#125; 方法中调用就可以了。]]></content>
      <categories>
        <category>iOS 实用</category>
      </categories>
      <tags>
        <tag>Crash Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARC下的内存泄漏]]></title>
    <url>%2F2017%2F04%2F18%2FARCMemoryLeak%2F</url>
    <content type="text"><![CDATA[已习惯于arc帮我们管理内存的我们，写起代码来，比MRC似乎肆意妄为了许多，总有些有恃无恐的感觉，其实arc下面还是很容易引起内存溢出的。 ARC 是帮助我们做对象内存管理的一套机制，使得我们以前在 MRC 模式下管理内存工作量能在 ARC 模式下得到缓解。正如苹果官方文档上所描述的：Automatic Reference Counting (ARC) is a compiler feature that provides automatic memory management of Objective-C objects.可见 ARC 是编译时特性，它没有改变 Objective-C 引用计数式内存管理的本质，更不是 GC（垃圾回收）。也就是说只要我们稍不注意，隐式的持有或复制对象就会造成内存泄露。 NSNotificationcenter1[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(method:) name:@"notiName" object:nil]; 这里添加观察者其实是不会造成内存泄漏的，但是，但是，但是……如果self被销毁，当在调用post消息的时候，就会报对象被释放的错误，导致闪退，所以在添加观察者的对象，一定要在它被销毁的时候从消息中心删除！ 就是在注册通知的地方加上这个： 1234- (void)dealloc &#123; [[NSNotificationCenter defaultCenter]removeObserver:self];&#125; NSTimer1timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(method:) userInfo:nil repeats:YES]; 上面的timer为了防止 target 被释放而导致的程序异常，timer 会持有 target， self 持有 timer，timer 在初始化时持有 self，造成循环引用。解决的方法就是使用 invalidate 方法销掉 timer。 delegate属性的强引用把delegate声明为strong属性容易导致内存溢出 。 解决办法是把delegate属性的strong改为assign或者weak即可。 当用weak或assign修饰的时候，指明该对象并不负责保持delegate这个对象，delegate这个对象的销毁由外部控制。 当用strong修饰的时候，该对象强引用delegate，外界不能销毁delegate对象，会导致循环引用(Retain Cycles)。 WKWebView1[_webView.configuration.userContentController addScriptMessageHandler:self name:clickName]; 添加addScriptMessageHandler之后，必须在vc销毁前把它移除。 1[_webView.configuration.userContentController removeScriptMessageHandlerForName:clickName]; 和NSNotification 很类似。 Block 上面图片中就是一典型案例，红色部分就是修改之前导致内存溢出的代码，我们来分析一下： 上面的success block应该是self持有，而在success中有持有了self，导致self和 block 的循环引用，造成内存泄露！ 说到底还是造成了循环引用导致了内存泄漏，所以我们要打破循环，释放对象，这里我们把self变成了弱引用，打破循环引用。 以上几种情况可能通过instrument 是查看不出来的，至少是没有小红叉的。我们通过instruments查看所有VC的引用计数才找到那些VC是发生了内存泄露。 参考他的]]></content>
      <categories>
        <category>iOS 实用</category>
      </categories>
      <tags>
        <tag>ARC内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金山城市沙滩游]]></title>
    <url>%2F2017%2F04%2F16%2FvisitJinShanCityBeach%2F</url>
    <content type="text"><![CDATA[一大早就从床上爬起来，已经很久都没有起的这么早了，洗漱完毕，准备出发。聪明的我已经于昨晚查好了路线，确认无误后，正式出发。 对于大海，早就向往之，之前不知道上海的什么地方可以看到，一直耽搁未成行。但现在万事俱备，又恰逢这三四月舒爽的季节，还犹豫什么呢？ 对于我这样一个在中原长大的孩子，高山、大海都可以让我惊奇不已（说出来很尴尬，还是在去年才真正的爬了一次山）。虽然很累，但心愿已了。说真的，我是特别喜欢这种山山水水的自然风光，一方面慨叹于大自然的鬼斧神工，另一方面可以使自己放松身心，心旷神怡。带着对大海的期许，在车上睡着了。。。 金山这个地方距离我住的地方真的很远，从747换到了上石线，坐上没多久我就睡着了，中间醒了好几次，竟然还没有到，然后就无聊的玩手机了。不知道过了多久，终于到了。下车没走多久就看到了4号口，走近才发现是出口，只让出不让进（只好改道咯）！问了出口的保安，给指了指5号口的方向，大踏步的前进吧！到了之后，掏钱买票。。。等等，，，没带钱？？？翻遍了全身的口袋，找到了三块钱（两个硬币和一张纸币）。WTF!这下可怎么办，不过，经历过大风大浪的我，怎么可能让这点小事难倒。瞬间就想到了这是21世纪，接着在电光石火间就想到可以美团啊。哈哈哈，这点小事怎么可能难倒我。然而，售票的妹子（虽然以我的眼力一眼看不出她的年龄，姑且叫她大妹子吧）告诉我这个入口网上订的票不能进，要去3号口，QNMLGB。心里碎碎念了好久，这能怪谁呢？能怪我没带现金吗？当然不能，只能怪他们的设施不够现代化，接着走吧，顶着一轮明日，终于来到了。当然，拍个照先。 买票，进去，我看这次谁还敢拦我！ 现在是非泳期，但是是周末，所以票价是20。来都来了，再贵也得进啊。马上就能看到大海了，好激动。。。 这是什么鬼啊？这叫大海吗？这样的大海是带不走我的哀愁的吧？ 远处被一道像是大坝的东西给围住了，过来的浪一个个小的可怜，完全不是我想象中的样子。看到一块大石头，心想着，怎么着也得上去吟诗一首吧，跳上去刚刚站好，直抒胸臆的“啊”还没出口，背后响起了“帅哥，快下来，那里不让上噢”的声音，刚刚涌上来的灵感，汇成了一句“好的，马上下来”喷涌而出。 继续往前走，沙滩上的沙子是真的沙子，我没有脱鞋去感受，因为我怕扎了脚。 终于到了可以近距离接触到水的地方了，可还是被围栏围起来了，很煞风景有没有？没有比基尼美女（这个天气也不可能有，这才四月份）也就算了，就这点水还围起来，真是够了！沙滩上的一群大妈在热火朝天的聊着，时不时的还扭几下，难道是传说中的“沙滩舞蹈队”？正在我暗暗猜测她们的真正身份的时候，突然，三个大妈从人群中走了出来，背对着大海站好，她们对面还站着一位拍照的大妈，在拍照大妈的口令声中：“1”，“2”，“3”，三个大妈突然像少女般的跳了起来，而且还摆出了pose，全身闪起了青春的光芒，光芒四射，刺痛了我的眼睛。当然pose还未摆好，就已经从空中着陆了，毕竟跳起的高度有限。 再往前走，一股下水道污泥的味道扑面而来。只好调整方向，然后沙雕映入眼帘。 再往前走，视线开阔了一些，能看到远处的海域，似有若无的小岛。迎面的海风吹来，真的有点大海的感觉了。还有乘坐快艇在水中驰骋的乘客。好了，没有优美的词再去赞美这个地方了，能想到的就这么多。😁大概用了不到一个小时，就把这里全转了个遍，而且还是在我故意放慢脚步的情况下。总的来说，这里满足不了对大海的憧憬，充其量就算是个亲子乐园吧。最后放上拍的看起来还不错的图用以以后怀念这里吧，反正绝对不会再来第二次了。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 本地推送（通知）]]></title>
    <url>%2F2017%2F04%2F14%2FlocalNotification%2F</url>
    <content type="text"><![CDATA[以前一直迷惑，本地推送到底有什么用，后来仔细想了想，确实有用（废话，不然苹果爸爸干嘛开发这个？手动鄙视自己！） 本地通知服务 主要处理基于时间行为的通知。比如定时通知用户该起床撒尿了。 就是这么个用处！嗯，是这样吧？是的！ 在iOS10苹果废弃了之前的UILocalNotification，而采用了新的UserNotifications Framework来推送通知。现在先说一下iOS10之前的本地推送流程！ iOS 10之前注册通知123456789101112- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. if ([[UIDevice currentDevice].systemVersion floatValue] &gt; 8.0) &#123; UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil]; [application registerUserNotificationSettings:settings]; &#125; return YES;&#125; 发送通知123456789101112131415161718192021222324252627// 1.创建一个本地通知 UILocalNotification *localNote = [[UILocalNotification alloc] init]; // 1.1.设置通知发出的时间 localNote.fireDate = [NSDate dateWithTimeIntervalSinceNow:5]; // 1.2.设置通知内容 localNote.alertBody = @"这是一个本地推送"; // 1.3.设置锁屏时,字体下方显示的一个文字 localNote.alertAction = @"看我"; localNote.hasAction = YES; // 1.4.设置启动图片(通过通知打开的) localNote.alertLaunchImage = @"../Documents/1.jpg"; // 1.5.设置通过到来的声音 localNote.soundName = UILocalNotificationDefaultSoundName; // 1.6.设置应用图标左上角显示的数字 localNote.applicationIconBadgeNumber = 1; // 1.7.设置一些额外的信息 localNote.userInfo = @&#123;@"hello" : @"how are you", @"msg" : @"success"&#125;; // 2.执行通知 [[UIApplication sharedApplication] scheduleLocalNotification:localNote]; 这里要说一点，就是iOS系统限制了注册本地推送的数量，最大的注册量为64条。 接收推送 应用在前台或后台，未被杀死时。 1234567//程序处于前台或后台时调用- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification&#123; NSLog(@"333这里被调用"); UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"Title" message:@"程序在前台或后台，未被杀死，点击通知栏调用" delegate:self cancelButtonTitle:@"cancel" otherButtonTitles:@"ok", nil]; [alert show];&#125; 程序已被杀死时 1234567891011121314- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. if (launchOptions[UIApplicationLaunchOptionsLocalNotificationKey]) &#123; //添加处理代码 NSLog(@"666这里被调用"); UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"Title" message:@"程序已被杀死，点击通知栏调用" delegate:self cancelButtonTitle:@"cancel" otherButtonTitles:@"ok", nil]; [alert show]; &#125; return YES;&#125; iOS 10之后先导入这个东西#import &lt;UserNotifications/UserNotifications.h&gt; 注册通知1234567891011121314151617- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. // 使用 UNUserNotificationCenter 来管理通知 UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; //监听回调事件 center.delegate = self; //iOS 10 使用以下方法注册，才能得到授权 [center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert + UNAuthorizationOptionSound + UNAuthorizationOptionBadge) completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; // Enable or disable features based on authorization. &#125;]; return YES;&#125; 发送通知1234567891011121314151617181920// 使用 UNUserNotificationCenter 来管理通知 UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter]; //需创建一个包含待通知内容的 UNMutableNotificationContent 对象，注意不是 UNNotificationContent ,此对象为不可变对象。 UNMutableNotificationContent* content = [[UNMutableNotificationContent alloc] init]; content.title = [NSString localizedUserNotificationStringForKey:@"本地推送Title" arguments:nil]; content.body = [NSString localizedUserNotificationStringForKey:@"本地推送Body" arguments:nil]; content.sound = [UNNotificationSound defaultSound]; // 在 设定时间 后推送本地推送 UNTimeIntervalNotificationTrigger* trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO]; UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:@"FiveSecond" content:content trigger:trigger]; //添加推送成功后的处理！ [center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;]; 通知处理实现UNUserNotificationCenterDelegate代理方法: 第一个代理方法： 123456-(void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler&#123; // 处理完成后条用 completionHandler ，用于指示在前台显示通知的形式 completionHandler(UNNotificationPresentationOptionSound);&#125; 这个方法中的那句话就是，当应用在前台的时候，收到本地通知，是用什么方式来展现。系统给了三种形式： 12345typedef NS_OPTIONS(NSUInteger, UNNotificationPresentationOptions) &#123; UNNotificationPresentationOptionBadge = (1 &lt;&lt; 0), UNNotificationPresentationOptionSound = (1 &lt;&lt; 1), UNNotificationPresentationOptionAlert = (1 &lt;&lt; 2),&#125; 第二个代理方法： 这个方法是在后台或者程序被杀死的时候，点击通知栏调用的，在前台的时候不会被调用 1234567- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler&#123; UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"Title" message:@"message" delegate:self cancelButtonTitle:@"cancel" otherButtonTitles:@"ok", nil]; [alert show]; completionHandler();&#125;]]></content>
      <categories>
        <category>iOS 推送</category>
      </categories>
      <tags>
        <tag>本地推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UITableView的一些琐碎]]></title>
    <url>%2F2017%2F04%2F13%2FhandleUITableView%2F</url>
    <content type="text"><![CDATA[表格UITableView基本上开发中应用最常用的控件之一了，关于tableview你又了解多少呢，反正我是只知道一些常规的用法，现在把之前写过的项目中应用到的一些小细节总结一下。 cell分割线这个不知道是不是我自己的问题，第一次遇到要将cell分割线与屏幕边缘没有间距的需求时，试了好多方法！ 第一种方法下面的这个在Objective-C里写了没有什么效果，但在Swift中可以完美执行，我不知道是不是我一个人的问题。贴出来这个方法： 1tableView.separatorInset = UIEdgeInsetsZero; 第二种方法这个方法是在论坛里看到的，试了试，可以的。 12345- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123; cell.separatorInset = UIEdgeInsetsZero; cell.layoutMargins = UIEdgeInsetsZero;&#125; tableView的这个代理方法是在cell将要出现在屏幕的时候调用。但是这种方法和第一种方法有个什么问题呢？就是不能将tableView.separatorStyle设置为UITableViewCellSeparatorStyleNone,这样就导致了如果cell的个数不足以充满屏幕的话，会在cell的底部看到空余的cell分割线，这对于我这个强迫症是不能忍的，当然了也有解决办法，就是添加一句：tableView.tableFooterView = [UIView new];就OK了。 第三种方法自从在oc中知道第一种方法不能用之后，基本上我都在用这种方法，就是在自定义的cell里重新画线。 12345678910111213141516- (void)drawRect:(CGRect)rect &#123; [super drawRect:rect]; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [UIColor clearColor].CGColor); CGContextFillRect(context, rect); CGContextSetStrokeColorWithColor(context, [UIColor colorWithRed:225.0/255.0 green:225.0/255.0 blue:225.0/255.0 alpha:1.0].CGColor); CGContextStrokeRect(context, CGRectMake(0, 0, SCREEN_WIDTH, 0.5)); CGContextSetStrokeColorWithColor(context, [UIColor colorWithRed:225.0/255.0 green:225.0/255.0 blue:225.0/255.0 alpha:1.0].CGColor); CGContextStrokeRect(context, CGRectMake(0, rect.size.height-0.5, SCREEN_WIDTH, 0.5)); &#125; 重新绘制的话，可以设置分割线的颜色，长度，高度。 卡片式cell就是下面这种效果： 实现这种效果我已知的有三种效果： 第一种通过设置cell的contentView来间接实现，在cell的contentView的顶部或者底部留下一定的间距，这样就会有cell间就有间距的效果。但是这种方式在cell有点击效果的时候，会很明显的看出有分层，因为这时候cell是被点击的，contentView都会有系统点击的阴影效果。这种方式在cell左滑删除，置顶等操作的时候，左滑出的视图会高出一部分（左滑显示出的高度=（cell的高度-留下的间距高度）+ 留下的间距高度），很显然这种方式有致命缺陷。 建议还是不要第一种方法 第二种通过分组的方式间接的实现，每组的Header可以当做是cell之间的间距，每组中只有一个cell： 12345678910111213141516171819- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; return 10;&#125; - (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123; return 10;&#125; - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return 1;&#125; - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return 100;&#125; 但是呢，这还是会出现一个问题，因为系统默认分组的时候每组的Header会停留在tableview的顶部，这要怎么处理呢？网上也有一种解决办法: 123456789101112131415- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; if (scrollView == self.tableView) &#123; CGFloat sectionHeaderHeight = 10; if (scrollView.contentOffset.y &lt;= sectionHeaderHeight &amp;&amp; scrollView.contentOffset.y &gt;= 0) &#123; scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0); &#125; else if (scrollView.contentOffset.y &gt;= sectionHeaderHeight) &#123; scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0); &#125; &#125; &#125; 但是这种方式是通过scroll偏移量来监听和改变tableview的contentInset，因为只要UITableView在滚动就一直在运行，不是很好。 第三种重写cell的setFrame方法： 12345678- (void)setFrame:(CGRect)frame &#123; frame.origin.x = 15; frame.size.width -= 2 * frame.origin.x; frame.size.height -= 15; frame.origin.y += 10; [super setFrame:frame];&#125; 这种方式看上去很优雅，其实也有缺点，就是不适合有编辑的情况，因为在编辑的时候会不停调用setFrame方法，导致错乱，此时建议使用上面的第二种方案。]]></content>
      <categories>
        <category>iOS 实用</category>
      </categories>
      <tags>
        <tag>UItableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 常用操作之文件操作]]></title>
    <url>%2F2017%2F04%2F13%2FfileOperations%2F</url>
    <content type="text"><![CDATA[在项目开发中，不可避免的会遇到将一些东西存到本地，或者在本地创建新的文件或文件夹，特地在此总结了一下。 文件操作获取Documents文件夹路径123456789/*** 获取Documents文件夹路径** @return 文件夹路径*/+ (NSString *)getDocumentsFolderPath&#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); return [paths objectAtIndex:0];&#125; 获取Documents文件路径1234567891011/*** 获取Documents文件路径** @param fileName 文件名称** @return 文件路径*/+ (NSString *)getDocumentsFilePath:(NSString *)fileName&#123; return [[self getDocumentsFolderPath] stringByAppendingPathComponent:fileName];&#125; 获取一个目录所占的空间大小1234567891011121314151617/*** 获取一个目录所占的空间大小** @param filePath 文件目录路径** @return 目录空间大小*/+ (long long)fileSizeAtPath:(NSString*) filePath&#123; NSFileManager* manager = [NSFileManager defaultManager]; if ([manager fileExistsAtPath:filePath])&#123; return [[manager attributesOfItemAtPath:filePath error:nil] fileSize]; &#125; else&#123; return 0; &#125;&#125; 文件是否存在123456789/*文件是否存在*/ + (BOOL)isFileExisted:(NSString *)fileName&#123; NSFileManager *fileManager = [NSFileManager defaultManager]; if(![fileManager fileExistsAtPath:[self getFilePath:fileName]])&#123; return NO; &#125; return YES; &#125; 创建指定名字的文件12345678910111213/*创建指定名字的文件*/ + (BOOL)createFileAtPath:(NSString *)fileName&#123; NSArray *array = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *path = [[array objectAtIndex:0] stringByAppendingPathComponent:fileName]; NSLog(@"-----%@:", path); NSFileManager *fileManager = [NSFileManager defaultManager]; if(![fileManager fileExistsAtPath:path])&#123; [fileManager createFileAtPath:path contents:nil attributes:nil]; return YES; &#125; return NO; &#125; 创建指定名字的文件夹1234567891011121314/*创建指定名字的文件夹*/ + (BOOL)createDirectoryAtPath:(NSString *)fileName&#123; NSArray *array = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *path = [[array objectAtIndex:0] stringByAppendingPathComponent:fileName]; NSLog(@"-----%@:", path); NSFileManager *fileManager = [NSFileManager defaultManager]; if(![fileManager fileExistsAtPath:path])&#123; NSError *error = nil; [fileManager createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:&amp;error]; return YES; &#125; return NO; &#125; 删除文件123456789101112+ (BOOL)deleteFileAtPath:(NSString *)fileName&#123; NSArray *array = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *path = [[array objectAtIndex:0] stringByAppendingPathComponent:fileName]; NSFileManager *fileManager = [NSFileManager defaultManager]; if(![fileManager fileExistsAtPath:path])&#123; return NO; &#125; [fileManager removeItemAtPath:path error:nil]; return YES; &#125; NSUserDefaults保存和取出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/**保存@param value &lt;#value description#&gt;@param key &lt;#key description#&gt;*/+(void)saveValue:(id) value forKey:(NSString *)key&#123; NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; [userDefaults setObject:value forKey:key]; [userDefaults synchronize];&#125;/**取出@param key &lt;#key description#&gt;@return &lt;#return value description#&gt;*/+(id)valueForKey:(NSString *)key&#123; NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; return [userDefaults objectForKey:key];&#125;/**根据key取出NSString的value@param key &lt;#key description#&gt;@return &lt;#return value description#&gt;*/+(id)StringForKey:(NSString *)key&#123; NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; return [userDefaults stringForKey:key];&#125;/**根据key取出Bool型的值@param key &lt;#key description#&gt;@return &lt;#return value description#&gt;*/+(BOOL)boolValueForKey:(NSString *)key&#123; NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; return [userDefaults boolForKey:key];&#125;/**保存Bool型的值@param value value@param key key*/+(void)saveBoolValue:(BOOL)value forKey:(NSString *)key&#123; NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; [userDefaults setBool:value forKey:key]; [userDefaults synchronize];&#125;/**获取userDefaults存储的所有信息*/+(void)printAllUserDefault&#123; NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; NSDictionary *dic = [userDefaults dictionaryRepresentation]; NSLog(@"%@",dic);&#125;]]></content>
      <categories>
        <category>iOS 实用</category>
      </categories>
      <tags>
        <tag>本地存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swiftOptional]]></title>
    <url>%2F2017%2F04%2F07%2FswiftOptional%2F</url>
    <content type="text"><![CDATA[学习swift的过程中不可避免的会遇到？或！这种东西，这就是今天要说的可选型（Optional)了。大家都知道，swift是苹果官方推出的一款较于Objective-C安全性较高的语言，而可选型就是swift最为突出的特性之一。 Optional是什么？Optional 是 Swift 新加入的类型。可选型的意思简单理解是：有值得时候就有值，无值的时候就是 nil 。Swift 中的 nil 和其他语言中的 nil 还有些不一样，nil 自己本身就是一种类型，没有就是 nil ，是和其他类型严格区分开的。可选型的定义很简单：类型 + ? 。比如 String?、Int?、Float? 等，这里需要注意的是 String? 和 String 是完全不同的两个类型，前者是 String 类型的可选型，后者是 String 类型，注意区分。举个例子，在 OC 中我们可以这样写: 12NSString *name = @"jack";name = nil; 而在swift中如果像下面这种写法是会报错的： 123//这种写法是会报错的，说的是 nil 是不可以分配给 String 类型的，这也说明在 swift 中 nil 是和其他类型严格区分的。var name: String = "jack"name = nil 改为可选型之后就可以了，像下面这样： 12var name: String? = "name"name = nil 可选型，顾名思义就是可以选择，比如 String? 的意思就是可以在 String 和 nil 之间选择，可以是 String 也可以是 nil 。如果一个变量定义成 String，那么这个变量就会是 String 类型，而不可能是nil。 还有一点需要注意的是声明可选型必须是显示的声明也就是必须是 1var name: String? = nil 而不能是： 1var name = nil 这样，因为 Swift 在做类型判断的时候无法判断 name 到底是 String 类型的可选型还是其他类型的可选型，因此会导致编译错误。 Tips: 当然枚举类型的写法还可以如 12&gt; var name: Optional&lt;String&gt; = Optional.Some("Loveway")&gt; 这样，只不过我们一般都用 12&gt; var name: String? = nil&gt; 这样的简写。 Optional的解包可选型是不能够被直接使用的（因为 Swift 是类型安全的，可选型的值又可能会是 nil，如果不做处理可能导致程序 crash），如果我们想使用可选型的值，那么在这之前我们需要做的一项工作就是：解包（unwarp）！ 1.强制解包 所谓的强制解包意思就是我知道这个类型是可选型，但是在我的程序执行到这里的时候我可以保证它是有值得，所以我要在这里使用它。具体表现形式就是在可选型后面加个 !，如下: 12var name: String? = "jack"print("My name is " + name!) 但是这样的解包是不安全，因为你不知道什么时候你的这个可选型就会变成 nil，如果我们代码非常多的话，一不小心为 nil了，可能会导致程序崩溃。这个时候我们会想到一种方法：判空！如下: 123456var name: String? = "loveway"if name != nil &#123; print("My name is " + name!)&#125; else &#123; print("name is nil")&#125; 这样写似乎是没有什么问题了，但是需要注意的是，你在判断非 nil 的作用域内使用 name 的时候还必须把 ! 带上，这样代码比较多的时候还是比较麻烦。于是我们可以使用下面这种方式: 2.使用 if let 解包 如下： 123456var name: String? = "jack"if let name = name &#123; print("My name is " + name)&#125; else &#123; print("name is nil")&#125; 这种解包方式可以保证 name 是解包过的，不会再是 nil 这种情况，其实逻辑是和上面做非空判断一样的。当然你把 let 换成 var 也是可以的，效果是一样的，只不过我们一般要用的是解包后的值，而不会去改变它，所以平常使用中一般都是用 if let 。 同时 if let 可以同时一次性解包多个可选型，用 , 隔开，使语句简洁，如下: 1234567var name: String? = "loveway"var age: Int? = 18if let name = name, age = age &#123; print("My name is " + name + "My age is" + "\(age)")&#125; else &#123; print("name is nil")&#125; 最后，既然这里使用的是 if ，那么同样我们可以如下这样用，来进行进一步的判断筛选: 1234567var name: String? = "loveway"var age: Int? = 18if let name = name, age = age where age == 18 &#123; print("My name is \(name), age is \(String(age))")&#125; else &#123; print("name is nil")&#125; 可选链式调用（Optional Chaining）可选链式调用（Optional Chaining）是一种可以在当前值可能为 nil 的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功，如果可选值是 nil ，那么调用将返回 nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为 nil ，整个调用链都会失败，即返回 nil 。 下面我们就来举个例子具体说明可选链，如下: 123456var name: String? = "loveway"if let name = name &#123; print(name.uppercaseString)&#125; else &#123; print("name is nil")&#125; 我们来解包 name ，如果有值就打印出 name 的大写，如果没有就输出 name is nil ，其实上面这段代码完全等同于: 12var name: String? = "loveway"name?.uppercaseString 上面这句代码的意思就是如果可选型变量 name 有值，那么就对 name 进行解包，并得到 name 的uppercaseString 值，如果没有，那么这句代码就会返回一个 nil 。这样就符合 Swift 的类型安全，完全是没有问题的。但是如果你写成: 12var name: String? = "loveway"name!.uppercaseString 也是可以的，不过不安全，因为如果 name 没有值，你进行强制解包，就会报错。 所以我们以后可能会用到类似于 person?.name?.uppercaseString 这样的一层层解包的，这种就是可选链。 Nil Coalescing Operator（空合运算符）如上，如果我们想把解包后的值存起来的话，可以这样: 1let newName = name == nil ? "no name" : name! 上面代码的意思就是如果 name 为 nil ，newName 就是 “no name”，否则 newName 就是 name!（name的解包）。其实 Swift 为我们提供了更简洁的语法，如下: 1let newName2 = name ?? "no name" 上面代码的意思就是 name 如果有值 newName2 的值就是 name! ,否则就是 no name 。这里需要注意的是 ??是空合运算符，这样写的可阅读性强，比较简洁。 当然关于 ?? 远不止这些，有兴趣的同学可以看 聊聊swift语言中的“??” 这篇文章。 隐式可选型上面我们都知道了，创建一个显示可选型是: 类型 + ?。这里创建隐式可选型的就是： 类型 + !。 1var name: String! = "loveway" 这里可能有的童鞋会疑惑，已经有了显示的可选型，为什么还需要有隐式的可选型。这里其实隐式的可选型也是有一定作用的。比如你有一个变量，声明为隐式的可选型（!），它的作用就是，当你这个类没有被初始化的时候他是没有值的，但是当你这个类初始化以后，你可以确保他是有值的，所以这里声明为隐式的可选型，而不是显示的。同样需要注意的是隐式的可选型也是可选型，如果你需要用它的值，你也是要进行判断的。如果不进行判断而直接使用，可能会造成不可预料的后果！差不多可选型就到这里了，如果还有什么遗漏，欢迎大家指正！ 转自重读 Swift 之一：Optional（可选型）]]></content>
      <categories>
        <category>swift学习笔记</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 Swift 中的 map 和 flatMap]]></title>
    <url>%2F2017%2F04%2F06%2FswiftMapAndFlatMap%2F</url>
    <content type="text"><![CDATA[map 和 flatMap 是 Swift 中两个常用的函数，它们体现了 Swift 中很多的特性。对于简单的使用来说，它们的接口并不复杂，但它们内部的机制还是非常值得研究的，能够帮助我们够好的理解 Swift 语言。 map 简介首先，咱们说说 map 函数如何使用。 123let numbers = [1,2,3,4]let result = numbers.map &#123; $0 + 2 &#125;print(result) // [3,4,5,6] map 方法接受一个闭包作为参数， 然后它会遍历整个 numbers 数组，并对数组中每一个元素执行闭包中定义的操作。 相当于对数组中的所有元素做了一个映射。 比如咱们这个例子里面的闭包是讲所有元素都加 2 。 这样它产生的结果数据就是 [3,4,5,6]。 初步了解之后，我们来看一下 map 的定义： 1func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T] 咱们抛开一些和关键逻辑无关的修饰符 @noescape,throws 这些，在整理一下就是这样： 1func map&lt;T&gt;(transform: (Self.Generator.Element) -&gt; T) rethrows -&gt; [T] map 函数接受一个闭包， 这个闭包的定义是这样的： 1(Self.Generator.Element) -&gt; T 它接受 Self.Generator.Element 类型的参数， 这个类型代表数组中当前元素的类型。 而这个闭包的返回值，是可以和传递进来的值不同的。 比如我们可以这样： 12let stringResult = numbers.map &#123; "No. \($0)" &#125;// ["No. 1", "No. 2", "No. 3", "No. 4"] 这次我们在闭包装把传递进来的数字拼接到一个字符串中， 然后返回一个组数， 这个数组中包含的数据类型，就是我们拼接好的字符串。 这就是关于 map 的初步了解， 我们继续来看 flatMap。 flatMapmap 可以对一个集合类型的所有元素做一个映射操作。 那么 flatMap 呢？ 让我们来看一个 flatMap 的例子： 12result = numbers.flatMap &#123; $0 + 2 &#125;// [3,4,5,6] 我们对同样的数组使用 flatMap 进行处理， 得到了同样的结果。 那 flatMap 和 map 到底有什么区别呢？ 咱们再来看另一个例子： 12345let numbersCompound = [[1,2,3],[4,5,6]];var res = numbersCompound.map &#123; $0.map&#123; $0 + 2 &#125; &#125;// [[3, 4, 5], [6, 7, 8]]var flatRes = numbersCompound.flatMap &#123; $0.map&#123; $0 + 2 &#125; &#125;// [3, 4, 5, 6, 7, 8] 这里就看出差别了。 对于二维数组， map 和 flatMap 的结果就不同了。 我们先来看第一个调用： 12var res = numbersCompound.map &#123; $0.map&#123; $0 + 2 &#125; &#125;// [[3, 4, 5], [6, 7, 8]] numbersCompound.map { ... } 这个调用实际上是遍历了这里两个数组元素 [1,2,3] 和 [4,5,6]。 因为这两个元素依然是数组，所以我们可以对他们再次调用 map 函数：$0.map{ $0 + 2 }。 这个内部的调用最终将数组中所有的元素加 2。 再来看看 flatMap 的调用： 12var flatRes = numbersCompound.flatMap &#123; $0.map&#123; $0 + 2 &#125; &#125;// [3, 4, 5, 6, 7, 8] flatMap 依然会遍历数组的元素，并对这些元素执行闭包中定义的操作。 但唯一不同的是，它对最终的结果进行了所谓的 “降维” 操作。 本来原始数组是一个二维的， 但经过 flatMap 之后，它变成一维的了。 flatMap 是如何做到的呢，它的原理是什么，为什么会存在这样一个函数呢？ 相信此时你脑海中肯定会浮现出类似的问题。 下面咱们再来看一下 flatMap 的定义, 还是抛去 @noescape, rethrows 这些无关逻辑的关键字： 12func flatMap&lt;T&gt;(transform: (Self.Generator.Element) throws -&gt; T?) -&gt; [T]func flatMap&lt;S : SequenceType&gt;(transform: (Self.Generator.Element) -&gt; S) -&gt; [S.Generator.Element] 和 map 不同， flatMap 有两个重载。 参照我们刚才的示例， 我们调用的其实是第二个重载： 1func flatMap&lt;S : SequenceType&gt;(transform: (Self.Generator.Element) -&gt; S) -&gt; [S.Generator.Element] flatMap 的闭包接受的是数组的元素，但返回的是一个 SequenceType 类型，也就是另外一个数组。 这从我们刚才这个调用中不难看出： 1numbersCompound.flatMap &#123; $0.map&#123; $0 + 2 &#125; &#125; 我们传入给 flatMap 一个闭包 $0.map{ $0 + 2 } , 这个闭包中，又对 $0 调用了 map 方法， 从 map 方法的定义中我们能够知道，它返回的还是一个集合类型，也就是 SequenceType。 所以我们这个 flatMap 的调用对应的就是第二个重载形式。 那么为什么 flatMap 调用后会对数组降维呢？ 我们可以从它的源码中窥探一二（Swift 不是开源了吗~）。 1234567891011121314151617extension Sequence &#123; //... public func flatMap&lt;S : Sequence&gt;( @noescape transform: ($&#123;GElement&#125;) throws -&gt; S ) rethrows -&gt; [S.$&#123;GElement&#125;] &#123; var result: [S.$&#123;GElement&#125;] = [] for element in self &#123; result.append(contentsOf: try transform(element)) &#125; return result &#125; //... &#125; 这就是 flatMap 的完整源码了， 它的源码也很简单， 对遍历的每一个元素调用 try transform(element)。 transform 函数就是我们传递进来的闭包。 然后将闭包的返回值通过 result.append(contentsOf:) 函数添加到 result 数组中。 那我们再来看一下 result.append(contentsOf:) 都做了什么， 它的文档定义是这样： Append the elements of newElements to self. 简单说就是将一个集合中的所有元素，添加到另一个集合。 还以我们刚才这个二维数组为例： 123let numbersCompound = [[1,2,3],[4,5,6]];var flatRes = numbersCompound.flatMap &#123; $0.map&#123; $0 + 2 &#125; &#125;// [3, 4, 5, 6, 7, 8] flatMap 首先会遍历这个数组的两个元素 [1,2,3] 和 [4,5,6]， 因为这两个元素依然是数组， 所以我们可以对他们再进行 map 操作： $0.map{ $0 + 2 }。 这样， 内部的 $0.map{ $0 + 2 } 调用返回值类型还是数组， 它会返回 [3,4,5] 和 [6,7,8]。 然后， flatMap 接收到内部闭包的这两个返回结果， 进而调用 result.append(contentsOf:) 将它们的数组中的内容添加到结果集中，而不是数组本身。 那么我们最终的调用结果理所当然就应该是 [3, 4, 5, 6, 7, 8] 了。 仔细想想是不是这样呢\~ flatMap 的另一个重载我们刚才分析了半天， 其实只分析到 flatMap 的一种重载情况， 那么另外一种重载又是怎么回事呢： 1func flatMap&lt;T&gt;(transform: (Self.Generator.Element) -&gt; T?) -&gt; [T] 从定义中我们看出， 它的闭包接收的是 Self.Generator.Element 类型， 返回的是一个 T? 。 我们都知道，在 Swift 中类型后面跟随一个 ?， 代表的是 Optional 值。 也就是说这个重载中接收的闭包返回的是一个 Optional 值。 更进一步来说，就是闭包可以返回 nil。 我们来看一个例子： 123let optionalArray: [String?] = ["AA", nil, "BB", "CC"];var optionalResult = optionalArray.flatMap&#123; $0 &#125;// ["AA", "BB", "CC"] 这样竟然没有报错， 并且 flatMap 的返回结果中， 成功的将原数组中的 nil 值过滤掉了。 再仔细观察，你会发现更多。 使用 flatMap 调用之后， 数组中的所有元素都被解包了， 如果同样使用 print 函数输出原始数组的话， 大概会得到这样的结果: 1[Optional("AA"), nil, Optional("BB"), Optional("CC")] 而使用 print 函数输出 flatMap 的结果集时，会得到这样的输出： 1["AA", "BB", "CC"] 也就是说原始数组的类型是 [String?] 而 flatMap 调用后变成了 [String]。 这也是 flatMap 和 map 的一个重大区别。 如果同样的数组，我们使用 map 来调用， 得到的是这样的输出： 1[Optional("AA"), nil, Optional("BB"), Optional("CC")] 这就和原始数组一样了。 这两者的区别就是这样。 map 函数值对元素进行变换操作。 但不会对数组的结构造成影响。 而 flatMap 会影响数组的结构。再进一步分析之前，我们暂且这样理解。 flatMap 的这种机制，而已帮助我们方便的对数据进行验证，比如我们有一组图片文件名， 我们可以使用 flatMap 将无效的图片过滤掉： 12var imageNames = ["test.png", "aa.png", "icon.png"];imageNames.flatMap&#123; UIImage(named: $0) &#125; 那么 flatMap 是如何实现过滤掉 nil 值的呢？ 我们还是来看一下源码： 123456789101112131415161718extension Sequence &#123; // ... public func flatMap&lt;T&gt;( @noescape transform: ($&#123;GElement&#125;) throws -&gt; T? ) rethrows -&gt; [T] &#123; var result: [T] = [] for element in self &#123; if let newElement = try transform(element) &#123; result.append(newElement) &#125; &#125; return result &#125; // ... &#125; 依然是遍历所有元素，并应用 try transform(element) 闭包的调用， 但关键一点是，这里面用到了 if let 语句， 对那些只有解包成功的元素，才会添加到结果集中: 123if let newElement = try transform(element) &#123; result.append(newElement)&#125; 这样， 就实现了我们刚才看到的自动去掉 nil 值的效果了。 结尾关于 Swift 中的 map 和 flatMap， 看完这篇内容是不会会对你有所启发呢。 当然， 关于这两个函数我们这里并没有完全讨论完。 它们背后还有着更多的思想。 关于本篇文章的代码，大家还可以来 Github 上面 参看. 转自：https://www.swiftcafe.io/2016/03/28/about-map/?utm\_source=tuicool&amp;utm\_medium=referral]]></content>
      <categories>
        <category>swift学习笔记</category>
      </categories>
      <tags>
        <tag>map</tag>
        <tag>flatMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雨夜]]></title>
    <url>%2F2017%2F03%2F31%2FrainNight%2F</url>
    <content type="text"><![CDATA[这是一个夜，一个下雨的夜。 我喜欢此时此刻的气氛，一个人窝在被窝里，窗外淅淅沥沥的雨滴敲打着窗户上的玻璃，正应了那句话“大珠小珠落玉盘”。房间里很安静，安静的只能听到自己的呼吸声，窗外时不时的传来一声汽车呼啸而过的声音。这种环境，这种氛围，让我觉得很舒服，恰到好处。 一个人在这种环境下，思想会变得格外的清晰和明朗，会想明白很多一直想不明白的问题。于我自己而言，喜欢黑夜甚于白天。尤其是这样的一个静谧的夜。 上海的生活节奏快的可怕，初来乍到之时，手忙脚乱，慌不择路。慢慢的习惯了这种生活，喜欢在一片喧嚣之中觅得一方清幽之所，独处，享受。 一个人生活，有好处，也有坏处。好处就是可以经常反思自己，可以依靠自己来约束自己。坏处就是缺少与人交流，没有交流，进步就会异常缓慢。就现在来说，我还挺满意自己如今的生活状态，虽说朝九晚五，但也是异常充实，知道每天需要做些什么来填补自己。年龄在一天天的增长，我要做的就是让经历，经验，学识都要与之增长。 本来说好了，这不是一篇鸡汤文，但写着写着，总想写一些话来安慰或鼓励自己一下。学而不思则罔，思而不学则殆。快节奏的生活中，会思考显得弥足珍贵。我们不要只顾风雨兼程，还要时不时的停下来，审视自己。以人为镜，正己。 夜，是思绪放飞的时刻。会想到一些人，会想到一些事。想昨天，想明天。想一切能想到的。思想的触角漫无边际，任其四通八达，通向未来。 窗外的雨还在淅淅沥沥的下着，夜已深。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极光推送开发环境可以收到,生产环境收不到推送]]></title>
    <url>%2F2017%2F03%2F30%2Fjpush%2F</url>
    <content type="text"><![CDATA[首先阐述一下我遇到的问题： 我们项目连通了极光推送，以前写过的项目也是这样，在开发环境下测试，好使了，但是打包ADHoc时候，就不好使了，当时也没在意，因为网上好多人说，只要测试好使了，证书显示配置成功了（绿灯），那就没问题了。 so，上线，然后上线以后，发现推送功能完全不好使！这就尴尬了，赶紧下架。 因为我们项目使用的是别名推送，使用极光网站推送时候，我使用了广播，别名推送，regID推送，结果 都能收到（开发环境）；然后我在生产环境－－－－－＞再次发送－－－－－＞广播，别名，regID，结果，很显然，别名收不到，这就纠结了，开始查看问题吧。 经过两天的爬坑，终于找到了问题所在，也正在积极解决。在这里再次感谢极光官方两位大牛，如果没有你们的帮忙，我想我还会纠结好久。 Lris12 Helperhaps 好了，废话少说，阐述问题跟代码 初次发现这个问题的时候，首先排查的就是证书配置，这里再次建议大家好好仔细的看看开发文档，因为很多错误都是细节处不注意造成的，附上开发文档地址。因为这个项目是接手别人已经做得差不多的，我就负责收尾，所以，证书这方面我会优先查看，是否错误。 在developer.apple.com 中，我已经看到 很明显，开发环境的证书跟生产环境的证书，都已经配置完成，那么证书是没有问题的，下面我们看看极光官网的配置： 也是已验证，这就奇怪了，到这，我表示，可能是代码出错了，好吧，我们来看代码。 别名设置，相信在官方文档中大家都明白怎么写。反复查看文档，我发现并没有任何问题这么写。经过跟 Lris12 大神的交流，觉得很可能是因为网络原因，在注册极光还没有返回成功的时候，就绑定别名，导致regID跟别名没有绑定成功。 解决方法： 添加5个监听，在监听到extern NSString * const kJPFNetworkDidLoginNotification; // 登录成功，之后再设置别名。 极光集成指南 Ps：这里强烈建议这么写，安全第一 安全第一！！！ 这里附上代码： 1234567891011- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123;NSNotificationCenter *defaultCenter = [NSNotificationCenter defaultCenter];[defaultCenter addObserver:self selector:@selector(networkDidReceiveMessage:) name:kJPFNetworkDidLoginNotification object:nil];[JPUSHService registerDeviceToken:deviceToken];&#125; //通知方法 12345678910111213- (void)networkDidReceiveMessage:(NSNotification *)notification &#123;[JPUSHService setTags:nil aliasInbackground:[OpenUDID value]];dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;[JPUSHService setTags:nil alias:[OpenUDID value] fetchCompletionHandle:^(int iResCode, NSSet *iTags, NSString *iAlias)&#123;&#125;];&#125;); //销毁通知： 123[[NSNotificationCenter defaultCenter] removeObserver:self name:kJPFNetworkDidLoginNotification object:nil];&#125; 然而，问题依旧没有解决，但是这个时候，我们登录极光官网推送。我在生产环境，再次发送，广播，别名，regID，结果，都收到了！！正当我高兴的时候，发现 api推送依旧收不到！！收不到！！绝望！！ 继续排查！！！按照开发文档，设置xcode配置，嗯 ，依旧没用。 这里我重点说一下 ：iOS9 之后 卸载重装后会改变token，所以registrationID会改变，如果你没有用到idfa。如果你的项目使用的是regID推送，那么你要注意，每次更新app，新用户下载app，重新下载app等一系列状况下，regID改变的问题。还有如果注册成功后，会返回，设置成功，有callback为0。这个也要注意下。 好，回归正题。这时候时间已经过去一天半了， 最后我觉得，我所有的代码，配置，证书，环境，都没有问题！再去极光官网看看，到底咋回事。 好吗 这一看 终于发现了问题所在！ 大家看没看到，这里写的是推送平台iOS-dev？卧槽！！后台给我推送的居然是开发环境！！果断找后台理论！！！ Lris大神告诉我：「发布版本后无法有效推送」 or 「生产环境下收不到消息」 按以下步骤排查问题： 客户端－－－－＞客户端是否打包证书－－－－＞检查当前环境是否正确－－－－－＞设备里面的手机应用有没有添加/配置这个tag/ 别名－－－＞服务端注意改变环境参数，option的apns_production的值（true：生产）（false开发）。根据客户端环境改变服务端推送环境。环境要一致才能收到推送。 然后我们后台给我发送了一段代码 堵住了我的嘴： 12345$platform = 'android,ios' ;$msg_content = json_encode(array('n_builder_id'=&gt;0, 'n_title'=&gt;$n_title, 'n_content'=&gt;$n_content,'content-available'=&gt;1,'apns_production'=&gt;1));$obj = new jpush($masterSecret,$appkeys); 我标红的位置，人家已经设置了1，为什么还不好用？经过Helperhaps大神的解释，好吧，我懂了！我们后台使用的过期的V2 api。 特别提示：建议不要在客户端里写代码直接调用此 API。因为 Android apk 比较容易破解，别人很容易从客户端代码里找出来调用 JPush Remote API 所需要的保密信息，从而可以模拟到你的身份来发起恶意的推送。 建议的使用方式是：调用 JPush Remote API 的代码放在你自己的应用服务器上。你自己的应用服务器对自己的客户端提供接口来推送消息。具体请参考推聊的作法：示例与代码。 升级到 v3 Push API：建议开发者升级到 v3 版本。此版本会继续支持到 2015 年。至此，这个问题才算是解决（至少对前端来说）。第一次发这样的帖子感觉有点乱 嗯。。。 下次大家在推送上有问题的话。。先看开发文档走一遍流程，然后看看极光个人推送，广播能否收到，然后就可以考虑跟服务端干一仗了！！ 最后祝大家 永无BUG！！！！！！！！！！！！！ 转自：http://www.jianshu.com/p/0d382c4d98ff]]></content>
      <categories>
        <category>iOS 推送</category>
      </categories>
      <tags>
        <tag>jpush</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native 奇葩报错]]></title>
    <url>%2F2017%2F03%2F22%2FrnPortCrash%2F</url>
    <content type="text"><![CDATA[刚写了一个react-native小demo，完美运行，心中窃喜，于是关闭项目。过了一会儿，想再一睹刚才如行云流水般运行的项目，于是，运行，结果……纳尼？出现了一片姨妈红有没有？心中一万头草泥马呼啸而过有没有？到底发生了什么？ NA！阿sir啊，我说了我没动过代码啦，出现下面这种错误不关我的事啊：12ProjectName has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent. 分析错误原因： 1.第一种情况：程序入口处项目名称不一致。检查发现： 1AppRegistry.registerComponent('ProjectName', () =&gt; ProjectName); 一模一样！为了担心怕自己的眼睛看到的不是真实的，特地粘贴复制了一遍！ 第一种情况排除！ 2.第二种情况8081端口被占用 检验方法：到项目根目录下---------&gt;&gt;&gt;打开终端---------&gt;&gt;&gt;输入命令行：react-native start 如果出现了Packager can&#39;t listen on port 8081,好的恭喜你，找到了症结所在，下面就是根据提示来就好了： .lsof -i : 8081 //列出被占用的端口 .kill -9 &lt; PID &gt; //找出与之对应的PID，杀死就ok了 .重新运行项目 .依旧完美]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
      <tags>
        <tag>8081port</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native 之index.ios.js解读]]></title>
    <url>%2F2017%2F03%2F22%2FexplainIndexiosjs%2F</url>
    <content type="text"><![CDATA[撸代码之前还是要搞清楚作用比较好，不然洋洋洒洒的撸了个天昏地暗，却不知道为什么用这个姿势撸，不就尴尬了吗？要知其然，还要知其所以然，论掌握撸代码姿势的重要性！ React.native是facebook开源的一套基于JavaScript的开源框架，很方便用来开发移动设备的app。 而且，方便及时更新app的UI与数据，也很方便部署。在react-native的ios项目中，界面搭建部分是一个js文件：index.ios.js。下面对这个文件进行一下解读，方便后续开发中明白各个部分的作用。 1、引用React1import React, &#123; Component &#125; from 'react'; 2、控件的引入12345678import &#123; AppRegistry, StyleSheet, Text, View, ListView, TouchableOpacity&#125; from 'react-native'; 3、样式设置12345678910111213141516171819//设置样式const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, welcome: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;, instructions: &#123; textAlign: 'center', color: '#333333', marginBottom: 5, &#125;,&#125;); 作用：定义了一段应用在 “Hello World” 文本上的样式。 React Native 使用 CSS 来定义应用界面的样式。 4、创建React组件对应的类123456789101112131415161718export default class HelloWorld extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Welcome to React Native! &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; To get started, edit index.android.js &lt;/Text&gt; &lt;Text style=&#123;styles.instructions&#125;&gt; Double tap R on your keyboard to reload,&#123;'\n'&#125; Shake or press menu button for dev menu &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 作用：描述将要创建的组件，包括各种行为和属性。 5、解释一下 组件渲染的方法 123render() &#123; return ();&#125; 注意：只有当组件被渲染时，必须实现render接口方法，因为，只有render方法，是用于输出内容组件内容的；其他接口方法，都是可选的。 标签定义视图 12&lt;View style=&#123;styles.container&#125;&gt;&lt;/View&gt; 作用：设置显示区域，相当于iOS中的UIView控件（Objective-c和Swift） 标签定义文本 123&lt;Text style=&#123;styles.welcome&#125;&gt;Welcome to React Native!&lt;/Text&gt; 作用：设置并显示字符串，相当于iOS的UILabel控件（Objective-c和Swift）。 定义程序入口 1AppRegistry.registerComponent('HelloWorld', () =&gt; HelloWorld); 作用：用AppRegistry的registerComponent( )方法，定义了App的入口，并提供了根组件。 转自：http://blog.csdn.net/maoyingyong/article/details/46439951]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
      <tags>
        <tag>index.ios.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native 之ListView]]></title>
    <url>%2F2017%2F03%2F22%2Freact-native-listView%2F</url>
    <content type="text"><![CDATA[最近在摸索react-native，虽然苹果爸爸已经在之前封杀了JSPatch，我还是抱着试一试的态度先学一个疗程，毕竟，知识嘛，多学点总是好的。 其实对于js我了解的不多，所以一些东西给不了相应的解释，还请见谅（ps：我的学习阶段都是从模仿开始的）。后面我会不断的学习基础知识，把相应的解释会添加上去的。见笑了！ 接下来先学习一下如何创建一个ListView。 1.设置样式上代码： 12345678910111213141516171819202122232425262728293031323334353637//设置样式const styles = StyleSheet.create(&#123;//整个listView的样式设置outerViewStyle: &#123;//占满窗口flex: 1&#125;,//一个自定义view的样式设置headerViewStyle: &#123;height: 64,backgroundColor: 'orange',justifyContent: 'center',alignItems: 'center'&#125;,//列表row的样式设置rowStyle: &#123;//设置主轴的方向flexDirection: 'row',//侧轴方向居中alignItems: 'center',padding: 10,//单元格底部的线设置borderBottomColor: '#e8e8e8',borderBottomWidth: 0.5&#125;,//分区头部view的样式设置sectionHeaderViewStyle: &#123;backgroundColor: '#e8e8e8',justifyContent: 'center',height: 25&#125;&#125;); 以上就是本listView能用到的一些设置。 2.获取数据用到的数据是本地的json数据 1234567891011121314151617181920212223242526272829303132333435363738394041//调取数据componentDidMount()&#123;this.loadDataFromJson();&#125;,var Car = require('./Car.json');loadDataFromJson()&#123;//获取json数据var jsonData = Car.data;//定义一些变量var dataBlob = &#123;&#125;,sectionIDs = [],rowIDs = [],cars = [];for (var i = 0; i &lt; jsonData.length; i++) &#123;//1.把区号放入sectionIDs数组中sectionIDs.push(i);//2.把区中的内容放入dataBlob对象中dataBlob[i] = jsonData[i].title;//3.取出该组中所有的车cars = jsonData[i].cars;rowIDs[i] = [];//遍历所有的车数组for (var j = 0; j &lt; cars.length; j++) &#123;//1.把行号放入rowIDs[i]中rowIDs[i].push(j);//2.把每一行的内容放入dataBlob对象中dataBlob[i + ':' + j] = cars[j];&#125;&#125;//更新状态this.setState(&#123;dataSource: this.state.dataSource.cloneWithRowsAndSections(dataBlob,sectionIDs,rowIDs)&#125;);&#125;, 3.初始化函数123456789101112131415161718192021222324252627282930//初始化函数getInitialState()&#123;//配置区数据var getSectionData = (dataBlob,sectionID) =&gt; &#123;return dataBlob[sectionID];&#125;;//配置行数据var getRowData = (dataBlob,sectionID,rowID) =&gt; &#123;return dataBlob[sectionID + ':' +rowID];&#125;;return &#123;dataSource : new ListView.DataSource(&#123;getSectionData: getSectionData,//获取区中的数据getRowData: getRowData,//获取行中的数据rowHasChanged: (r1,r2) =&gt; r1 !== r2,sectionHeaderHasChanged: (s1,s2) =&gt; s1 !== s2&#125;)&#125;&#125;,render() &#123;return (&lt;ListView /&gt;);&#125;, 4.配置数据123456789101112131415161718// 每一行的数据renderRow(rowData)&#123;return(&lt;TouchableOpacity activeOpacity=&#123;0.5&#125;&gt;&lt;View style=&#123;styles.rowStyle&#125;&gt;&lt;Text style=&#123;&#123;marginLeft:5&#125;&#125;&gt;&#123;rowData.name&#125;&lt;/Text&gt;&lt;/View&gt;&lt;/TouchableOpacity&gt;);&#125;,renderSectionHeader(sectionData,sectionID) &#123;return(&lt;View style=&#123;styles.sectionHeaderViewStyle&#125;&gt;&lt;Text style=&#123;&#123;marginLeft:5,color:'red'&#125;&#125;&gt;&#123;sectionData&#125;&lt;/Text&gt;&lt;/View&gt;);&#125; 5.界面显示1234567891011121314render()&#123;return (&lt;View style = &#123;styles.outerViewStyle&#125;&gt;&lt;View style=&#123;styles.headerViewStyle&#125;&gt;&lt;Text style=&#123;&#123;color:'white',fontSize:25&#125;&#125;&gt;车的品牌&lt;/Text&gt;&lt;/View&gt;&lt;ListViewdataSource=&#123;this.state.dataSource&#125;renderRow=&#123;this.renderRow&#125;renderSectionHeader=&#123;this.renderSectionHeader&#125;/&gt;&lt;/View&gt;);&#125;, 上一个效果图： 由于本人也是刚刚窥探rn，所以很多地方都是不求甚解，所以很多地方没有给出相应的解释，还请见谅！这里给出源码，大家可以共同学习！ 怒戳我，得源码！]]></content>
      <categories>
        <category>react-native学习笔记</category>
      </categories>
      <tags>
        <tag>listView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moya + RxSwift 进行网络请求]]></title>
    <url>%2F2017%2F03%2F13%2Fmoya%2F</url>
    <content type="text"><![CDATA[如在OC中使用AFNetworking一般,Swift我们用Alamofire来做网络库.而Moya在Alamofire的基础上又封装了一层: 1.关于moya 官方说moya有以下特性-_-: 编译时检查正确的API端点访问. 使你定义不同端点枚举值对应相应的用途更加明晰. 提高测试地位从而使单元测试更加容易. 2.开始 ### 1.创建枚举API 就像这样: 1234567enum APIManager &#123; case getNewsLatest//获取最新消息 case getStartImage// 启动界面图像获取 case getVersion(String)//软件版本查询 case getThemes//主题日报列表查看 case getNewsDetail(Int)//获取新闻详情&#125; ### 2.实现TargetType协议 就像这样: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970extension APIManager: TargetType &#123;/// The target's base `URL`.var baseURL: URL &#123;return URL.init(string: "http://news-at.zhihu.com/api/")!&#125;/// The path to be appended to `baseURL` to form the full `URL`.var path: String &#123;switch self &#123;case .getNewsLatest:return "4/news/latest"case .getStartImage://start-image 后为图像分辨率，接受任意的 number*number 格式， number 为任意非负整数，返回值均相同。return "4/start-image/1080*1776"case .getVersion(let version)://URL 最后部分的数字代表所安装『知乎日报』的版本return "4/version/ios/" + versioncase .getThemes:return "4/themes"case .getNewsDetail(let id):return "4/news/\(id)"&#125;&#125;/// The HTTP method used in the request.var method: Moya.Method &#123;return .get&#125;/// The parameters to be incoded in the request.var parameters: [String: Any]? &#123;return nil&#125;/// The method used for parameter encoding.var parameterEncoding: ParameterEncoding &#123;return URLEncoding.default&#125;/// Provides stub data for use in testing.var sampleData: Data &#123;return "".data(using: String.Encoding.utf8)!&#125;/// The type of HTTP task to be performed.var task: Task &#123;return .request&#125;/// Whether or not to perform Alamofire validation. Defaults to `false`.var validate: Bool &#123;return false&#125;&#125; 在这里,可以设置请求的参数,例如url……method……para等. ### 3.使用 Moya的使用非常简单，通过TargetType协议定义好每个target之后，就可以直接使用Moya开始发送网络请求了。就像这样: 1234let provider = MoyaProvider&lt;APIManager&gt;()provider.request(.getNewsLatest) &#123; result in// do something with result&#125; 3.配合RxSwiftMoya本身已经是一个使用起来非常方便，能够写出非常简洁优雅的代码的网络封装库，但是让Moya变得更加强大的原因之一还因为它对于Functional Reactive Programming的扩展，具体说就是对于RxSwift和ReactiveCocoa的扩展，通过与这两个库的结合，能让Moya变得更加强大。我选择RxSwift的原因有两个，一个是RxSwift的库相对来说比较轻量级，语法更新相对来说比较少，我之前用过ReactiveCocoa，一些大版本的更新需求重写很多代码，第二个更重要的原因是因为RxSwift背后有整个ReactiveX的支持，里面包括Java，JS，.Net, Swift，Scala，它们内部都用了ReactiveX的逻辑思想，这意味着你一旦学会了其中的一个，以后可以很快的上手ReactiveX中的其他语言。 Moya提供了非常方面的RxSwift扩展： 123456789let provider = RxMoyaProvider&lt;APIManager&gt;()provider.request(.getNewsLatest).filterSuccessfulStatusCodes().mapJSON().subscribe(onNext: &#123; (json) in//do something with postsprint(json)&#125;).addDisposableTo(disposeBag) 解释一下: RxMoyaProvider是MoyaProvider的子类，是对RxSwift的扩展 filterSuccessfulStatusCodes()是Moya为RxSwift提供的扩展方法，顾名思义，可以得到成功地网络请求，忽略其他的 mapJSON()也是Moya RxSwift的扩展方法，可以把返回的数据解析成 JSON 格式 subscribe 是一个RxSwift的方法，对经过一层一层处理的 Observable 订阅一个 onNext 的 observer，一旦得到 JSON 格式的数据，就会经行相应的处理 addDisposableTo(disposeBag) 是 RxSwift 的一个自动内存处理机制，跟ARC有点类似，会自动清理不需要的对象。 4.配合HandyJSON在实际应用过程中网络请求往往紧密连接着数据层（Model），具体地说，在我们的这个例子中，一般我们需要建立一个类用来统一管理数据，然后把得到的 JSON 数据映射到数据层（Model）。 12345678910111213struct MenuModel: HandyJSON &#123; var others: [ThemeModel]?&#125;struct ThemeModel: HandyJSON &#123; var color: String? var thumbnail: String? var id: Int? var description: String? var name: String?&#125; 然后创建ViewModel类,创建具体请求方法: 1234567891011121314151617181920class MenuViewModel &#123;private let provider = RxMoyaProvider&lt;APIManager&gt;()var dispose = DisposeBag()func getThemes(completed: @escaping (_ menuModel: MenuModel) -&gt; ())&#123;provider.request(.getThemes).mapModel(MenuModel.self).subscribe(onNext: &#123; (model) incompleted(model)&#125;, onError: &#123; (error) in&#125;, onCompleted: nil, onDisposed: nil).addDisposableTo(dispose)&#125;&#125; 这里解释一下:我这里是将请求的数据通过闭包传了出去,当然也可以不那么做.个人喜好问题.. 这里是为 RxSwift 中的 ObservableType和 Response写一个简单的扩展方法 mapModel，利用我们写好的Model 类，一步就把JSON数据映射成 model。1234567891011121314extension ObservableType where E == Response &#123;public func mapModel&lt;T: HandyJSON&gt;(_ type: T.Type) -&gt; Observable&lt;T&gt; &#123;return flatMap &#123; response -&gt; Observable&lt;T&gt; inreturn Observable.just(response.mapModel(T.self))&#125;&#125;&#125;extension Response &#123;func mapModel&lt;T: HandyJSON&gt;(_ type: T.Type) -&gt; T &#123;let jsonString = String.init(data: data, encoding: .utf8)return JSONDeserializer&lt;T&gt;.deserializeFrom(json: jsonString)!&#125;&#125; 5.配合ObjectMapper毕竟将json数据转换成model的库那么多 ….,所以……,用哪个很随意…..这里再介绍一下ObjectMapper 1.创建model类 1234567891011121314151617181920212223242526272829303132333435363738class DetailModel: Mappable &#123;var body = String()var image_source: String?var title = String()var image: String?var share_url = String()var js = String()var recommenders = [[String: String]]()var ga_prefix = String()var section: DetailSectionModel?var type = Int()var id = Int()var css = [String]()func mapping(map: Map) &#123;body &lt;- map["body"]image_source &lt;- map["image_source"]title &lt;- map["title"]image &lt;- map["image"]share_url &lt;- map["share_url"]js &lt;- map["js"]recommenders &lt;- map["recommenders"]ga_prefix &lt;- map["ga_prefix"]section &lt;- map["section"]type &lt;- map["type"]id &lt;- map["id"]css &lt;- map["css"]&#125;required init?(map: Map) &#123;&#125;&#125; 使用 ObjectMapper ，需要让自己的 Model 类使用 Mappable 协议，这个协议包括两个方法： 123required init?(map: Map) &#123;&#125;func mapping(map: Map) &#123;&#125; 在 mapping 方法中，用 &lt;- 操作符来处理和映射你的 JSON数据。 数据类建立好之后，我们还需要为 RxSwift 中的 Observable 写一个简单的扩展方法 mapObject，利用我们写好的model 类，一步就把JSON 数据映射成一个个 model。 123456789101112131415161718192021222324252627282930313233343536extension Observable &#123;func mapObject&lt;T: Mappable&gt;(type: T.Type) -&gt; Observable&lt;T&gt; &#123;return self.map &#123; response in//if response is a dictionary, then use ObjectMapper to map the dictionary//if not throw an errorguard let dict = response as? [String: Any] else &#123;throw RxSwiftMoyaError.ParseJSONError&#125;return Mapper&lt;T&gt;().map(JSON: dict)!&#125;&#125;func mapArray&lt;T: Mappable&gt;(type: T.Type) -&gt; Observable&lt;[T]&gt; &#123;return self.map &#123; response in//if response is an array of dictionaries, then use ObjectMapper to map the dictionary//if not, throw an errorguard let array = response as? [Any] else &#123;throw RxSwiftMoyaError.ParseJSONError&#125;guard let dicts = array as? [[String: Any]] else &#123;throw RxSwiftMoyaError.ParseJSONError&#125;return Mapper&lt;T&gt;().mapArray(JSONArray: dicts)!&#125;&#125;&#125;enum RxSwiftMoyaError: String &#123;case ParseJSONErrorcase OtherError&#125;extension RxSwiftMoyaError: Swift.Error &#123; &#125; mapObject 方法处理单个对象，mapArray 方法处理对象数组。 如果传进来的数据 response 是一个 dictionary，那么就利用 ObjectMapper 的 map方法映射这些数据，这个方法会调用你之前在 mapping方法里面定义的逻辑。 如果 response 不是一个 dictionary， 那么就抛出一个错误。 在底部自定义了简单的Error，继承了Swift 的 Error类，在实际应用过程中可以根据需要提供自己想要的 Error。 然后运行请求方法: 1234567891011121314class DetailViewModel &#123;private let provider = RxMoyaProvider&lt;APIManager&gt;()func getNewsDetail(id: Int) -&gt; Observable&lt;DetailModel&gt; &#123;return provider.request(.getNewsDetail(id)).filterSuccessfulStatusCodes().mapJSON().mapObject(type: DetailModel.self)&#125;&#125; 有没有感觉很爽呢!————源码地址,共同学习! 有不对之处,,,,还望各路大神不吝指正!]]></content>
      <categories>
        <category>swift学习笔记</category>
      </categories>
      <tags>
        <tag>moya + RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxSwift的简单使用]]></title>
    <url>%2F2017%2F03%2F13%2FRxSwift%2F</url>
    <content type="text"><![CDATA[RxSwift为ReactiveX（Reactive Extensions）旗下的Swift语言库，提供了Swift平台上进行响应式编程的解决方案。Rx的重要角色为Observable（被观察者）和Observer（观察者），Observable类似于ReactiveCocoa中的Signal，里面装有事件流，供Observer订阅。事件流在Rx中与ReactiveCocoa一样具有三类：Next、Error、Completed，代表着继续事件、错误事件、完成事件。我们在使用RxSwift进行iOS开发时，通常会引入另外一个库：RxCocoa，这个库将UIKit以及Foundation框架中许多成员，如视图(View)、控制事件(Control Event)、键值观察（KVO）、通知（Notification）等等进行与RxSwift接入的扩展，将Rx与iOS API无缝连接。 1. bindTobindTo为ObservableType协议的几个重载方法（Observable也会实现ObservableType协议）。顾名思义，它会将某个东东与一个可观察者进行绑定，也就是说，当这个可观察者的事件流中有事件“流过”（有事件元素发送），被绑定的这个东东就会被刺激到，进而进行相关的操作。 在这里，有一个用的比较多的是重载方法为bindTo&lt;O : ObserverType where O.E == E&gt;(observer: O) -&gt; Disposable，这个方法有一个参数，从方法泛型的声明中可以得知，参数的类型为一个观察者类型，且这个观察者能够接受到的事件流元素的类型要跟被观察者的一样(O.E == E)。这个方法意图就是将一个被观察者与一个指定的观察者进行绑定，被观察者事件流中发出的所有事件元素都会让观察者接收。在MVVM架构模式中，此方法主要用于视图（View）层跟视图模型（ViewModel）层或视图层跟视图层的绑定，这里举个栗子： 123textField.rx_text.bindTo(label.rx_text).addDisposableTo(disposeBag) 其中，UITextField的rx_text属性为ControlProperty类型，实现了ControlPropertyType，所以不仅是观察者类型，还是被观察者类型，UILabel中的rx_text只是单纯的观察者类型。 bindTo的另外一个用得比较多的重载方法为：bindTo(variable: RxSwift.Variable&lt;Self.E&gt;) -&gt; Disposable，这个方法将一个被观察者与一个Variable（变量）绑定在一起，这个变量的元素类型跟被观察者的事件元素类型一致。此方法作用就是把从被观察者事件流中发射出的事件元素存入变量中，在这里不做演示。关于bindTo的其他重载方法在这里就不完全阐述了，剩下的主要是用于对函数的绑定。 2.UIBindingObserver现在介绍的这个东东就跟上面说的被观察者类型的bindTo方法密切相关了。UIBindingObserver，名字就告诉了我们它是一个观察者，用于对UI的绑定，我这里通过一个例子来讲解它： 1234567891011121314// MARK: - 绑定方法func binding() &#123; textField.rx_text .bindTo(label.rx_sayHelloObserver) .addDisposableTo(disposeBag)&#125;// MARK: - 视图控件扩展private extension UILabel &#123; var rx_sayHelloObserver: AnyObserver&lt;String&gt; &#123; return UIBindingObserver(UIElement: self, binding: &#123; (label, string) in label.text = "Hello \(string)" &#125;).asObserver() &#125;&#125; 上面的代码中，我在视图控制器ViewController所在的Swift文件中创建了一个私有的UILabel扩展，并在扩展中定义了一个只读计算属性，属性的类型为AnyObserver&lt;String&gt;，为一个事件元素是String的观察者类型。当获取这个属性值的时候，就返回了与特定UIBindingObserver关联的观察者。现在我们来看一下UIBindingObserver的构造方法： 1init(UIElement: UIElementType, binding: (UIElementType, Value) -&gt; Void) 方法的第一个参数就是传入一个要被绑定的视图的实例，由于现在是在UILabel的扩展中，所以这里我传入了self，代表UILabel自己；构造方法的第二个参数为一个无返回值的闭包类型，闭包的参数其一就是被绑定了的视图，其二就是由绑定的被观察者中所发射出来的事件元素。通过这个闭包，我们能够将视图中的某些属性根据相应的事件元素而进行改变，如例子中label.text = &quot;Hello \(string)&quot;。当我们执行例子中的binding函数进行绑定后，TextField中的字符串每经过修改，Label中的文字总会实时更新，并在字符串前面加上Hello。 在RxCocoa框架中，某些地方也用到了UIBindingObserver，如UILable中的rx_text： 12345public var rx_text: AnyObserver&lt;String&gt; &#123; return UIBindingObserver(UIElement: self) &#123; label, text in label.text = text &#125;.asObserver()&#125; 3.DriverDriver从名字上可以理解为驱动（我自己会亲切地把它叫做”老司机”），在功能上它类似被观察者（Observable），而它本身也可以与被观察者相互转换（Observable: asDriver, Driver: asObservable），它驱动着一个观察者，当它的事件流中有事件涌出时，被它驱动着的观察者就能进行相应的操作。一般我们会将一个Observable被观察者转换成Driver后再进行驱动操作： 我们沿用上面例子中的UILabel私有扩展，并修改下binding方法： 123456func binding() &#123; textField.rx_text .asDriver() .drive(label.rx_sayHelloObserver) .addDisposableTo(disposeBag)&#125; 可见，Driver的drive方法与Observable的方法bindTo用法非常相似，事实上，它们的作用也是一样，说白了就是被观察者与观察者的绑定。那为什么RxSwift的作者又搞出Driver这么个东西来呢？其实，比较与Observable，Driver有以下的特性： 它不会发射出错误(Error)事件 对它的观察订阅是发生在主线程(UI线程)的 自带shareReplayLatestWhileConnected 下面就围绕着这三个特性一一研究下： 当你将一个Observable转换成Driver时，用到的asDriver方法有下面几个重载： 12345asDriver(onErrorJustReturn onErrorJustReturn: Self.E)asDriver(onErrorDriveWith onErrorDriveWith: RxCocoa.Driver&lt;Self.E&gt;)asDriver(onErrorRecover onErrorRecover: (error: ErrorType) -&gt; RxCocoa.Driver&lt;Self.E&gt;) 从这三个重载方法中可看出，当我们要将有可能会发出错误事件的Observable转换成Driver时，必须要先将所有可能发出的错误事件滤除掉，从而使得Driver不可能会发射出错误的事件。 在Observable中假如你要进行限流，你要用到方法throttle(dueTime: RxSwift.RxTimeInterval, scheduler: SchedulerType)，方法的第一个参数是两个事件之间的间隔时间，第二个参数是一个线程的有关类，如我要在主线程中，我可以传入MainScheduler.instance。而在Driver中我们要限流，调用的是throttle(dueTime: RxSwift.RxTimeInterval)，只配置事件的间隔时间，而它默认会在主线程中进行。 一般我们在对Observable进行map操作后，我们会在后面加上shareReplay(1)或shareReplayLatestWhileConnected，以防止以后被观察者被多次订阅观察后，map中的语句会多次调用： 123456789let rx_textChange = textField.rx_text.map &#123; return "Good \($0)" &#125;.shareReplay(1)rx_textChange.subscribeNext &#123; print("1 -- \($0)") &#125;.addDisposableTo(disposeBag)rx_textChange.subscribeNext &#123; print("2 -- \($0)") &#125;.addDisposableTo(disposeBag) 在Driver中，框架已经默认帮我们加上了shareReplayLatestWhileConnected，所以我们也没必要再加上&quot;replay&quot;相关的语句了。 从这些特性可以看出，Driver是一个专门针对于UI的特定可观察者类。并不是说对UI进行相应绑定操作不能使用纯粹的Observable，但是，Driver已经帮我们省去了好多的操作，让我们对UI的绑定更加的高效便捷。所以，对UI视图的绑定操作，我们首选“老司机”Driver。 4.DisposeBag当一个Observable（被观察者）被观察订阅后，就会产生一个Disposable实例，通过这个实例，我们就能进行资源的释放了。对于RxSwift中资源的释放，也就是解除绑定、释放空间，有两种方法，分别是显式释放以及隐式释放： 显式释放 可以让我们在代码中直接调用释放方法进行资源的释放，如下面的实例： 123let dispose = textField.rx_text.bindTo(label.rx_sayHelloObserver)dispose.dispose() 这个例子只是为了更明朗地说明显式释放方法而已，实际上并不会这样写。 隐式释放 则通过DisposeBag来进行，它类似于Objective-C ARC中的自动释放池机制，当我们创建了某个实例后，会被添加到所在线程的自动释放池中，而自动释放池会在一个RunLoop周期后进行池子的释放与重建；DisposeBag对于RxSwift就像自动释放池一样，我们把资源添加到DisposeBag中，让资源随着DisposeBag一起释放。如下实例： 123456let disposeBag = DisposeBag()func binding() &#123; textField.rx_text .bindTo(label.rx_sayHelloObserver) .addDisposableTo(self.disposeBag)&#125; 方法addDisposableTo会对DisposeBag进行弱引用，所以这个DisposeBag要被实例引用着，一般可作为实例的成员变量，当实例被销毁了，成员DisposeBag会跟着销毁，从而使得RxSwift在此实例上绑定的资源得到释放。 对于UITableViewCell跟UICollectionViewCell来说，DisposeBag也能让cell在重用前释放掉之前被绑定的资源： 1234567891011121314151617class TanTableViewCell: UITableViewCell &#123; var disposeBag: DisposeBag? var viewModel: TanCellViewModel? &#123; didSet &#123; let disposeBag = DisposeBag() viewModel?.title .drive(self.textLabel!.rx_text) .addDisposableTo(disposeBag) self.disposeBag = disposeBag &#125; &#125; override func prepareForReuse() &#123; super.prepareForReuse() self.disposeBag = nil &#125;&#125; 5.DataSource这里主要讲解的是RxCocoa框架中带有的对于UITableView以及UICollectionView数据源的解决方案，在GitHub中也有一个开源小库RxDataSource，在这里我就不再研究了，有兴趣的朋友可以去看看：GitHub RxDataSource。我这里用一个例子来展示下RxCocoa中的简单UITableView数据源： 12345678910111213141516171819202122232425262728293031class TanViewController: UIViewController &#123;var disposeBag = DisposeBag()let data = [TanCellViewModel(title: "One"), TanCellViewModel(title: "Two"), TanCellViewModel(title: "Three")]override func viewDidLoad() &#123; super.viewDidLoad() self.view.addSubview(self.tableView) self.tableView.frame = self.view.bounds self.binging()&#125;private func binging() &#123;Observable.just(self.data).asDriver(onErrorJustReturn: []).drive(self.tableView.rx_itemsWithCellIdentifier(TanTableViewCell.CELL_IDENTIFIER, cellType: TanTableViewCell.self)) &#123; (_, viewModel, cell) incell.viewModel = viewModel&#125;.addDisposableTo(self.disposeBag)&#125;// MARK: - Lazyprivate var tableView: UITableView = &#123;let tableView = UITableView(frame: CGRectZero, style: .Plain)tableView.registerClass(TanTableViewCell.self, forCellReuseIdentifier: TanTableViewCell.CELL_IDENTIFIER)return tableView&#125;()&#125; 如上，我们能够将数据封装在Observable中，然后把Observable绑定到UITableView中，通过UITableView的方法rx_itemsWithCellIdentifier，我们就能够进行数据跟Cell的一一对应配置。到此，UITableView的数据源就设置好了。UICollectionView的数据源设置跟UITableView差不多，在这里就不再作例子了。 6.项目实战下面就是重头戏了，我将通过折腾出一个小项目来演示RxSwift的使用，包括基础以及进阶的内容，首先来设定下这个项目：说简单点，就是做一个登录界面（万能Demo），输入用户号码跟密码，点击登录按钮，即可登录获取数据。说复杂点，我们要完成下面的要求： 用户号码输入框要判断用户输入的是否全是数字，若格式不正确，提示用户格式错误。 号码输入框输入的数字最少要有11位，密码输入框输入的字符串长度最少要有6位。 要满足上面的两条要求，登录按钮才可以点击。 登录按钮点击后进行登录，界面显示正在转动的等待视图，当接收到后台数据时，等待视图消失。 解析后台返回的数据，并把数据呈现到界面中。 在这个项目中，我还是使用熟悉的MVVM架构模式。在开干之前我首先要说几点： RxSwift中的ViewModel是没有什么明确的状态的，它的输出由输入决定，可以这么说，我们要使用RxSwift将ViewModel中的外界输入（UI触发、外界事件）转换成输出，再由这些输出去驱动UI界面，并且，ViewModel做的是转换，我们不能够在其中对某个Observable进行订阅操作，所以，在ViewModel中我们是看不到addDisposableTo的。 我对比了一下由ReactiveCocoa与RxSwift实现的ViewModel，发现使用ReactiveCocoa实现的ViewModel中会有比较多的明确状态变量，比如说现在实现的是登录的界面，在ReactiveCocoa的ViewModel中我们会看到有&quot;userName&quot;、&quot;passWord“等等之类的状态变量，它是由ReactiveCocoa将其与UI视图属性相绑定的：RAC(self.viewModel, userName) = userNameTextField.rac_textSignal;，而在RxSwift实现的ViewModel，就不会看到这些状态变量了，有的是驱动外界UI的输出Driver，个人认为RxSwift实现ViewModel的宗旨是将外界视图的输入经过转变产生输出，在让输出去驱动回UI视图，所以我在构建ViewModel类的时候，会在它的构造方法中开设一个接收输入的参数，其次就在后面的控制器绑定中将ViewModel的输出进行订阅，驱动视图层。 这个项目我使用的第三方库有RxSwift、RxCocoa、Moya、Argo、Curry，前面两个在上面有说到；Moya是一款Swift语言的网络请求框架，它是另一款网络请求框架Alamofire的再度封装，它有基于RxSwift的扩展，能与RxSwift无缝对接；Argo是一款小巧的JSON解析库，函数柯里化(Currying)库Curry配合着它一起使用，而且，Argo的解析语法非常新颖奇特，用着感觉非常过瘾！ .界面在Storyboard中布局好登录界面，分别有用户电话号码的输入框、用户密码输入框、等待视图（菊花）、提示视图（用于提醒输入的错误，以及登录的状态）、登录按钮： .Entity 实体下面进行实体类(Entity)的构建： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import UIKitimport RxSwiftimport RxCocoaimport Argoimport Moyaimport Curry// MARK: - Userstruct User &#123; let name: String let userToken: String&#125;extension User: Decodable &#123; static func decode(json: JSON) -&gt; Decoded&lt;User&gt; &#123; return curry(self.init) &lt;^&gt; json &lt;| "name" &lt;*&gt; json &lt;| "user_token" &#125;&#125;// MARK: - ResponseResultenum ResponseResult &#123; case succeed(user: User) case faild(message: String)var user: User? &#123; switch self &#123; case let .succeed(user): return user case .faild: return nil &#125; &#125;&#125;extension ResponseResult: Decodable &#123; init(statusCode: Int, message: String, user: User?) &#123; if statusCode == 200 &amp;&amp; user != nil &#123; self = .succeed(user: user!) &#125;else&#123; self = .faild(message: message) &#125;&#125;static func decode(json: JSON) -&gt; Decoded&lt;ResponseResult&gt; &#123; return curry(self.init) &lt;^&gt; json &lt;| "status_code" &lt;*&gt; json &lt;| "message" &lt;*&gt; json &lt;|? "user" &#125;&#125;// MARK: - ValidateResultenum ValidateResult &#123; case succeed case faild(message: String) case empty&#125;infix operator ^-^ &#123;&#125;func ^-^ (lhs: ValidateResult, rhs: ValidateResult) -&gt; Bool &#123; switch (lhs, rhs) &#123; case (.succeed, .succeed): return true default: return false &#125;&#125;// MARK: - RequestTargetenum RequestTarget &#123; case login(telNum: String, password: String)&#125;extension RequestTarget: TargetType &#123; var baseURL: NSURL &#123; return NSURL(string: "")!&#125;var path: String &#123; return "/login"&#125;var method: Moya.Method &#123; return .POST&#125;var parameters: [String: AnyObject]? &#123; switch self &#123; case let .login(telNum, password): return ["tel_num": telNum, "password": password] default: () &#125;&#125;var sampleData: NSData &#123; let jsonString = "&#123;\"status_code\":200, \"message\":\"登录成功\", \"user\":&#123;\"name\":\"Tangent\",\"user_token\":\"abcdefg123456\"&#125;&#125;" return jsonString.dataUsingEncoding(NSUTF8StringEncoding)! &#125;&#125; User 用户类，登录成功后，后台会返回用户的个人信息，包括用户名称以及用户的登录令牌。 ResponseResult网络请求返回类，枚举类型，成功的话它的关联值是一个用户类型，失败的话它就会有信息字符串关联。它的构造中靠的是状态码来完成，若后台返回的状态码为200，表示登录成功，返回用户，若为其他，表明登录失败，并返回错误信息。这里的decode方法为Argo解析所需实现的。 ValidateResult 验证类，如验证电话号码是否格式正确，号码或密码的长度是否达到要求等等，失败的时候会有错误信息相关联。 RequestTarget 请求目标，为Moya框架定制的网络请求类。 .ViewModelServer 服务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import UIKitimport RxCocoaimport RxSwiftimport Moyaimport Argo// MARK: - ValidateServerclass ValidateServer &#123;static let instance = ValidateServer()class func shareInstance() -&gt; ValidateServer &#123;return self.instance&#125;let minTelNumCount = 11let minPasswordCount = 6func validateTelNum(telNum: String) -&gt; ValidateResult &#123;guard let _ = Int(telNum) else &#123; return .faild(message: "号码格式错误") &#125;return telNum.characters.count &gt;= self.minTelNumCount ? .succeed : .faild(message: "号码长度不足")&#125;func validatePassword(password: String) -&gt; ValidateResult &#123;return password.characters.count &gt;= self.minPasswordCount ? .succeed : .faild(message: "密码长度不足")&#125;&#125;// MARK: - NetworkServerclass NetworkServer &#123;static let instance = NetworkServer()class func shareInstace() -&gt; NetworkServer &#123;return self.instance&#125;// Lazyprivate lazy var provider: RxMoyaProvider = &#123;return RxMoyaProvider&lt;RequestTarget&gt;(stubClosure: MoyaProvider.ImmediatelyStub)&#125;()func loginWork(telNum: String, password: String) -&gt; Driver&lt;ResponseResult&gt; &#123;return self.provider.request(.login(telNum: telNum, password: password)).mapJSON().map &#123; jsonObject -&gt; ResponseResult inlet decodeResult: Decoded&lt;ResponseResult&gt; = decode(jsonObject)return try decodeResult.dematerialize()&#125;.asDriver(onErrorJustReturn: .faild(message: "网络或数据解析错误！"))&#125;&#125; 在这里有两个服务类，第一个为验证服务类，用于验证用户号码格式以及号码或密码的长度是否达到要求，第二个为网络请求类，用于向后台请求登录，这里要注意的是，RxMoyaProvider一定要被类引用，否则若把它设置为局部变量，请求就不能完成。在构建RxMoyaProvider的时候，我在构造方法中传入了MoyaProvider.ImmediatelyStub这个stubClosure参数，为的是测试，这样子系统就不会请求网络，而是直接通过获取Target的sampleData属性。 .ViewModel 视图模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import UIKitimport RxSwiftimport RxCocoaclass ViewModel &#123;// MARK: - Outputlet juhuaShow: Driver&lt;Bool&gt;let loginEnable: Driver&lt;Bool&gt;let tipString: Driver&lt;String&gt;init(input: (telNum: Driver&lt;String&gt;, password: Driver&lt;String&gt;, loginTap: Driver&lt;Void&gt;),dependency: (validateServer: ValidateServer, networkServer: NetworkServer)) &#123;let telNumValidate = input.telNum.distinctUntilChanged().map &#123; return dependency.validateServer.validateTelNum($0) &#125;let passwordValidate = input.password.distinctUntilChanged().map &#123; return dependency.validateServer.validatePassword($0) &#125;let validateString = [telNumValidate, passwordValidate].combineLatest &#123; result -&gt; String invar validateString = ""if case let .faild(message) = result[0] &#123;validateString = "\(message)"&#125;if case let .faild(message) = result[1] &#123;validateString = "\(validateString) \(message)"&#125;return validateString&#125;let telNumAndPassWord = Driver.combineLatest(input.telNum, input.password) &#123; ($0, $1) &#125;let loginString = input.loginTap.withLatestFrom(telNumAndPassWord).flatMapLatest &#123;return dependency.networkServer.loginWork($0.0, password: $0.1)&#125;.map &#123; result -&gt; String inswitch result &#123;case let .faild(message):return "登录失败 \(message)"case let .succeed(user):return "登录成功，用户名:\(user.name)，标识符:\(user.userToken)"&#125;&#125;self.loginEnable = [telNumValidate, passwordValidate].combineLatest &#123; result -&gt; Bool inreturn result[0] ^-^ result[1]&#125;self.juhuaShow = Driver.of(loginString.map&#123;_ in false&#125;, input.loginTap.map&#123;_ in true&#125;).merge()self.tipString = Driver.of(validateString, loginString).merge()&#125;&#125; ViewModel相对来说比较难搞，毕竟我们要处理好每一个输入输出的关系，灵活进行转变。在这里，没有显式的状态变量，只有对外的输出以及构造时对内的输入，思想就是将输入流进行加工转变成输出流，数据在传输中能够单向传递。 .ViewController 视图控制器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import UIKitimport RxSwiftimport RxCocoaclass ViewController: UIViewController &#123;@IBOutlet weak var telNumTF: UITextField!@IBOutlet weak var passWordTF: UITextField!@IBOutlet weak var juhuaView: UIActivityIndicatorView!@IBOutlet weak var loginBtn: UIButton!@IBOutlet weak var tipLb: UILabel!private var viewModel: ViewModel?private var disposeBag = DisposeBag()override func viewDidLoad() &#123;super.viewDidLoad()self.viewModel = ViewModel(input: (self.telNumTF.rx_text.asDriver(),self.passWordTF.rx_text.asDriver(),self.loginBtn.rx_tap.asDriver()),dependency: (ValidateServer.shareInstance(),NetworkServer.shareInstace()))// Bindingself.viewModel!.juhuaShow.drive(self.juhuaView.rx_animating).addDisposableTo(self.disposeBag)self.viewModel!.loginEnable.drive(self.loginBtn.rx_loginEnable).addDisposableTo(self.disposeBag)self.viewModel!.tipString.drive(self.tipLb.rx_text).addDisposableTo(self.disposeBag)&#125;&#125;private extension UIButton &#123;var rx_loginEnable: AnyObserver&lt;Bool&gt; &#123;return UIBindingObserver(UIElement: self, binding: &#123; (button, bool) inself.enabled = boolif bool &#123;button.backgroundColor = UIColor.greenColor()&#125;else&#123;button.backgroundColor = UIColor.redColor()&#125;&#125;).asObserver()&#125;&#125; 在这里，我们构建好ViewModel，将输入以及视图模型依赖的服务传入ViewModel构造方法中，并在下面把ViewModel的输入去驱动UI视图。 源码地址]]></content>
      <categories>
        <category>swift学习笔记</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift 之循环语句和闭包]]></title>
    <url>%2F2017%2F03%2F08%2Fswift-closure%2F</url>
    <content type="text"><![CDATA[swift简介: 苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可与Objective-C共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。2015年12月4日，苹果公司宣布其Swift编程语言现在开放源代码。 1.流程控制swift使用三种语句控制流程：for-in、for、switch-case、while和repeat-while，且判断条件的括号可以省略 for-in 循环 12345678let names = ["Jack", "Rose", "Mike", "Puppy"]for name in names &#123;print("Hello, \(name)!")&#125;//如果不需要使用到迭代的值，使用下划线`_`忽略该值for _ in 1...10print("hello") if 语句 原来在oc中,if后的条件语句可以是这样: 1234假设judge是一个BOOL型或NSString或NSArray或NSDictionary等类型if (judge)&#123;//write code...&#125; 但在swift中,if后的条件返回值必须是Bool型,在写成上面的那种情形就会报错…. 所以在swift中这样写: 123if judge == true &#123;//write code...&#125; 在Swift2.0以后，不支持do-while语句，使用repeat-while代替，用法与do-while一样: 1234repeat &#123; print("repeat while : \(j)") j++ &#125; while j &lt; 3 guard-else 保镖模式 在执行操作前，进行检查，如果不符合，则拦截，使用方式与if有些类似，如果与let结合使用，可以对可选类型解包，先看看普通的if-else模式: 12345678func test(i: Int?) &#123; if let i = i where i &gt; 0 &#123; // 符合条件的处理 return &#125;// 不符合条件的处理&#125; 上面的处理把条件放在了条件判断内部，使用guard与之相反，把正确的情况放在最外部，而异常情况放在条件判断内部: 123456789func test(i: Int?) &#123; guard let i = i where i &gt; 0 else &#123; // 在这里拦截，处理不符合条件的情况 return &#125; // 符合条件的处理，这个时候已经对i进行了拆包，i是非可选类型，可以直接使用 print(i)&#125; 保镖模式可以避免代码中过多的流程判断代码导致过多的代码块嵌套，增强可读性!!! 保镖模式guard-else内的代码块必须包含break, return等跳出代码块的关键字 switch-case swift中的switch语句最明显的区别于oc的地方在于,不需要break 2. 函数(方法)1.基本形式1234567891011121314151617///单个返回值func 函数名称(参数1: 参数1类型, 参数2: 参数2类型) -&gt; 返回值 &#123;//函数体&#125;///多个返回值(元组)func 函数名称(参数1: 参数1类型, 参数2: 参数2类型) -&gt; (x: String, y: Int) &#123;//函数体return ("abc", 3)&#125;///无返回值func 函数名 &#123;&#125; 还有一种相当于oc中的加号方法: 123class func 函数名(参数: 参数类型) -&gt; 返回值类型 &#123;&#125; 2.闭包1234///闭包函数声明形式:&#123; (parameters) -&gt; returnType instatements // 可以有多行&#125; 闭包函数 1234567891011121314151617181920//定义一个函数变量var addfunc: (Int, Int) -&gt; Int//闭包的写法// 1. 完整写法addfunc = &#123;(a: Int, b: Int) -&gt; (Int) in//var c = a + 1 //函数体可以有多条语句，如果在同一行，需要用分号隔开，函数体不需要大括号return a + b&#125;// 2. 前面的addfunc变量可以推断出后面函数的参数类型和返回值类型，故可以省略addfunc = &#123;(a, b) in return a + b&#125;// 3. 参数列表括号可以省去，函数只有一条语句时，return可以省略addfunc = &#123;a, b in a + b&#125;// 4. 参数和in可以省去，通过$和索引取得参数addfunc = &#123;$0 + $1&#125;// 操作符需要的参数与函数参数一致，可以省去参数，并使用括号括起来，作为参数时，可不用括号addfunc = (+) 3.Trailing(尾行)闭包如果函数作为另一个函数的参数，并且是最后一个参数时，可以通过Trainling闭包来增强函数的可读性 123456789101112131415161718func someFunctionThatTakesAClosure(a: Int, closure: () -&gt; ()) &#123;// 函数体部分&#125;// 1. 一般形式someFunctionThatTakesAClosure(10, closure: &#123;// 闭包主体部分&#125;)// 2. Trainling闭包的方式someFunctionThatTakesAClosure(10) &#123;// 闭包主体部分&#125;// 3. 如果没有其他参数时，可以省略括号someFunctionThatTakesAClosure &#123;// 闭包主体部分&#125; 4.Escaping（逃逸）闭包如果一个闭包/函数作为参数传给另外一个函数，但这个闭包在传入函数返回之后才会执行，就称该闭包在函数中”逃逸”，需要在函数参数添加@escaping声明，来声明该闭包/函数允许从函数中”逃逸”，如下: 123456var completionHandlers: [() -&gt; Void] = []// 传入的闭包/函数并没有在函数内执行，需要在函数类型钱添加@escaping声明func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123;completionHandlers.append(completionHandler)&#125; 逃逸闭包只是一个声明，以增强函数的意图 5.自动闭包对于没有参数的闭包，swift提供了一种简写的方式，直接写函数体，不需要函数形式（返回值和参数列表），如下: 12345// 声明一个自动闭包（无参数，可以有返回值，返回值类型swift可以自动识别）let sayHello = &#123; print("hello world") &#125;//调用闭包函数sayHello() 自动闭包只是闭包的一种简写方式 如果一个函数接受一个不带参数的闭包: 12345func logIfTrue(predicate: () -&gt; Bool) &#123; if predicate() &#123; print("True") &#125;&#125; 调用: 1234logIfTrue(predicate: &#123; return 1 &lt; 2 &#125;)// 可以简化returnlogIfTrue(predicate: &#123; 1 &lt; 2 &#125;) 上面代码看起来可读性不是很好，swift引入了一个关键字@autoclosure，简化自动闭包的大括号，在闭包类型前面添加该关键字声明: 12345678func logIfTrue(predicate: @autoclosure () -&gt; Bool) &#123; if predicate() &#123; print("True") &#125;&#125;// 调用logIfTrue(predicate:1 &lt; 2) @autoclosure 关键字是为了简化闭包的写法，增强可读性，这里的例子比较简单，可以参考：了解更多点击这里]]></content>
      <categories>
        <category>swift学习笔记</category>
      </categories>
      <tags>
        <tag>closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之WiFi相关功能总结]]></title>
    <url>%2F2017%2F03%2F08%2FWiFi%2F</url>
    <content type="text"><![CDATA[iOS 开发中难免会遇到很多与网络方面的判断，这里做个汇总，大多可能是与WiFi相关的。 1.Ping域名、Ping某IP有时候可能会遇到ping 某个域名或者ip通不通，再做下一步操作。这里的ping与传统的做get或者post请求还是有很大区别的。比如我们连接了某个WiFi，测试ping www.baidu.com，如果能ping 通，基本可以断定可以上网了，但是如果我们做了一个get 请求（url 是www.baidu.com）,路由器可能重定向这个WiFi内的某网页了，依然没有错误返回，就会误认为可以正常上网。 这里有关于ping命令的详细解释：百度百科ping iOS中想要ping域名或者ip，苹果提供了一个官方例子:SimplePing 在例子中，有一个苹果已经封装过的类【SimplePing.h】和【SimplePing.m】 使用起来也相当的简单： a.首先创建一个Ping对象：123456789SimplePing *pinger = [[SimplePing alloc] initWithHostName:self.hostName];self.pinger = pinger;pinger.delegate = self;pinger.addressStyle = SimplePingAddressStyleICMPv4;[pinger start]; b.然后在start成功的代理方法中，发送数据报文：1234567891011121314/*** start成功，也就是准备工作做完后的回调*/- (void)simplePing:(SimplePing *)pinger didStartWithAddress:(NSData *)address&#123;// 发送测试报文数据[self.pinger sendPingWithData:nil];&#125;- (void)simplePing:(SimplePing *)pinger didFailWithError:(NSError *)error&#123;NSLog(@"didFailWithError");[self.pinger stop];&#125; c.其他几个代理方法也非常简单，就简单记录一下:12345678910111213141516171819202122// 发送测试报文成功的回调方法- (void)simplePing:(SimplePing *)pinger didSendPacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber&#123;NSLog(@"#%u sent", sequenceNumber);&#125;//发送测试报文失败的回调方法- (void)simplePing:(SimplePing *)pinger didFailToSendPacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber error:(NSError *)error&#123;NSLog(@"#%u send failed: %@", sequenceNumber, error);&#125;// 接收到ping的地址所返回的数据报文回调方法- (void)simplePing:(SimplePing *)pinger didReceivePingResponsePacket:(NSData *)packet sequenceNumber:(uint16_t)sequenceNumber&#123;NSLog(@"#%u received, size=%zu", sequenceNumber, packet.length);&#125;- (void)simplePing:(SimplePing *)pinger didReceiveUnexpectedPacket:(NSData *)packet&#123;NSLog(@"#%s",__func__);&#125; *********注意点：iOS 中 ping失败后（即发送测试报文成功后，一直没后收到响应的报文）,不会有任何回调方法告知我们。而一般ping 一次的结果也不太准确，ping 花费的时间也非常短，所以我们一般会ping多次，发送一次ping 测试报文0.5s后检测一下这一次ping是否已经收到响应。0.5s后检测时，如果已经收到响应，则可以ping 通；如果没有收到响应，则视为超时。 做法也有很多种，可以用NSTimer或者 {- (void)performSelector: withObject:afterDelay:} 这里有一个别人写的工程：https://github.com/lovesunstar/STPingTest 2.获取WiFi信息以前物联网刚火的时候，出现过很多一体式无线路由，所以App里难免会遇到要判断当前所连接的WiFi，以及获取WiFi信息的功能。 需要导入import SystemConfiguration.CaptiveNetwork 123456789101112131415161718192021222324252627282930313233343536//获取WiFi 信息，返回的字典中包含了WiFi的名称、路由器的Mac地址、还有一个Data(转换成字符串打印出来是wifi名称)- (NSDictionary *)fetchSSIDInfo &#123;NSArray *ifs = (__bridge_transfer NSArray *)CNCopySupportedInterfaces();if (!ifs) &#123;return nil;&#125;NSDictionary *info = nil;for (NSString *ifnam in ifs) &#123;info = (__bridge_transfer NSDictionary *)CNCopyCurrentNetworkInfo((__bridge CFStringRef)ifnam);if (info &amp;&amp; [info count]) &#123; break; &#125;&#125;return info;&#125;//打印出来的结果：2017-03-02 15:28:51.674 SimplePing[18883:6790207] WIFI_INFO:&#123;BSSID = "a4:2b:8c:c:7f:bd";SSID = bdmy06;SSIDDATA = ;&#125; 3.获取WiFi名称有了上一步，获取WiFi名称就非常简单了。 123456NSString *WiFiName = info[@"SSID"];//打印结果：2017-03-02 15:35:13.059 SimplePing[18887:6791418] bdmy06 完整的： 1234567891011121314151617181920212223242526272829303132333435- (NSString *)fetchWiFiName &#123;NSArray *ifs = (__bridge_transfer NSArray *)CNCopySupportedInterfaces();if (!ifs) &#123;return nil;&#125;NSString *WiFiName = nil;for (NSString *ifnam in ifs) &#123;NSDictionary *info = (__bridge_transfer NSDictionary *)CNCopyCurrentNetworkInfo((__bridge CFStringRef)ifnam);if (info &amp;&amp; [info count]) &#123;// 这里其实对应的有三个key:kCNNetworkInfoKeySSID、kCNNetworkInfoKeyBSSID、kCNNetworkInfoKeySSIDData，// 不过它们都是CFStringRef类型的WiFiName = [info objectForKey:(__bridge NSString *)kCNNetworkInfoKeySSID];// WiFiName = [info objectForKey:@"SSID"];break;&#125;&#125;return WiFiName;&#125; 4.获取当前所连接WiFi的网关地址12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091- (NSString *)getGatewayIpForCurrentWiFi &#123;NSString *address = @"error";struct ifaddrs *interfaces = NULL;struct ifaddrs *temp_addr = NULL;int success = 0;// retrieve the current interfaces - returns 0 on successsuccess = getifaddrs(&amp;interfaces);if (success == 0) &#123;// Loop through linked list of interfacestemp_addr = interfaces;//*/while(temp_addr != NULL) &#123;/*/int i=255;while((i--)&gt;0)//*/if(temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET) &#123;// Check if interface is en0 which is the wifi connection on the iPhoneif([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@"en0"])&#123;// Get NSString from C String //ifa_addr//ifa-&gt;ifa_dstaddr is the broadcast address, which explains the "255's"// address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_dstaddr)-&gt;sin_addr)];address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr)];//routerIP----192.168.1.255 广播地址NSLog(@"broadcast address--%@",[NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_dstaddr)-&gt;sin_addr)]);//--192.168.1.106 本机地址NSLog(@"local device ip--%@",[NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr)]);//--255.255.255.0 子网掩码地址NSLog(@"netmask--%@",[NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_netmask)-&gt;sin_addr)]);//--en0 端口地址NSLog(@"interface--%@",[NSString stringWithUTF8String:temp_addr-&gt;ifa_name]);&#125;&#125;temp_addr = temp_addr-&gt;ifa_next;&#125;&#125;// Free memoryfreeifaddrs(interfaces);in_addr_t i = inet_addr([address cStringUsingEncoding:NSUTF8StringEncoding]);in_addr_t* x = &amp;i;unsigned char *s = getdefaultgateway(x);NSString *ip=[NSString stringWithFormat:@"%d.%d.%d.%d",s[0],s[1],s[2],s[3]];free(s);return ip;&#125; 5.获取本机在WiFi环境下的IP地址12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (NSString *)getLocalIPAddressForCurrentWiFi&#123;NSString *address = nil;struct ifaddrs *interfaces = NULL;struct ifaddrs *temp_addr = NULL;int success = 0;// retrieve the current interfaces - returns 0 on successsuccess = getifaddrs(&amp;interfaces);if (success == 0) &#123;// Loop through linked list of interfacestemp_addr = interfaces;while(temp_addr != NULL) &#123;if(temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET) &#123;// Check if interface is en0 which is the wifi connection on the iPhoneif([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@"en0"]) &#123;address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr)];return address;&#125;&#125;temp_addr = temp_addr-&gt;ifa_next;&#125;freeifaddrs(interfaces);&#125;return nil;&#125; 6.获取广播地址、子网掩码、端口等12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697- (NSMutableDictionary *)getLocalInfoForCurrentWiFi &#123;NSMutableDictionary *dict = [NSMutableDictionary dictionary];struct ifaddrs *interfaces = NULL;struct ifaddrs *temp_addr = NULL;int success = 0;// retrieve the current interfaces - returns 0 on successsuccess = getifaddrs(&amp;interfaces);if (success == 0) &#123;// Loop through linked list of interfacestemp_addr = interfaces;//*/while(temp_addr != NULL) &#123;if(temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET) &#123;// Check if interface is en0 which is the wifi connection on the iPhoneif([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@"en0"]) &#123;//----192.168.1.255 广播地址NSString *broadcast = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_dstaddr)-&gt;sin_addr)];if (broadcast) &#123;[dict setObject:broadcast forKey:@"broadcast"];&#125;NSLog(@"broadcast address--%@",broadcast);//--192.168.1.106 本机地址NSString *localIp = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr)];if (localIp) &#123;[dict setObject:localIp forKey:@"localIp"];&#125;NSLog(@"local device ip--%@",localIp);//--255.255.255.0 子网掩码地址NSString *netmask = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_netmask)-&gt;sin_addr)];if (netmask) &#123;[dict setObject:netmask forKey:@"netmask"];&#125;NSLog(@"netmask--%@",netmask);//--en0 端口地址NSString *interface = [NSString stringWithUTF8String:temp_addr-&gt;ifa_name];if (interface) &#123;[dict setObject:interface forKey:@"interface"];&#125;NSLog(@"interface--%@",interface);return dict;&#125;&#125;temp_addr = temp_addr-&gt;ifa_next;&#125;&#125;// Free memoryfreeifaddrs(interfaces);return dict;&#125; 打印结果： 12345678910112017-03-02 17:59:09.257 SimplePing[19141:6830567] wifi:&#123;broadcast = "192.168.1.255";interface = en0;localIp = "192.168.1.7";netmask = "255.255.255.0";&#125;]]></content>
      <categories>
        <category>iOS 网络相关</category>
      </categories>
      <tags>
        <tag>WiFi</tag>
      </tags>
  </entry>
</search>
